/*
 * protocol.c
 *
 * Created: 02-Apr-21 2:28:54 PM
 *  Author: Mina Medhat
 */ 
#include "protocol.h"




extern volatile unsigned short MAIN_REGISTERS[20];




unsigned char MY_ADDRESS[5]={MY_PROTOCOL_ADDRESS_ARRAY_0,MY_PROTOCOL_ADDRESS_ARRAY_1,MY_PROTOCOL_ADDRESS_ARRAY_2,MY_PROTOCOL_ADDRESS_ARRAY_3,MY_PROTOCOL_ADDRESS_ARRAY_4};
volatile unsigned char MASTER_ADDRESS[5]={0,0,0,0,0};

volatile SENSOR_STATE_DT F_SENSOR_STATE=NOTCONNECTED_STATE;

unsigned char SENSOR_PASSWORD[4]={MY_PROTOCOL_PASSWORD_ARRAY_0,MY_PROTOCOL_PASSWORD_ARRAY_1,MY_PROTOCOL_PASSWORD_ARRAY_2,MY_PROTOCOL_PASSWORD_ARRAY_3};
unsigned char SENSOR_SESSION_KEY[2];

NRF_RF_CHANNEL_DT MY_CHANNELS[]={NRF_USED_CH_1,NRF_USED_CH_2,NRF_USED_CH_3,NRF_USED_CH_4,NRF_USED_CH_5,NRF_USED_CH_6,NRF_USED_CH_7,NRF_USED_CH_8};

extern volatile unsigned char C_T_BEACON;	
	
volatile unsigned char DATA_BUFFER[18];
volatile unsigned char LENGTH=0;













void PROTOCOL_SETUP()
{
	 NRF_SETUP_USED_CONFIG();
	 NRF_UPDATE_USED_CHANNEL(MY_CHANNELS[0]);
	 NRF_START_RX_MODE();
	 
}

void PROTOCOL_IO_SETUP()
{
	 NRF_IO_SETUP();
}


unsigned char PROTOCOL_CHECK_RECIVED_PACKET(unsigned char *PACKET, unsigned char CHECK_ADDRESS, unsigned char *MASTER_ADDRESS,unsigned char LENGTH_LOCAL)
{
	if (LENGTH_LOCAL!=(0b01111111 & PACKET[0]))
	{
		return 0;
	}
	if (PACKET[1]>PROTOCOL_CURRENT_VERSION)
	{
		return 0;
	}
	unsigned char i;
	if (CHECK_ADDRESS)
	{
		for(i=0;i<5;i++)
		{
		if (PACKET[2+i]!=MASTER_ADDRESS[i])
		{
			return 0;
		}
		}
	}
	
	
	
	
	volatile unsigned char HASH_VALUE[2];
	if (0b10000000&PACKET[0])
	{
		HASH_PASWORD_KEY(PACKET,HASH_VALUE,LENGTH_LOCAL-2,SENSOR_PASSWORD);
	}
	else
	{
		HASH_SESSION_KEY(PACKET,HASH_VALUE,LENGTH_LOCAL-2,SENSOR_SESSION_KEY);
	}
	if ((HASH_VALUE[0]==PACKET[LENGTH_LOCAL-2])&&(HASH_VALUE[1]==PACKET[LENGTH_LOCAL-1]))
	{
		return 1;
	}
	return 0;
	
}

unsigned char PROTOCOL_BEACON()
{
	 volatile unsigned char HASH_VALUE[2];
	 DATA_BUFFER[0]=10|0B00000000;
	 DATA_BUFFER[1]=PROTOCOL_CURRENT_VERSION;
	 DATA_BUFFER[2]=MY_PROTOCOL_ADDRESS_ARRAY_0;
	 DATA_BUFFER[3]=MY_PROTOCOL_ADDRESS_ARRAY_1;
	 DATA_BUFFER[4]=MY_PROTOCOL_ADDRESS_ARRAY_2;
	 DATA_BUFFER[5]=MY_PROTOCOL_ADDRESS_ARRAY_3;
	 DATA_BUFFER[6]=MY_PROTOCOL_ADDRESS_ARRAY_4;
	 DATA_BUFFER[7]=BEACON_RECEIVED_CODE;
	 HASH_SESSION_KEY(DATA_BUFFER,HASH_VALUE,8,SENSOR_SESSION_KEY);
	 DATA_BUFFER[8]=HASH_VALUE[0];
	 DATA_BUFFER[9]=HASH_VALUE[1];
	 if (!NRF_SEND_DATA_WITH_ACK(MASTER_ADDRESS,5,DATA_BUFFER,10))
	 {
		 return 0;
	 }
	 C_T_BEACON=0;
	 return 1;
}

unsigned char PROTOCOL_SESSION_KEY()
{
	
	unsigned char SESSION_KEY_LOCAL[2];	
	unsigned char TEMP_LOCAL=CHALLANGE_RESULT_SUCCESS;
	DECRYPT_ALGORISM_2_V1(SESSION_KEY_LOCAL,&DATA_BUFFER[8],2,SENSOR_PASSWORD);
	volatile unsigned char HASH_VALUE[2];
	DATA_BUFFER[0]=11|0B10000000;
	DATA_BUFFER[1]=PROTOCOL_CURRENT_VERSION;
	DATA_BUFFER[2]=MY_PROTOCOL_ADDRESS_ARRAY_0;
	DATA_BUFFER[3]=MY_PROTOCOL_ADDRESS_ARRAY_1;
	DATA_BUFFER[4]=MY_PROTOCOL_ADDRESS_ARRAY_2;
	DATA_BUFFER[5]=MY_PROTOCOL_ADDRESS_ARRAY_3;
	DATA_BUFFER[6]=MY_PROTOCOL_ADDRESS_ARRAY_4;
	DATA_BUFFER[7]=NEW_SESSION_KEY_APPLIED_CODE;
	ENCRYPT_ALGORISM_2_V1(&TEMP_LOCAL,&DATA_BUFFER[8],1,SENSOR_PASSWORD);
	HASH_PASWORD_KEY(DATA_BUFFER,HASH_VALUE,9,SENSOR_PASSWORD);
	DATA_BUFFER[9]=HASH_VALUE[0];
	DATA_BUFFER[10]=HASH_VALUE[1];
	if (!NRF_SEND_DATA_WITH_ACK(MASTER_ADDRESS,5,DATA_BUFFER,11))
	{
		/*REMOVE THIS IF IT DIDNOT WORK*/
		SENSOR_SESSION_KEY[0]=SESSION_KEY_LOCAL[0];
		SENSOR_SESSION_KEY[1]=SESSION_KEY_LOCAL[1];
		/**/
		return 0;
	}
	SENSOR_SESSION_KEY[0]=SESSION_KEY_LOCAL[0];
	SENSOR_SESSION_KEY[1]=SESSION_KEY_LOCAL[1];	
	 C_T_BEACON=0;
	
	
	
	return 1;
}

unsigned char PROTOCOL_CHANGE_CHANNEL()
{
		unsigned char TEMP_LOCAL=CHALLANGE_RESULT_SUCCESS;
		unsigned char CHANNEL_LOCAL;
		DECRYPT_ALGORISM_1_V1(&CHANNEL_LOCAL,&DATA_BUFFER[8],1,SENSOR_SESSION_KEY);
		volatile unsigned char HASH_VALUE[2];
		DATA_BUFFER[0]=11|0B00000000;
		DATA_BUFFER[1]=PROTOCOL_CURRENT_VERSION;
		DATA_BUFFER[2]=MY_PROTOCOL_ADDRESS_ARRAY_0;
		DATA_BUFFER[3]=MY_PROTOCOL_ADDRESS_ARRAY_1;
		DATA_BUFFER[4]=MY_PROTOCOL_ADDRESS_ARRAY_2;
		DATA_BUFFER[5]=MY_PROTOCOL_ADDRESS_ARRAY_3;
		DATA_BUFFER[6]=MY_PROTOCOL_ADDRESS_ARRAY_4;
		DATA_BUFFER[7]=CHANNEL_CHANGED_CODE;
		ENCRYPT_ALGORISM_1_V1(&TEMP_LOCAL,&DATA_BUFFER[8],1,SENSOR_SESSION_KEY);
		HASH_SESSION_KEY(DATA_BUFFER,HASH_VALUE,9,SENSOR_SESSION_KEY);
		DATA_BUFFER[9]=HASH_VALUE[0];
		DATA_BUFFER[10]=HASH_VALUE[1];
		if (!NRF_SEND_DATA_WITH_ACK(MASTER_ADDRESS,5,DATA_BUFFER,11))
		{
			return 0;
		}
		NRF_UPDATE_USED_CHANNEL(MY_CHANNELS[CHANNEL_LOCAL]);
		 C_T_BEACON=0;
		
		
			USART_SEND_str("CHANNEL :");
				TEST_UART_SEND_VALUE(CHANNEL_LOCAL);
				USART_SEND_str("\n");
		
		
		
		
		return 1;
}

unsigned char PROTOCOL_CHANGE_DATA()
{
	unsigned char LOCAL_DATA[4];
	DECRYPT_ALGORISM_1_V1(LOCAL_DATA,&DATA_BUFFER[8],4,SENSOR_SESSION_KEY);
	
	
	
	volatile unsigned char HASH_VALUE[2];
	DATA_BUFFER[0]=10|0B00000000;
	DATA_BUFFER[1]=PROTOCOL_CURRENT_VERSION;
	DATA_BUFFER[2]=MY_PROTOCOL_ADDRESS_ARRAY_0;
	DATA_BUFFER[3]=MY_PROTOCOL_ADDRESS_ARRAY_1;
	DATA_BUFFER[4]=MY_PROTOCOL_ADDRESS_ARRAY_2;
	DATA_BUFFER[5]=MY_PROTOCOL_ADDRESS_ARRAY_3;
	DATA_BUFFER[6]=MY_PROTOCOL_ADDRESS_ARRAY_4;
	DATA_BUFFER[7]=DATA_CHANGED_CODE;
	HASH_SESSION_KEY(DATA_BUFFER,HASH_VALUE,8,SENSOR_SESSION_KEY);
	DATA_BUFFER[8]=HASH_VALUE[0];
	DATA_BUFFER[9]=HASH_VALUE[1];
	if (!NRF_SEND_DATA_WITH_ACK(MASTER_ADDRESS,5,DATA_BUFFER,10))
	{
		return 0;
	}
	global_interupt_disable();
	MAIN_REGISTERS[(LOCAL_DATA[0]<<8)|(LOCAL_DATA[1])]=((LOCAL_DATA[2]<<8)|(LOCAL_DATA[3]));
	global_interupt_enable();
	 C_T_BEACON=0;
	 
	 
	 
	 volatile unsigned short ADDRESS=(LOCAL_DATA[0]<<8)|(LOCAL_DATA[1]);
	 volatile unsigned short VALUE=((LOCAL_DATA[2]<<8)|(LOCAL_DATA[3]));
	 USART_SEND_str("ADDRESS : ");
	 TEST_UART_SEND_VALUE(ADDRESS);
	 USART_SEND_str("  DATA : ");
	 TEST_UART_SEND_VALUE(VALUE);
	 USART_SEND_str("\n");
	 
	 
	return 1;
}

unsigned char PROTOCOL_READ_DATA()
{
	unsigned char LOCAL_DATA[4];
	DECRYPT_ALGORISM_1_V1(LOCAL_DATA,&DATA_BUFFER[8],2,SENSOR_SESSION_KEY);
	global_interupt_disable();
	LOCAL_DATA[2]=MAIN_REGISTERS[(LOCAL_DATA[0]<<8)|(LOCAL_DATA[1])]>>8;
	LOCAL_DATA[3]=MAIN_REGISTERS[(LOCAL_DATA[0]<<8)|(LOCAL_DATA[1])]&0XFF;
	global_interupt_enable();
	
	/*TESTING*/
	 volatile unsigned short ADDRESS=(LOCAL_DATA[0]<<8)|(LOCAL_DATA[1]);
	 volatile unsigned short VALUE=((LOCAL_DATA[2]<<8)|(LOCAL_DATA[3]));
	/************/
	
	
	volatile unsigned char HASH_VALUE[2];
	DATA_BUFFER[0]=12|0B00000000;
	DATA_BUFFER[1]=PROTOCOL_CURRENT_VERSION;
	DATA_BUFFER[2]=MY_PROTOCOL_ADDRESS_ARRAY_0;
	DATA_BUFFER[3]=MY_PROTOCOL_ADDRESS_ARRAY_1;
	DATA_BUFFER[4]=MY_PROTOCOL_ADDRESS_ARRAY_2;
	DATA_BUFFER[5]=MY_PROTOCOL_ADDRESS_ARRAY_3;
	DATA_BUFFER[6]=MY_PROTOCOL_ADDRESS_ARRAY_4;
	DATA_BUFFER[7]=DATA_READ_CODE;
	/*ENCR FUNCTION PUTS 8 , 9*/
	ENCRYPT_ALGORISM_1_V1(&LOCAL_DATA[2],&DATA_BUFFER[8],2,SENSOR_SESSION_KEY);
	
	HASH_SESSION_KEY(DATA_BUFFER,HASH_VALUE,10,SENSOR_SESSION_KEY);
	DATA_BUFFER[10]=HASH_VALUE[0];
	DATA_BUFFER[11]=HASH_VALUE[1];
	if (!NRF_SEND_DATA_WITH_ACK(MASTER_ADDRESS,5,DATA_BUFFER,12))
	{
		return 0;
	}
	 C_T_BEACON=0;
	 
	/*************************/
	 USART_SEND_str("READING ADDRESS : ");
	 TEST_UART_SEND_VALUE(ADDRESS);
	 USART_SEND_str("  DATA : ");
	 TEST_UART_SEND_VALUE(VALUE);
	 USART_SEND_str("\n");
	 /************************/
	return 1;
}
volatile unsigned char MASTER_ADDRESS_BUFFER[5];
unsigned char PROTOCOL_CONNECT()
{
	
	volatile unsigned short R_N=GENNERATE_RANDOM_NUMBER();
	volatile unsigned char HASH_VALUE[2];
	unsigned long COUNT_TIMER=0;
	USART_SEND_str("connect request\n");
	 MASTER_ADDRESS_BUFFER[0]=DATA_BUFFER[2];
	 MASTER_ADDRESS_BUFFER[1]=DATA_BUFFER[3];
	 MASTER_ADDRESS_BUFFER[2]=DATA_BUFFER[4];
	 MASTER_ADDRESS_BUFFER[3]=DATA_BUFFER[5];
	 MASTER_ADDRESS_BUFFER[4]=DATA_BUFFER[6];
	 
	 
	 /*****************SEND CHALLANGE******************/
	 DATA_BUFFER[0]=12|0B10000000;
	 DATA_BUFFER[1]=PROTOCOL_CURRENT_VERSION;
	 DATA_BUFFER[2]=MY_PROTOCOL_ADDRESS_ARRAY_0;
	 DATA_BUFFER[3]=MY_PROTOCOL_ADDRESS_ARRAY_1;
	 DATA_BUFFER[4]=MY_PROTOCOL_ADDRESS_ARRAY_2;
	 DATA_BUFFER[5]=MY_PROTOCOL_ADDRESS_ARRAY_3;
	 DATA_BUFFER[6]=MY_PROTOCOL_ADDRESS_ARRAY_4;
	 DATA_BUFFER[7]=SENSOR_CHALLENGE_CODE;
	 DATA_BUFFER[8]=R_N>>8;
	 DATA_BUFFER[9]=R_N; 
	 HASH_PASWORD_KEY(DATA_BUFFER,HASH_VALUE,10,SENSOR_PASSWORD);
	 DATA_BUFFER[10]=HASH_VALUE[0];
	 DATA_BUFFER[11]=HASH_VALUE[1];
	 _delay_ms(5);
	 

	 if (!NRF_SEND_DATA_WITH_ACK(MASTER_ADDRESS_BUFFER,5,DATA_BUFFER,12))
	 {
		 return 0;
	 }
	  USART_SEND_str("X\n");
	 /****************************************************/
	 NRF_START_RX_MODE();
	 
	 COUNT_TIMER=0;
	 while(!NRF_CHECK_RX_PL(DATA_BUFFER,&LENGTH))
	 {
		 COUNT_TIMER++;
		 if(COUNT_TIMER==MAX_COUNT_WAIT)
		 {
			USART_SEND_str("XS\n");
			 NRF_STOP_RX_MODE();
			 return 0;
		 }
	 }
	 USART_SEND_str("H\n");
	 NRF_STOP_RX_MODE();
	 if (!PROTOCOL_CHECK_RECIVED_PACKET(DATA_BUFFER,1,MASTER_ADDRESS_BUFFER,LENGTH))
	 {
		 return 0;
	 }
	 if(PROTOCOL_READ_PACKET_TYPE()!=CHALLENGE_ANSWER_CODE)
	 {
		 return 0;
	 }
	 volatile unsigned char RECIVED_R_N[2];
	 DECRYPT_ALGORISM_2_V1(RECIVED_R_N,&DATA_BUFFER[8],2,SENSOR_PASSWORD);
	 unsigned char TEMP_1;
	 if ((RECIVED_R_N[0]!=(R_N>>8))||(RECIVED_R_N[1]!=(R_N&0xff)))
	 {
		  USART_SEND_str("FAIL\n");
		 /*FAILED*/
		  TEMP_1=CHALLANGE_RESULT_FAILED;
		  DATA_BUFFER[0]=11|0B10000000;
		  DATA_BUFFER[1]=PROTOCOL_CURRENT_VERSION;
		  DATA_BUFFER[2]=MY_PROTOCOL_ADDRESS_ARRAY_0;
		  DATA_BUFFER[3]=MY_PROTOCOL_ADDRESS_ARRAY_1;
		  DATA_BUFFER[4]=MY_PROTOCOL_ADDRESS_ARRAY_2;
		  DATA_BUFFER[5]=MY_PROTOCOL_ADDRESS_ARRAY_3;
		  DATA_BUFFER[6]=MY_PROTOCOL_ADDRESS_ARRAY_4;
		  DATA_BUFFER[7]=CHALLENGE_RESULT_CODE;
		  ENCRYPT_ALGORISM_2_V1(&TEMP_1,&DATA_BUFFER[8],1,SENSOR_PASSWORD);
		  HASH_PASWORD_KEY(DATA_BUFFER,HASH_VALUE,9,SENSOR_PASSWORD);
		  DATA_BUFFER[9]=HASH_VALUE[0];
		  DATA_BUFFER[10]=HASH_VALUE[1];
		  _delay_ms(2);
		  NRF_SEND_DATA_WITH_ACK(MASTER_ADDRESS_BUFFER,5,DATA_BUFFER,11);
		  return 0; 
	 }
	 
	
	 /***********************************************************************************/
	  TEMP_1=CHALLANGE_RESULT_SUCCESS;
	  DATA_BUFFER[0]=11|0B10000000;
	  DATA_BUFFER[1]=PROTOCOL_CURRENT_VERSION;
	  DATA_BUFFER[2]=MY_PROTOCOL_ADDRESS_ARRAY_0;
	  DATA_BUFFER[3]=MY_PROTOCOL_ADDRESS_ARRAY_1;
	  DATA_BUFFER[4]=MY_PROTOCOL_ADDRESS_ARRAY_2;
	  DATA_BUFFER[5]=MY_PROTOCOL_ADDRESS_ARRAY_3;
	  DATA_BUFFER[6]=MY_PROTOCOL_ADDRESS_ARRAY_4;
	  DATA_BUFFER[7]=CHALLENGE_RESULT_CODE;
	  ENCRYPT_ALGORISM_2_V1(&TEMP_1,&DATA_BUFFER[8],1,SENSOR_PASSWORD);
	  HASH_PASWORD_KEY(DATA_BUFFER,HASH_VALUE,9,SENSOR_PASSWORD);
	  DATA_BUFFER[9]=HASH_VALUE[0];
	  DATA_BUFFER[10]=HASH_VALUE[1];
	  _delay_ms(2);
	  if (!NRF_SEND_DATA_WITH_ACK(MASTER_ADDRESS_BUFFER,5,DATA_BUFFER,11))
	  {
		  return 0;
	  }
	     
	/*CONNECTED*/	
	MASTER_ADDRESS[0]=MASTER_ADDRESS_BUFFER[0];
	MASTER_ADDRESS[1]=MASTER_ADDRESS_BUFFER[1];
	MASTER_ADDRESS[2]=MASTER_ADDRESS_BUFFER[2];
	MASTER_ADDRESS[3]=MASTER_ADDRESS_BUFFER[3];
	MASTER_ADDRESS[4]=MASTER_ADDRESS_BUFFER[4];
	F_SENSOR_STATE=CONNECTED_STATE; 
	C_T_BEACON=0;
	
				
	return 1;
	 
}




void PROTOCOL_SWITCH()
{
		if (F_SENSOR_STATE==NOTCONNECTED_STATE)
		{
			if (PROTOCOL_READ_PACKET_TYPE()==MASTER_REQUEST_CONNECT_CODE) /*master want to connect*/
			{
				if (PROTOCOL_CONNECT())
				{
					USART_SEND_str("CONNECTED\n");
					setbit(*PORT_OUT_CONNECTED_LED,CONNECTED_LED_PIN);
					/*DONE*/
				}
			}
		}
		else
		{
			switch (PROTOCOL_READ_PACKET_TYPE())
			{
				case BEACON_CODE:USART_SEND_str("T B\n");
									if (PROTOCOL_BEACON())
									{
										USART_SEND_str("B\n");
									}
									
								 break;
				
				case NEW_SESSION_KEY_CODE:	USART_SEND_str("T S\n");
											if (PROTOCOL_SESSION_KEY())
											{
												/*TEST*/
												USART_SEND_str("S: ");
												volatile unsigned short SES_TEST=((SENSOR_SESSION_KEY[0]<<8)|SENSOR_SESSION_KEY[1]);	
												TEST_UART_SEND_VALUE(SES_TEST);
												USART_SEND_str("\n");
											}
											break;
				
				case MASTER_CHANGE_CHANNEL_CODE:USART_SEND_str("T C\n");
												if (PROTOCOL_CHANGE_CHANNEL())
												{
													USART_SEND_str("C\n");
												}
				
												break;
				
				case MASTER_CHANGE_DATA_CODE:PROTOCOL_CHANGE_DATA();
											break;
				
				case MASTER_NEEDS_DATA_CODE:PROTOCOL_READ_DATA();
											break;
				
				default:break;
				
				
				
				
				
			}
		}
}
