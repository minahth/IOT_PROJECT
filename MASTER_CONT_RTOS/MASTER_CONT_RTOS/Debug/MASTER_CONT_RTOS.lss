
MASTER_CONT_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000392  00800100  00008638  000086cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00008638  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c57  00800492  00800492  00008a5e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00008a5e  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000c18  00000000  00000000  00008a8e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000109df  00000000  00000000  000096a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00002d62  00000000  00000000  0001a085  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00008431  00000000  00000000  0001cde7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00002bf0  00000000  00000000  00025218  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00005044  00000000  00000000  00027e08  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000d0b8  00000000  00000000  0002ce4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000be0  00000000  00000000  00039f04  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	61 c0       	rjmp	.+194    	; 0xc4 <__ctors_end>
       2:	00 00       	nop
       4:	a0 c6       	rjmp	.+3392   	; 0xd46 <__vector_1>
       6:	00 00       	nop
       8:	7b c0       	rjmp	.+246    	; 0x100 <__bad_interrupt>
       a:	00 00       	nop
       c:	79 c0       	rjmp	.+242    	; 0x100 <__bad_interrupt>
       e:	00 00       	nop
      10:	77 c0       	rjmp	.+238    	; 0x100 <__bad_interrupt>
      12:	00 00       	nop
      14:	75 c0       	rjmp	.+234    	; 0x100 <__bad_interrupt>
      16:	00 00       	nop
      18:	73 c0       	rjmp	.+230    	; 0x100 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	a8 c7       	rjmp	.+3920   	; 0xf6e <__vector_7>
      1e:	00 00       	nop
      20:	6f c0       	rjmp	.+222    	; 0x100 <__bad_interrupt>
      22:	00 00       	nop
      24:	6d c0       	rjmp	.+218    	; 0x100 <__bad_interrupt>
      26:	00 00       	nop
      28:	7b c7       	rjmp	.+3830   	; 0xf20 <__vector_10>
      2a:	00 00       	nop
      2c:	69 c0       	rjmp	.+210    	; 0x100 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 98 14 	jmp	0x2930	; 0x2930 <__vector_12>
      34:	65 c0       	rjmp	.+202    	; 0x100 <__bad_interrupt>
      36:	00 00       	nop
      38:	63 c0       	rjmp	.+198    	; 0x100 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	61 c0       	rjmp	.+194    	; 0x100 <__bad_interrupt>
      3e:	00 00       	nop
      40:	f8 c6       	rjmp	.+3568   	; 0xe32 <__vector_16>
      42:	00 00       	nop
      44:	5d c0       	rjmp	.+186    	; 0x100 <__bad_interrupt>
      46:	00 00       	nop
      48:	44 c7       	rjmp	.+3720   	; 0xed2 <__vector_18>
      4a:	00 00       	nop
      4c:	59 c0       	rjmp	.+178    	; 0x100 <__bad_interrupt>
      4e:	00 00       	nop
      50:	b6 c7       	rjmp	.+3948   	; 0xfbe <__vector_20>
      52:	00 00       	nop
      54:	55 c0       	rjmp	.+170    	; 0x100 <__bad_interrupt>
      56:	00 00       	nop
      58:	53 c0       	rjmp	.+166    	; 0x100 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	51 c0       	rjmp	.+162    	; 0x100 <__bad_interrupt>
      5e:	00 00       	nop
      60:	4f c0       	rjmp	.+158    	; 0x100 <__bad_interrupt>
      62:	00 00       	nop
      64:	4d c0       	rjmp	.+154    	; 0x100 <__bad_interrupt>
      66:	00 00       	nop
      68:	4b c0       	rjmp	.+150    	; 0x100 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	49 c0       	rjmp	.+146    	; 0x100 <__bad_interrupt>
      6e:	00 00       	nop
      70:	47 c0       	rjmp	.+142    	; 0x100 <__bad_interrupt>
      72:	00 00       	nop
      74:	06 c7       	rjmp	.+3596   	; 0xe82 <__vector_29>
      76:	00 00       	nop
      78:	8e c6       	rjmp	.+3356   	; 0xd96 <__vector_30>
      7a:	00 00       	nop
      7c:	41 c0       	rjmp	.+130    	; 0x100 <__bad_interrupt>
      7e:	00 00       	nop
      80:	b1 c6       	rjmp	.+3426   	; 0xde4 <__vector_32>
      82:	00 00       	nop
      84:	3d c0       	rjmp	.+122    	; 0x100 <__bad_interrupt>
      86:	00 00       	nop
      88:	3b c0       	rjmp	.+118    	; 0x100 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	cc 01       	movw	r24, r24
      8e:	ce 01       	movw	r24, r28
      90:	d0 01       	movw	r26, r0
      92:	d2 01       	movw	r26, r4
      94:	d4 01       	movw	r26, r8
      96:	d6 01       	movw	r26, r12
      98:	d8 01       	movw	r26, r16
      9a:	c0 01       	movw	r24, r0
      9c:	c2 01       	movw	r24, r4
      9e:	c4 01       	movw	r24, r8
      a0:	c6 01       	movw	r24, r12
      a2:	c8 01       	movw	r24, r16
      a4:	ca 01       	movw	r24, r20
      a6:	bc 01       	movw	r22, r24
      a8:	be 01       	movw	r22, r28
      aa:	f3 04       	cpc	r15, r3
      ac:	f9 04       	cpc	r15, r9
      ae:	f6 04       	cpc	r15, r6
      b0:	fc 04       	cpc	r15, r12
      b2:	ff 04       	cpc	r15, r15
      b4:	02 05       	cpc	r16, r2
      b6:	05 05       	cpc	r16, r5
      b8:	08 05       	cpc	r16, r8
      ba:	0b 05       	cpc	r16, r11
      bc:	0e 05       	cpc	r16, r14
      be:	11 05       	cpc	r17, r1
      c0:	14 05       	cpc	r17, r4
      c2:	17 05       	cpc	r17, r7

000000c4 <__ctors_end>:
      c4:	11 24       	eor	r1, r1
      c6:	1f be       	out	0x3f, r1	; 63
      c8:	cf ef       	ldi	r28, 0xFF	; 255
      ca:	d0 e1       	ldi	r29, 0x10	; 16
      cc:	de bf       	out	0x3e, r29	; 62
      ce:	cd bf       	out	0x3d, r28	; 61

000000d0 <__do_copy_data>:
      d0:	14 e0       	ldi	r17, 0x04	; 4
      d2:	a0 e0       	ldi	r26, 0x00	; 0
      d4:	b1 e0       	ldi	r27, 0x01	; 1
      d6:	e8 e3       	ldi	r30, 0x38	; 56
      d8:	f6 e8       	ldi	r31, 0x86	; 134
      da:	00 e0       	ldi	r16, 0x00	; 0
      dc:	0b bf       	out	0x3b, r16	; 59
      de:	02 c0       	rjmp	.+4      	; 0xe4 <__do_copy_data+0x14>
      e0:	07 90       	elpm	r0, Z+
      e2:	0d 92       	st	X+, r0
      e4:	a2 39       	cpi	r26, 0x92	; 146
      e6:	b1 07       	cpc	r27, r17
      e8:	d9 f7       	brne	.-10     	; 0xe0 <__do_copy_data+0x10>

000000ea <__do_clear_bss>:
      ea:	20 e1       	ldi	r18, 0x10	; 16
      ec:	a2 e9       	ldi	r26, 0x92	; 146
      ee:	b4 e0       	ldi	r27, 0x04	; 4
      f0:	01 c0       	rjmp	.+2      	; 0xf4 <.do_clear_bss_start>

000000f2 <.do_clear_bss_loop>:
      f2:	1d 92       	st	X+, r1

000000f4 <.do_clear_bss_start>:
      f4:	a9 3e       	cpi	r26, 0xE9	; 233
      f6:	b2 07       	cpc	r27, r18
      f8:	e1 f7       	brne	.-8      	; 0xf2 <.do_clear_bss_loop>
      fa:	92 d7       	rcall	.+3876   	; 0x1020 <main>
      fc:	0c 94 1a 43 	jmp	0x8634	; 0x8634 <_exit>

00000100 <__bad_interrupt>:
     100:	85 c7       	rjmp	.+3850   	; 0x100c <__vector_default>

00000102 <TX0_ISR>:
}


void TX0_ISR()
{
	if (isbitset(*CHECK_CONNECTED_IN_ADDRESS,CHECK_CONNECTED_PIN))
     102:	0a 9b       	sbis	0x01, 2	; 1
     104:	18 c0       	rjmp	.+48     	; 0x136 <TX0_ISR+0x34>
	{
		if (COUNER_TX_BUFFER==TX_BUFFER_SIZE)
     106:	90 91 97 04 	lds	r25, 0x0497
     10a:	80 91 96 04 	lds	r24, 0x0496
     10e:	98 13       	cpse	r25, r24
     110:	05 c0       	rjmp	.+10     	; 0x11c <TX0_ISR+0x1a>
		{
			COUNER_TX_BUFFER=0;
     112:	10 92 97 04 	sts	0x0497, r1
			TX_BUFFER_SIZE=0;
     116:	10 92 96 04 	sts	0x0496, r1
     11a:	08 95       	ret
		}
		else
		{
			UDR0=TX_BUFFER[COUNER_TX_BUFFER];
     11c:	e0 91 97 04 	lds	r30, 0x0497
     120:	f0 e0       	ldi	r31, 0x00	; 0
     122:	e4 5a       	subi	r30, 0xA4	; 164
     124:	f3 4f       	sbci	r31, 0xF3	; 243
     126:	80 81       	ld	r24, Z
     128:	8c b9       	out	0x0c, r24	; 12
			COUNER_TX_BUFFER++;
     12a:	80 91 97 04 	lds	r24, 0x0497
     12e:	8f 5f       	subi	r24, 0xFF	; 255
     130:	80 93 97 04 	sts	0x0497, r24
     134:	08 95       	ret
		}
	}
	else
	{
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     136:	10 92 98 04 	sts	0x0498, r1
     13a:	08 95       	ret

0000013c <RESET_ALL_COMMAND_RX>:



void RESET_ALL_COMMAND_RX()
{
	COUNER_RX_BUFFER=0;
     13c:	10 92 95 04 	sts	0x0495, r1
	RX_BUFFER_SIZE=1;
     140:	81 e0       	ldi	r24, 0x01	; 1
     142:	80 93 94 04 	sts	0x0494, r24
	BLUETOOTH_STATE=BLUETOOTH_RESET_ALL;
     146:	82 e0       	ldi	r24, 0x02	; 2
     148:	80 93 98 04 	sts	0x0498, r24
	COUNER_TX_BUFFER=0;
     14c:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     150:	10 92 96 04 	sts	0x0496, r1
	
	#if ROBUST_ACK_MODE
	UDR0=RESET_ALL_COMMAND;
     154:	8f e0       	ldi	r24, 0x0F	; 15
     156:	8c b9       	out	0x0c, r24	; 12
     158:	08 95       	ret

0000015a <DELETE_ALL_SENSORS_COMMAND_RX>:
	#endif
}

void DELETE_ALL_SENSORS_COMMAND_RX()
{
	COUNER_RX_BUFFER=0;
     15a:	10 92 95 04 	sts	0x0495, r1
	RX_BUFFER_SIZE=1;
     15e:	81 e0       	ldi	r24, 0x01	; 1
     160:	80 93 94 04 	sts	0x0494, r24
	BLUETOOTH_STATE=BLUETOOTH_DELETE_ALL_SESNORS;
     164:	80 93 98 04 	sts	0x0498, r24
	COUNER_TX_BUFFER=0;
     168:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     16c:	10 92 96 04 	sts	0x0496, r1
	
	#if ROBUST_ACK_MODE
	UDR0=DELETE_ALL_SENSORS_COMMAND;
     170:	8e e0       	ldi	r24, 0x0E	; 14
     172:	8c b9       	out	0x0c, r24	; 12
     174:	08 95       	ret

00000176 <READ_STATE_OF_SENSOR_COMMAND_RX>:

/*READING DATA*/
void  READ_STATE_OF_SENSOR_COMMAND_RX()
{
	
	COUNER_RX_BUFFER=0;
     176:	10 92 95 04 	sts	0x0495, r1
	RX_BUFFER_SIZE=5;
     17a:	85 e0       	ldi	r24, 0x05	; 5
     17c:	80 93 94 04 	sts	0x0494, r24
	BLUETOOTH_STATE=BLUETOOTH_READING_STATE_SENSOR;
     180:	8a e0       	ldi	r24, 0x0A	; 10
     182:	80 93 98 04 	sts	0x0498, r24
	COUNER_TX_BUFFER=0;
     186:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     18a:	10 92 96 04 	sts	0x0496, r1
	
	#if ROBUST_ACK_MODE
	UDR0=READ_STATE_OF_SENSOR_COMMAND;
     18e:	88 e0       	ldi	r24, 0x08	; 8
     190:	8c b9       	out	0x0c, r24	; 12
     192:	08 95       	ret

00000194 <READ_CONNECTION_OF_SENSOR_COMMAND_RX>:
	
	
}
void  READ_CONNECTION_OF_SENSOR_COMMAND_RX()
{
	COUNER_RX_BUFFER=0;
     194:	10 92 95 04 	sts	0x0495, r1
	RX_BUFFER_SIZE=5;
     198:	85 e0       	ldi	r24, 0x05	; 5
     19a:	80 93 94 04 	sts	0x0494, r24
	BLUETOOTH_STATE=BLUETOOTH_READING_CONNECT_SENSOR;
     19e:	8b e0       	ldi	r24, 0x0B	; 11
     1a0:	80 93 98 04 	sts	0x0498, r24
	COUNER_TX_BUFFER=0;
     1a4:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     1a8:	10 92 96 04 	sts	0x0496, r1
	#if ROBUST_ACK_MODE
	UDR0=READ_CONNECTION_OF_SENSOR_COMMAND;
     1ac:	89 e0       	ldi	r24, 0x09	; 9
     1ae:	8c b9       	out	0x0c, r24	; 12
     1b0:	08 95       	ret

000001b2 <READ_NUM_OF_SENSORS_COMMAND_RX>:
	#endif
}

void READ_NUM_OF_SENSORS_COMMAND_RX() 
{
	TX_BUFFER[1]=NUMBER_OF_SENSORS;
     1b2:	80 91 56 0c 	lds	r24, 0x0C56
     1b6:	80 93 5d 0c 	sts	0x0C5D, r24
	COUNER_TX_BUFFER=1;
     1ba:	81 e0       	ldi	r24, 0x01	; 1
     1bc:	80 93 97 04 	sts	0x0497, r24
	TX_BUFFER_SIZE=2;
     1c0:	82 e0       	ldi	r24, 0x02	; 2
     1c2:	80 93 96 04 	sts	0x0496, r24
	BLUETOOTH_STATE=BLUETOOTH_IDLE;
     1c6:	10 92 98 04 	sts	0x0498, r1
	#if ROBUST_ACK_MODE
	UDR0=READ_NUM_OF_SENSORS_COMMAND;
     1ca:	8a e0       	ldi	r24, 0x0A	; 10
     1cc:	8c b9       	out	0x0c, r24	; 12
     1ce:	08 95       	ret

000001d0 <READ_MASTER_VER_COMMAND_RX>:
	#endif
}

void READ_MASTER_VER_COMMAND_RX()
{
	TX_BUFFER[1]=PROTOCOL_CURRENT_VERSION;
     1d0:	81 e0       	ldi	r24, 0x01	; 1
     1d2:	80 93 5d 0c 	sts	0x0C5D, r24
	COUNER_TX_BUFFER=1;
     1d6:	80 93 97 04 	sts	0x0497, r24
	TX_BUFFER_SIZE=2;
     1da:	82 e0       	ldi	r24, 0x02	; 2
     1dc:	80 93 96 04 	sts	0x0496, r24
	BLUETOOTH_STATE=BLUETOOTH_IDLE;
     1e0:	10 92 98 04 	sts	0x0498, r1
	#if ROBUST_ACK_MODE
	UDR0=READ_MASTER_VER_COMMAND;
     1e4:	8b e0       	ldi	r24, 0x0B	; 11
     1e6:	8c b9       	out	0x0c, r24	; 12
     1e8:	08 95       	ret

000001ea <READ_MASTER_ADDRESS_COMMAND_RX>:

void READ_MASTER_ADDRESS_COMMAND_RX()
{
	
	
	TX_BUFFER[1]=MY_PROTOCOL_ADDRESS_ARRAY_0;
     1ea:	80 e1       	ldi	r24, 0x10	; 16
     1ec:	80 93 5d 0c 	sts	0x0C5D, r24
	TX_BUFFER[2]=MY_PROTOCOL_ADDRESS_ARRAY_1;
     1f0:	80 e2       	ldi	r24, 0x20	; 32
     1f2:	80 93 5e 0c 	sts	0x0C5E, r24
	TX_BUFFER[3]=MY_PROTOCOL_ADDRESS_ARRAY_2;
     1f6:	80 e3       	ldi	r24, 0x30	; 48
     1f8:	80 93 5f 0c 	sts	0x0C5F, r24
	TX_BUFFER[4]=MY_PROTOCOL_ADDRESS_ARRAY_3;
     1fc:	80 e4       	ldi	r24, 0x40	; 64
     1fe:	80 93 60 0c 	sts	0x0C60, r24
	TX_BUFFER[5]=MY_PROTOCOL_ADDRESS_ARRAY_4;
     202:	80 e5       	ldi	r24, 0x50	; 80
     204:	80 93 61 0c 	sts	0x0C61, r24
	
	COUNER_TX_BUFFER=1;
     208:	81 e0       	ldi	r24, 0x01	; 1
     20a:	80 93 97 04 	sts	0x0497, r24
	TX_BUFFER_SIZE=6;
     20e:	86 e0       	ldi	r24, 0x06	; 6
     210:	80 93 96 04 	sts	0x0496, r24
	BLUETOOTH_STATE=BLUETOOTH_IDLE;
     214:	10 92 98 04 	sts	0x0498, r1
	#if ROBUST_ACK_MODE
	UDR0=READ_MASTER_ADDRESS_COMMAND;
     218:	8c e0       	ldi	r24, 0x0C	; 12
     21a:	8c b9       	out	0x0c, r24	; 12
     21c:	08 95       	ret

0000021e <READ_SENSOR_INFO_COMMAND_RX>:


void  READ_SENSOR_INFO_COMMAND_RX()
{
	
	COUNER_RX_BUFFER=0;
     21e:	10 92 95 04 	sts	0x0495, r1
	RX_BUFFER_SIZE=1;
     222:	81 e0       	ldi	r24, 0x01	; 1
     224:	80 93 94 04 	sts	0x0494, r24
	BLUETOOTH_STATE=BLUETOOTH_READING_SENSOR_INFO;
     228:	8c e0       	ldi	r24, 0x0C	; 12
     22a:	80 93 98 04 	sts	0x0498, r24
	COUNER_TX_BUFFER=0;
     22e:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     232:	10 92 96 04 	sts	0x0496, r1
	#if ROBUST_ACK_MODE
	UDR0=READ_SENSOR_INFO_COMMAND;
     236:	8d e0       	ldi	r24, 0x0D	; 13
     238:	8c b9       	out	0x0c, r24	; 12
     23a:	08 95       	ret

0000023c <RECIVE_USER_PASS_COMMAND_RX>:

/*RECIVE DATA*/

void RECIVE_USER_PASS_COMMAND_RX()
{
	COUNER_RX_BUFFER=0;
     23c:	10 92 95 04 	sts	0x0495, r1
	RX_BUFFER_SIZE=30;
     240:	8e e1       	ldi	r24, 0x1E	; 30
     242:	80 93 94 04 	sts	0x0494, r24
	BLUETOOTH_STATE=BLUETOOTH_RECIVING_USER_PASS;
     246:	83 e0       	ldi	r24, 0x03	; 3
     248:	80 93 98 04 	sts	0x0498, r24
	COUNER_TX_BUFFER=0;
     24c:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     250:	10 92 96 04 	sts	0x0496, r1
	#if ROBUST_ACK_MODE
	UDR0=RECIVE_USER_PASS_COMMAND;
     254:	81 e0       	ldi	r24, 0x01	; 1
     256:	8c b9       	out	0x0c, r24	; 12
     258:	08 95       	ret

0000025a <RECIVE_IOT_PAR_COMMAND_RX>:
	#endif
}

void RECIVE_IOT_PAR_COMMAND_RX()
{
	COUNER_RX_BUFFER=0;
     25a:	10 92 95 04 	sts	0x0495, r1
	RX_BUFFER_SIZE=38;
     25e:	86 e2       	ldi	r24, 0x26	; 38
     260:	80 93 94 04 	sts	0x0494, r24
	BLUETOOTH_STATE=BLUETOOTH_RECIVING_IOT_PAR;
     264:	84 e0       	ldi	r24, 0x04	; 4
     266:	80 93 98 04 	sts	0x0498, r24
	COUNER_TX_BUFFER=0;
     26a:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     26e:	10 92 96 04 	sts	0x0496, r1
	#if ROBUST_ACK_MODE
	UDR0=RECIVE_IOT_PAR_COMMAND;
     272:	82 e0       	ldi	r24, 0x02	; 2
     274:	8c b9       	out	0x0c, r24	; 12
     276:	08 95       	ret

00000278 <RECIVE_ADD_NEW_SENSOR_COMMAND_RX>:
}


void RECIVE_ADD_NEW_SENSOR_COMMAND_RX()
{
	if (F_B_ADD_NEW_SENSOR)
     278:	80 91 12 0d 	lds	r24, 0x0D12
     27c:	88 23       	and	r24, r24
     27e:	39 f0       	breq	.+14     	; 0x28e <RECIVE_ADD_NEW_SENSOR_COMMAND_RX+0x16>
	{
		COUNER_TX_BUFFER=0;
     280:	10 92 97 04 	sts	0x0497, r1
		TX_BUFFER_SIZE=0;
     284:	10 92 96 04 	sts	0x0496, r1
		UDR0=NACK_COMMAND;
     288:	8d ed       	ldi	r24, 0xDD	; 221
     28a:	8c b9       	out	0x0c, r24	; 12
     28c:	08 95       	ret
	}
	else
	{
		COUNER_RX_BUFFER=0;
     28e:	10 92 95 04 	sts	0x0495, r1
		RX_BUFFER_SIZE=11;
     292:	8b e0       	ldi	r24, 0x0B	; 11
     294:	80 93 94 04 	sts	0x0494, r24
		BLUETOOTH_STATE=BLUETOOTH_RECIVING_ADD_SENSOR;
     298:	85 e0       	ldi	r24, 0x05	; 5
     29a:	80 93 98 04 	sts	0x0498, r24
		COUNER_TX_BUFFER=0;
     29e:	10 92 97 04 	sts	0x0497, r1
		TX_BUFFER_SIZE=0;
     2a2:	10 92 96 04 	sts	0x0496, r1
		#if ROBUST_ACK_MODE
		UDR0=RECIVE_ADD_NEW_SENSOR_COMMAND;
     2a6:	83 e0       	ldi	r24, 0x03	; 3
     2a8:	8c b9       	out	0x0c, r24	; 12
     2aa:	08 95       	ret

000002ac <RECIVE_ENABLE_SENSOR_COMMAND_RX>:
	

void RECIVE_ENABLE_SENSOR_COMMAND_RX()
{
	
	if (F_B_ENABLE_SENSOR)
     2ac:	80 91 31 0e 	lds	r24, 0x0E31
     2b0:	88 23       	and	r24, r24
     2b2:	39 f0       	breq	.+14     	; 0x2c2 <RECIVE_ENABLE_SENSOR_COMMAND_RX+0x16>
	{
		COUNER_TX_BUFFER=0;
     2b4:	10 92 97 04 	sts	0x0497, r1
		TX_BUFFER_SIZE=0;
     2b8:	10 92 96 04 	sts	0x0496, r1
		UDR0=NACK_COMMAND;
     2bc:	8d ed       	ldi	r24, 0xDD	; 221
     2be:	8c b9       	out	0x0c, r24	; 12
     2c0:	08 95       	ret
	}
	else
	{
		COUNER_RX_BUFFER=0;
     2c2:	10 92 95 04 	sts	0x0495, r1
		RX_BUFFER_SIZE=5;
     2c6:	85 e0       	ldi	r24, 0x05	; 5
     2c8:	80 93 94 04 	sts	0x0494, r24
		BLUETOOTH_STATE=BLUETOOTH_RECIVING_ENABLE_SENSOR;
     2cc:	86 e0       	ldi	r24, 0x06	; 6
     2ce:	80 93 98 04 	sts	0x0498, r24
		COUNER_TX_BUFFER=0;
     2d2:	10 92 97 04 	sts	0x0497, r1
		TX_BUFFER_SIZE=0;
     2d6:	10 92 96 04 	sts	0x0496, r1
		#if ROBUST_ACK_MODE
		UDR0=RECIVE_ENABLE_SENSOR_COMMAND;
     2da:	84 e0       	ldi	r24, 0x04	; 4
     2dc:	8c b9       	out	0x0c, r24	; 12
     2de:	08 95       	ret

000002e0 <RECIVE_DISABLE_SENSOR_COMMAND_RX>:


void RECIVE_DISABLE_SENSOR_COMMAND_RX()
{
	
	if (F_B_DISABLE_SENSOR)
     2e0:	80 91 73 0e 	lds	r24, 0x0E73
     2e4:	88 23       	and	r24, r24
     2e6:	39 f0       	breq	.+14     	; 0x2f6 <RECIVE_DISABLE_SENSOR_COMMAND_RX+0x16>
	{
		COUNER_TX_BUFFER=0;
     2e8:	10 92 97 04 	sts	0x0497, r1
		TX_BUFFER_SIZE=0;
     2ec:	10 92 96 04 	sts	0x0496, r1
		UDR0=NACK_COMMAND;
     2f0:	8d ed       	ldi	r24, 0xDD	; 221
     2f2:	8c b9       	out	0x0c, r24	; 12
     2f4:	08 95       	ret
	}
	else
	{
		COUNER_RX_BUFFER=0;
     2f6:	10 92 95 04 	sts	0x0495, r1
		RX_BUFFER_SIZE=5;
     2fa:	85 e0       	ldi	r24, 0x05	; 5
     2fc:	80 93 94 04 	sts	0x0494, r24
		BLUETOOTH_STATE=BLUETOOTH_RECIVING_DISABLE_SENSOR;
     300:	97 e0       	ldi	r25, 0x07	; 7
     302:	90 93 98 04 	sts	0x0498, r25
		COUNER_TX_BUFFER=0;
     306:	10 92 97 04 	sts	0x0497, r1
		TX_BUFFER_SIZE=0;
     30a:	10 92 96 04 	sts	0x0496, r1
		#if ROBUST_ACK_MODE
		UDR0=RECIVE_DISABLE_SENSOR_COMMAND;
     30e:	8c b9       	out	0x0c, r24	; 12
     310:	08 95       	ret

00000312 <RECIVE_DELETE_SENSOR_COMMAND_RX>:
	}
}

void RECIVE_DELETE_SENSOR_COMMAND_RX()
{
	if (F_B_DELETE_SENSOR)
     312:	80 91 13 0e 	lds	r24, 0x0E13
     316:	88 23       	and	r24, r24
     318:	39 f0       	breq	.+14     	; 0x328 <RECIVE_DELETE_SENSOR_COMMAND_RX+0x16>
	{
		COUNER_TX_BUFFER=0;
     31a:	10 92 97 04 	sts	0x0497, r1
		TX_BUFFER_SIZE=0;
     31e:	10 92 96 04 	sts	0x0496, r1
		UDR0=NACK_COMMAND;
     322:	8d ed       	ldi	r24, 0xDD	; 221
     324:	8c b9       	out	0x0c, r24	; 12
     326:	08 95       	ret
	}
	else
	{
		COUNER_RX_BUFFER=0;
     328:	10 92 95 04 	sts	0x0495, r1
		RX_BUFFER_SIZE=5;
     32c:	85 e0       	ldi	r24, 0x05	; 5
     32e:	80 93 94 04 	sts	0x0494, r24
		BLUETOOTH_STATE=BLUETOOTH_RECIVING_DELETE_SENSOR;
     332:	88 e0       	ldi	r24, 0x08	; 8
     334:	80 93 98 04 	sts	0x0498, r24
		COUNER_TX_BUFFER=0;
     338:	10 92 97 04 	sts	0x0497, r1
		TX_BUFFER_SIZE=0;
     33c:	10 92 96 04 	sts	0x0496, r1
		#if ROBUST_ACK_MODE
		UDR0=RECIVE_DELETE_SENSOR_COMMAND;
     340:	86 e0       	ldi	r24, 0x06	; 6
     342:	8c b9       	out	0x0c, r24	; 12
     344:	08 95       	ret

00000346 <RECIVE_ADJUST_LED_COMMAND_RX>:

void RECIVE_ADJUST_LED_COMMAND_RX()
{
	
	
	COUNER_RX_BUFFER=0;
     346:	10 92 95 04 	sts	0x0495, r1
	RX_BUFFER_SIZE=8;
     34a:	88 e0       	ldi	r24, 0x08	; 8
     34c:	80 93 94 04 	sts	0x0494, r24
	BLUETOOTH_STATE=BLUETOOTH_RECIVING_ADJUST_LED;
     350:	89 e0       	ldi	r24, 0x09	; 9
     352:	80 93 98 04 	sts	0x0498, r24
	COUNER_TX_BUFFER=0;
     356:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     35a:	10 92 96 04 	sts	0x0496, r1
	#if ROBUST_ACK_MODE
	UDR0=RECIVE_ADJUST_LED_COMMAND;
     35e:	87 e0       	ldi	r24, 0x07	; 7
     360:	8c b9       	out	0x0c, r24	; 12
     362:	08 95       	ret

00000364 <BLUETOOTH_IDLE_RX>:
}


void BLUETOOTH_IDLE_RX(unsigned char RECIVED)
{
	switch(RECIVED)
     364:	90 e0       	ldi	r25, 0x00	; 0
     366:	fc 01       	movw	r30, r24
     368:	31 97       	sbiw	r30, 0x01	; 1
     36a:	ef 30       	cpi	r30, 0x0F	; 15
     36c:	f1 05       	cpc	r31, r1
     36e:	08 f5       	brcc	.+66     	; 0x3b2 <BLUETOOTH_IDLE_RX+0x4e>
     370:	ea 5b       	subi	r30, 0xBA	; 186
     372:	ff 4f       	sbci	r31, 0xFF	; 255
     374:	0c 94 2c 42 	jmp	0x8458	; 0x8458 <__tablejump2__>
	{
		
		
		case DELETE_ALL_SENSORS_COMMAND:DELETE_ALL_SENSORS_COMMAND_RX();
     378:	f0 ce       	rjmp	.-544    	; 0x15a <DELETE_ALL_SENSORS_COMMAND_RX>
		break;
     37a:	08 95       	ret
		case RESET_ALL_COMMAND:RESET_ALL_COMMAND_RX();
     37c:	df ce       	rjmp	.-578    	; 0x13c <RESET_ALL_COMMAND_RX>
		break;
     37e:	08 95       	ret
		
		/*READING DATA*/
		case READ_STATE_OF_SENSOR_COMMAND: READ_STATE_OF_SENSOR_COMMAND_RX();
     380:	fa ce       	rjmp	.-524    	; 0x176 <READ_STATE_OF_SENSOR_COMMAND_RX>
		break;
     382:	08 95       	ret
		
		case READ_CONNECTION_OF_SENSOR_COMMAND: READ_CONNECTION_OF_SENSOR_COMMAND_RX();
     384:	07 cf       	rjmp	.-498    	; 0x194 <READ_CONNECTION_OF_SENSOR_COMMAND_RX>
		break;
     386:	08 95       	ret
		
		case READ_NUM_OF_SENSORS_COMMAND: READ_NUM_OF_SENSORS_COMMAND_RX();
     388:	14 cf       	rjmp	.-472    	; 0x1b2 <READ_NUM_OF_SENSORS_COMMAND_RX>
		break;
     38a:	08 95       	ret
		case READ_MASTER_VER_COMMAND: READ_MASTER_VER_COMMAND_RX();
     38c:	21 cf       	rjmp	.-446    	; 0x1d0 <READ_MASTER_VER_COMMAND_RX>
		break;
     38e:	08 95       	ret
		case READ_MASTER_ADDRESS_COMMAND: READ_MASTER_ADDRESS_COMMAND_RX();
     390:	2c cf       	rjmp	.-424    	; 0x1ea <READ_MASTER_ADDRESS_COMMAND_RX>
		break;
     392:	08 95       	ret
		case READ_SENSOR_INFO_COMMAND: READ_SENSOR_INFO_COMMAND_RX();
     394:	44 cf       	rjmp	.-376    	; 0x21e <READ_SENSOR_INFO_COMMAND_RX>
		break;
     396:	08 95       	ret
		/*EVENTS*/
	/*	case EVENT_START_COMMAND:EVENT_START_COMMAND_RX();
		break;*/
		
		/*RECIVE DATA*/
		case RECIVE_USER_PASS_COMMAND:RECIVE_USER_PASS_COMMAND_RX();
     398:	51 cf       	rjmp	.-350    	; 0x23c <RECIVE_USER_PASS_COMMAND_RX>
		break;	
     39a:	08 95       	ret
		case RECIVE_IOT_PAR_COMMAND:RECIVE_IOT_PAR_COMMAND_RX();
     39c:	5e cf       	rjmp	.-324    	; 0x25a <RECIVE_IOT_PAR_COMMAND_RX>
		break;
     39e:	08 95       	ret
		case RECIVE_ADD_NEW_SENSOR_COMMAND:RECIVE_ADD_NEW_SENSOR_COMMAND_RX();
     3a0:	6b cf       	rjmp	.-298    	; 0x278 <RECIVE_ADD_NEW_SENSOR_COMMAND_RX>
		break;
     3a2:	08 95       	ret
		case RECIVE_ENABLE_SENSOR_COMMAND:RECIVE_ENABLE_SENSOR_COMMAND_RX();
     3a4:	83 cf       	rjmp	.-250    	; 0x2ac <RECIVE_ENABLE_SENSOR_COMMAND_RX>
		break;
     3a6:	08 95       	ret
		case RECIVE_DISABLE_SENSOR_COMMAND:RECIVE_DISABLE_SENSOR_COMMAND_RX();
     3a8:	9b cf       	rjmp	.-202    	; 0x2e0 <RECIVE_DISABLE_SENSOR_COMMAND_RX>
		break;
     3aa:	08 95       	ret
		case RECIVE_DELETE_SENSOR_COMMAND:RECIVE_DELETE_SENSOR_COMMAND_RX();
     3ac:	b2 cf       	rjmp	.-156    	; 0x312 <RECIVE_DELETE_SENSOR_COMMAND_RX>
		break;
     3ae:	08 95       	ret
		case RECIVE_ADJUST_LED_COMMAND:RECIVE_ADJUST_LED_COMMAND_RX();
     3b0:	ca cf       	rjmp	.-108    	; 0x346 <RECIVE_ADJUST_LED_COMMAND_RX>
     3b2:	08 95       	ret

000003b4 <BLUETOOTH_RESET_ALL_SURE>:
/***************************************************************/

void BLUETOOTH_RESET_ALL_SURE(unsigned char RECIVED)
{
	
	BLUETOOTH_STATE=BLUETOOTH_IDLE;
     3b4:	10 92 98 04 	sts	0x0498, r1
	COUNER_TX_BUFFER=0;
     3b8:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     3bc:	10 92 96 04 	sts	0x0496, r1
	
	if (RECIVED==RESET_SURE_FLAG)
     3c0:	8d 32       	cpi	r24, 0x2D	; 45
     3c2:	31 f4       	brne	.+12     	; 0x3d0 <BLUETOOTH_RESET_ALL_SURE+0x1c>
	{
		F_B_RESET_ALL=1;
     3c4:	81 e0       	ldi	r24, 0x01	; 1
     3c6:	80 93 74 0e 	sts	0x0E74, r24
		UDR0=ACK_COMMAND;
     3ca:	8a ea       	ldi	r24, 0xAA	; 170
     3cc:	8c b9       	out	0x0c, r24	; 12
     3ce:	08 95       	ret
	}
	else
	{
		UDR0=NACK_COMMAND;
     3d0:	8d ed       	ldi	r24, 0xDD	; 221
     3d2:	8c b9       	out	0x0c, r24	; 12
     3d4:	08 95       	ret

000003d6 <BLUETOOTH_RECIVING_RESET_SURE>:
}

void BLUETOOTH_RECIVING_RESET_SURE(unsigned char RECIVED)
{
	
	BLUETOOTH_STATE=BLUETOOTH_IDLE;
     3d6:	10 92 98 04 	sts	0x0498, r1
	COUNER_TX_BUFFER=0;
     3da:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     3de:	10 92 96 04 	sts	0x0496, r1
	
	if (RECIVED==RESET_SURE_FLAG)
     3e2:	8d 32       	cpi	r24, 0x2D	; 45
     3e4:	31 f4       	brne	.+12     	; 0x3f2 <BLUETOOTH_RECIVING_RESET_SURE+0x1c>
	{
		F_B_RESET_SENSORS=1;
     3e6:	81 e0       	ldi	r24, 0x01	; 1
     3e8:	80 93 6a 0e 	sts	0x0E6A, r24
		UDR0=ACK_COMMAND;
     3ec:	8a ea       	ldi	r24, 0xAA	; 170
     3ee:	8c b9       	out	0x0c, r24	; 12
     3f0:	08 95       	ret
	}
	else
	{
		UDR0=NACK_COMMAND;
     3f2:	8d ed       	ldi	r24, 0xDD	; 221
     3f4:	8c b9       	out	0x0c, r24	; 12
     3f6:	08 95       	ret

000003f8 <BLUETOOTH_RECIVING_USER_PASS_RX>:
	
	
}
/*BLUETOOTH RECIVING DATA*/
void BLUETOOTH_RECIVING_USER_PASS_RX(unsigned char RECIVED)
{
     3f8:	cf 93       	push	r28
     3fa:	df 93       	push	r29
     3fc:	1f 92       	push	r1
     3fe:	cd b7       	in	r28, 0x3d	; 61
     400:	de b7       	in	r29, 0x3e	; 62
	RX_BUFFER[COUNER_RX_BUFFER]=RECIVED;
     402:	e0 91 95 04 	lds	r30, 0x0495
     406:	f0 e0       	ldi	r31, 0x00	; 0
     408:	ec 57       	subi	r30, 0x7C	; 124
     40a:	f3 4f       	sbci	r31, 0xF3	; 243
     40c:	80 83       	st	Z, r24
	COUNER_RX_BUFFER++;
     40e:	80 91 95 04 	lds	r24, 0x0495
     412:	8f 5f       	subi	r24, 0xFF	; 255
     414:	80 93 95 04 	sts	0x0495, r24
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
     418:	90 91 95 04 	lds	r25, 0x0495
     41c:	80 91 94 04 	lds	r24, 0x0494
     420:	98 13       	cpse	r25, r24
     422:	2d c0       	rjmp	.+90     	; 0x47e <BLUETOOTH_RECIVING_USER_PASS_RX+0x86>
	{
		volatile unsigned char i;
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     424:	10 92 98 04 	sts	0x0498, r1
		for (i=0;i<15;++i)
     428:	19 82       	std	Y+1, r1	; 0x01
     42a:	89 81       	ldd	r24, Y+1	; 0x01
     42c:	8f 30       	cpi	r24, 0x0F	; 15
     42e:	80 f4       	brcc	.+32     	; 0x450 <BLUETOOTH_RECIVING_USER_PASS_RX+0x58>
		{
			F_B_USER_NAME[i]=RX_BUFFER[i];
     430:	e9 81       	ldd	r30, Y+1	; 0x01
     432:	f0 e0       	ldi	r31, 0x00	; 0
     434:	a9 81       	ldd	r26, Y+1	; 0x01
     436:	b0 e0       	ldi	r27, 0x00	; 0
     438:	ac 57       	subi	r26, 0x7C	; 124
     43a:	b3 4f       	sbci	r27, 0xF3	; 243
     43c:	8c 91       	ld	r24, X
     43e:	e1 58       	subi	r30, 0x81	; 129
     440:	ff 4e       	sbci	r31, 0xEF	; 239
     442:	80 83       	st	Z, r24
	COUNER_RX_BUFFER++;
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
	{
		volatile unsigned char i;
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
		for (i=0;i<15;++i)
     444:	89 81       	ldd	r24, Y+1	; 0x01
     446:	8f 5f       	subi	r24, 0xFF	; 255
     448:	89 83       	std	Y+1, r24	; 0x01
     44a:	89 81       	ldd	r24, Y+1	; 0x01
     44c:	8f 30       	cpi	r24, 0x0F	; 15
     44e:	80 f3       	brcs	.-32     	; 0x430 <BLUETOOTH_RECIVING_USER_PASS_RX+0x38>
		{
			F_B_USER_NAME[i]=RX_BUFFER[i];
		}
		for (i=0;i<15;++i)
     450:	19 82       	std	Y+1, r1	; 0x01
     452:	89 81       	ldd	r24, Y+1	; 0x01
     454:	8f 30       	cpi	r24, 0x0F	; 15
     456:	80 f4       	brcc	.+32     	; 0x478 <BLUETOOTH_RECIVING_USER_PASS_RX+0x80>
		{
			F_B_PASSWORD[i]=RX_BUFFER[i+15];
     458:	e9 81       	ldd	r30, Y+1	; 0x01
     45a:	f0 e0       	ldi	r31, 0x00	; 0
     45c:	a9 81       	ldd	r26, Y+1	; 0x01
     45e:	b0 e0       	ldi	r27, 0x00	; 0
     460:	ad 56       	subi	r26, 0x6D	; 109
     462:	b3 4f       	sbci	r27, 0xF3	; 243
     464:	8c 91       	ld	r24, X
     466:	e9 55       	subi	r30, 0x59	; 89
     468:	ff 4e       	sbci	r31, 0xEF	; 239
     46a:	80 83       	st	Z, r24
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
		for (i=0;i<15;++i)
		{
			F_B_USER_NAME[i]=RX_BUFFER[i];
		}
		for (i=0;i<15;++i)
     46c:	89 81       	ldd	r24, Y+1	; 0x01
     46e:	8f 5f       	subi	r24, 0xFF	; 255
     470:	89 83       	std	Y+1, r24	; 0x01
     472:	89 81       	ldd	r24, Y+1	; 0x01
     474:	8f 30       	cpi	r24, 0x0F	; 15
     476:	80 f3       	brcs	.-32     	; 0x458 <BLUETOOTH_RECIVING_USER_PASS_RX+0x60>
		{
			F_B_PASSWORD[i]=RX_BUFFER[i+15];
		}
		F_B_NEW_USER_PASS=1;
     478:	81 e0       	ldi	r24, 0x01	; 1
     47a:	80 93 5a 0c 	sts	0x0C5A, r24
	}
	COUNER_TX_BUFFER=0;
     47e:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     482:	10 92 96 04 	sts	0x0496, r1
	UDR0=ACK_COMMAND;
     486:	8a ea       	ldi	r24, 0xAA	; 170
     488:	8c b9       	out	0x0c, r24	; 12
}
     48a:	0f 90       	pop	r0
     48c:	df 91       	pop	r29
     48e:	cf 91       	pop	r28
     490:	08 95       	ret

00000492 <BLUETOOTH_RECIVING_IOT_PAR_RX>:

void BLUETOOTH_RECIVING_IOT_PAR_RX(unsigned char RECIVED)
{
     492:	cf 93       	push	r28
     494:	df 93       	push	r29
     496:	1f 92       	push	r1
     498:	cd b7       	in	r28, 0x3d	; 61
     49a:	de b7       	in	r29, 0x3e	; 62
	RX_BUFFER[COUNER_RX_BUFFER]=RECIVED;
     49c:	e0 91 95 04 	lds	r30, 0x0495
     4a0:	f0 e0       	ldi	r31, 0x00	; 0
     4a2:	ec 57       	subi	r30, 0x7C	; 124
     4a4:	f3 4f       	sbci	r31, 0xF3	; 243
     4a6:	80 83       	st	Z, r24
	COUNER_RX_BUFFER++;
     4a8:	80 91 95 04 	lds	r24, 0x0495
     4ac:	8f 5f       	subi	r24, 0xFF	; 255
     4ae:	80 93 95 04 	sts	0x0495, r24
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
     4b2:	90 91 95 04 	lds	r25, 0x0495
     4b6:	80 91 94 04 	lds	r24, 0x0494
     4ba:	98 13       	cpse	r25, r24
     4bc:	39 c0       	rjmp	.+114    	; 0x530 <BLUETOOTH_RECIVING_IOT_PAR_RX+0x9e>
	{
		volatile unsigned char i;
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     4be:	10 92 98 04 	sts	0x0498, r1
		F_B_CH_ID_LENGTH=RX_BUFFER[0];
     4c2:	80 91 84 0c 	lds	r24, 0x0C84
     4c6:	80 93 e7 10 	sts	0x10E7, r24
		for (i=0;i<10;++i)
     4ca:	19 82       	std	Y+1, r1	; 0x01
     4cc:	89 81       	ldd	r24, Y+1	; 0x01
     4ce:	8a 30       	cpi	r24, 0x0A	; 10
     4d0:	80 f4       	brcc	.+32     	; 0x4f2 <BLUETOOTH_RECIVING_IOT_PAR_RX+0x60>
		{
			F_B_CH_ID[i]=RX_BUFFER[i+1];
     4d2:	e9 81       	ldd	r30, Y+1	; 0x01
     4d4:	f0 e0       	ldi	r31, 0x00	; 0
     4d6:	a9 81       	ldd	r26, Y+1	; 0x01
     4d8:	b0 e0       	ldi	r27, 0x00	; 0
     4da:	ab 57       	subi	r26, 0x7B	; 123
     4dc:	b3 4f       	sbci	r27, 0xF3	; 243
     4de:	8c 91       	ld	r24, X
     4e0:	e1 5e       	subi	r30, 0xE1	; 225
     4e2:	f0 4f       	sbci	r31, 0xF0	; 240
     4e4:	80 83       	st	Z, r24
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
	{
		volatile unsigned char i;
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
		F_B_CH_ID_LENGTH=RX_BUFFER[0];
		for (i=0;i<10;++i)
     4e6:	89 81       	ldd	r24, Y+1	; 0x01
     4e8:	8f 5f       	subi	r24, 0xFF	; 255
     4ea:	89 83       	std	Y+1, r24	; 0x01
     4ec:	89 81       	ldd	r24, Y+1	; 0x01
     4ee:	8a 30       	cpi	r24, 0x0A	; 10
     4f0:	80 f3       	brcs	.-32     	; 0x4d2 <BLUETOOTH_RECIVING_IOT_PAR_RX+0x40>
		{
			F_B_CH_ID[i]=RX_BUFFER[i+1];
		}
		F_B_WRITE_KEY_LENGTH=RX_BUFFER[11];
     4f2:	80 91 8f 0c 	lds	r24, 0x0C8F
     4f6:	80 93 c4 10 	sts	0x10C4, r24
		for (i=0;i<25;++i)
     4fa:	19 82       	std	Y+1, r1	; 0x01
     4fc:	89 81       	ldd	r24, Y+1	; 0x01
     4fe:	89 31       	cpi	r24, 0x19	; 25
     500:	80 f4       	brcc	.+32     	; 0x522 <BLUETOOTH_RECIVING_IOT_PAR_RX+0x90>
		{
			F_B_WRITE_KEY[i]=RX_BUFFER[i+12];
     502:	e9 81       	ldd	r30, Y+1	; 0x01
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	a9 81       	ldd	r26, Y+1	; 0x01
     508:	b0 e0       	ldi	r27, 0x00	; 0
     50a:	a0 57       	subi	r26, 0x70	; 112
     50c:	b3 4f       	sbci	r27, 0xF3	; 243
     50e:	8c 91       	ld	r24, X
     510:	e2 57       	subi	r30, 0x72	; 114
     512:	ff 4e       	sbci	r31, 0xEF	; 239
     514:	80 83       	st	Z, r24
		for (i=0;i<10;++i)
		{
			F_B_CH_ID[i]=RX_BUFFER[i+1];
		}
		F_B_WRITE_KEY_LENGTH=RX_BUFFER[11];
		for (i=0;i<25;++i)
     516:	89 81       	ldd	r24, Y+1	; 0x01
     518:	8f 5f       	subi	r24, 0xFF	; 255
     51a:	89 83       	std	Y+1, r24	; 0x01
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	89 31       	cpi	r24, 0x19	; 25
     520:	80 f3       	brcs	.-32     	; 0x502 <BLUETOOTH_RECIVING_IOT_PAR_RX+0x70>
		{
			F_B_WRITE_KEY[i]=RX_BUFFER[i+12];
		}
		F_B_FIELD_NUM=RX_BUFFER[37];
     522:	80 91 a9 0c 	lds	r24, 0x0CA9
     526:	80 93 c1 10 	sts	0x10C1, r24
		F_B_NEW_IOT_PAR=1;
     52a:	81 e0       	ldi	r24, 0x01	; 1
     52c:	80 93 59 0c 	sts	0x0C59, r24
	}
	COUNER_TX_BUFFER=0;
     530:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     534:	10 92 96 04 	sts	0x0496, r1
	UDR0=ACK_COMMAND;
     538:	8a ea       	ldi	r24, 0xAA	; 170
     53a:	8c b9       	out	0x0c, r24	; 12
}
     53c:	0f 90       	pop	r0
     53e:	df 91       	pop	r29
     540:	cf 91       	pop	r28
     542:	08 95       	ret

00000544 <BLUETOOTH_RECIVING_ADD_SENSOR_RX>:
void BLUETOOTH_RECIVING_ADD_SENSOR_RX(unsigned char RECIVED)
{
	RX_BUFFER[COUNER_RX_BUFFER]=RECIVED;
     544:	e0 91 95 04 	lds	r30, 0x0495
     548:	f0 e0       	ldi	r31, 0x00	; 0
     54a:	ec 57       	subi	r30, 0x7C	; 124
     54c:	f3 4f       	sbci	r31, 0xF3	; 243
     54e:	80 83       	st	Z, r24
	COUNER_RX_BUFFER++;
     550:	80 91 95 04 	lds	r24, 0x0495
     554:	8f 5f       	subi	r24, 0xFF	; 255
     556:	80 93 95 04 	sts	0x0495, r24
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
     55a:	90 91 95 04 	lds	r25, 0x0495
     55e:	80 91 94 04 	lds	r24, 0x0494
     562:	98 13       	cpse	r25, r24
     564:	31 c0       	rjmp	.+98     	; 0x5c8 <BLUETOOTH_RECIVING_ADD_SENSOR_RX+0x84>
	{
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     566:	10 92 98 04 	sts	0x0498, r1
		B_NEW_SENSOR_BUFFER.SENSOR_ADDRESS[0]=RX_BUFFER[4];/*LEAST*/
     56a:	80 91 88 0c 	lds	r24, 0x0C88
     56e:	80 93 15 0e 	sts	0x0E15, r24
		B_NEW_SENSOR_BUFFER.SENSOR_ADDRESS[1]=RX_BUFFER[3];
     572:	80 91 87 0c 	lds	r24, 0x0C87
     576:	80 93 16 0e 	sts	0x0E16, r24
		B_NEW_SENSOR_BUFFER.SENSOR_ADDRESS[2]=RX_BUFFER[2];
     57a:	80 91 86 0c 	lds	r24, 0x0C86
     57e:	80 93 17 0e 	sts	0x0E17, r24
		B_NEW_SENSOR_BUFFER.SENSOR_ADDRESS[3]=RX_BUFFER[1];
     582:	80 91 85 0c 	lds	r24, 0x0C85
     586:	80 93 18 0e 	sts	0x0E18, r24
		B_NEW_SENSOR_BUFFER.SENSOR_ADDRESS[4]=RX_BUFFER[0];/*MOST*/
     58a:	80 91 84 0c 	lds	r24, 0x0C84
     58e:	80 93 19 0e 	sts	0x0E19, r24
		B_NEW_SENSOR_BUFFER.SENSOR_PASSWORD[0]=RX_BUFFER[5];
     592:	80 91 89 0c 	lds	r24, 0x0C89
     596:	80 93 1a 0e 	sts	0x0E1A, r24
		B_NEW_SENSOR_BUFFER.SENSOR_PASSWORD[1]=RX_BUFFER[6];
     59a:	80 91 8a 0c 	lds	r24, 0x0C8A
     59e:	80 93 1b 0e 	sts	0x0E1B, r24
		B_NEW_SENSOR_BUFFER.SENSOR_PASSWORD[2]=RX_BUFFER[7];
     5a2:	80 91 8b 0c 	lds	r24, 0x0C8B
     5a6:	80 93 1c 0e 	sts	0x0E1C, r24
		B_NEW_SENSOR_BUFFER.SENSOR_PASSWORD[3]=RX_BUFFER[8];
     5aa:	80 91 8c 0c 	lds	r24, 0x0C8C
     5ae:	80 93 1d 0e 	sts	0x0E1D, r24
		B_NEW_SENSOR_BUFFER.SENSOR_VERSION=RX_BUFFER[9];
     5b2:	80 91 8d 0c 	lds	r24, 0x0C8D
     5b6:	80 93 1e 0e 	sts	0x0E1E, r24
		B_NEW_SENSOR_BUFFER.SENSOR_TYPE=RX_BUFFER[10];
     5ba:	80 91 8e 0c 	lds	r24, 0x0C8E
     5be:	80 93 1f 0e 	sts	0x0E1F, r24
		F_B_ADD_NEW_SENSOR=1;
     5c2:	81 e0       	ldi	r24, 0x01	; 1
     5c4:	80 93 12 0d 	sts	0x0D12, r24
	}
	COUNER_TX_BUFFER=0;
     5c8:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     5cc:	10 92 96 04 	sts	0x0496, r1
	UDR0=ACK_COMMAND;
     5d0:	8a ea       	ldi	r24, 0xAA	; 170
     5d2:	8c b9       	out	0x0c, r24	; 12
     5d4:	08 95       	ret

000005d6 <BLUETOOTH_RECIVING_ENABLE_SENSOR_RX>:
}

void BLUETOOTH_RECIVING_ENABLE_SENSOR_RX(unsigned char RECIVED)
{
	RX_BUFFER[COUNER_RX_BUFFER]=RECIVED;
     5d6:	e0 91 95 04 	lds	r30, 0x0495
     5da:	f0 e0       	ldi	r31, 0x00	; 0
     5dc:	ec 57       	subi	r30, 0x7C	; 124
     5de:	f3 4f       	sbci	r31, 0xF3	; 243
     5e0:	80 83       	st	Z, r24
	COUNER_RX_BUFFER++;
     5e2:	80 91 95 04 	lds	r24, 0x0495
     5e6:	8f 5f       	subi	r24, 0xFF	; 255
     5e8:	80 93 95 04 	sts	0x0495, r24
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
     5ec:	90 91 95 04 	lds	r25, 0x0495
     5f0:	80 91 94 04 	lds	r24, 0x0494
     5f4:	98 13       	cpse	r25, r24
     5f6:	19 c0       	rjmp	.+50     	; 0x62a <BLUETOOTH_RECIVING_ENABLE_SENSOR_RX+0x54>
	{
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     5f8:	10 92 98 04 	sts	0x0498, r1
		B_SENSOR_ADDRESS_ENABLE[0]=RX_BUFFER[4];
     5fc:	80 91 88 0c 	lds	r24, 0x0C88
     600:	80 93 65 0e 	sts	0x0E65, r24
		B_SENSOR_ADDRESS_ENABLE[1]=RX_BUFFER[3];
     604:	80 91 87 0c 	lds	r24, 0x0C87
     608:	80 93 66 0e 	sts	0x0E66, r24
		B_SENSOR_ADDRESS_ENABLE[2]=RX_BUFFER[2];
     60c:	80 91 86 0c 	lds	r24, 0x0C86
     610:	80 93 67 0e 	sts	0x0E67, r24
		B_SENSOR_ADDRESS_ENABLE[3]=RX_BUFFER[1];
     614:	80 91 85 0c 	lds	r24, 0x0C85
     618:	80 93 68 0e 	sts	0x0E68, r24
		B_SENSOR_ADDRESS_ENABLE[4]=RX_BUFFER[0];
     61c:	80 91 84 0c 	lds	r24, 0x0C84
     620:	80 93 69 0e 	sts	0x0E69, r24
		/*B_SENSOR_ADDRESS_L_ENABLE=5;*/
		F_B_ENABLE_SENSOR=1;
     624:	81 e0       	ldi	r24, 0x01	; 1
     626:	80 93 31 0e 	sts	0x0E31, r24
	}
	COUNER_TX_BUFFER=0;
     62a:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     62e:	10 92 96 04 	sts	0x0496, r1
	UDR0=ACK_COMMAND;
     632:	8a ea       	ldi	r24, 0xAA	; 170
     634:	8c b9       	out	0x0c, r24	; 12
     636:	08 95       	ret

00000638 <BLUETOOTH_RECIVING_DISABLE_SENSOR_RX>:
}

void BLUETOOTH_RECIVING_DISABLE_SENSOR_RX(unsigned char RECIVED)
{
	RX_BUFFER[COUNER_RX_BUFFER]=RECIVED;
     638:	e0 91 95 04 	lds	r30, 0x0495
     63c:	f0 e0       	ldi	r31, 0x00	; 0
     63e:	ec 57       	subi	r30, 0x7C	; 124
     640:	f3 4f       	sbci	r31, 0xF3	; 243
     642:	80 83       	st	Z, r24
	COUNER_RX_BUFFER++;
     644:	80 91 95 04 	lds	r24, 0x0495
     648:	8f 5f       	subi	r24, 0xFF	; 255
     64a:	80 93 95 04 	sts	0x0495, r24
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
     64e:	90 91 95 04 	lds	r25, 0x0495
     652:	80 91 94 04 	lds	r24, 0x0494
     656:	98 13       	cpse	r25, r24
     658:	19 c0       	rjmp	.+50     	; 0x68c <BLUETOOTH_RECIVING_DISABLE_SENSOR_RX+0x54>
	{
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     65a:	10 92 98 04 	sts	0x0498, r1
		B_SENSOR_ADDRESS_DISABLE[0]=RX_BUFFER[4];
     65e:	80 91 88 0c 	lds	r24, 0x0C88
     662:	80 93 6b 0e 	sts	0x0E6B, r24
		B_SENSOR_ADDRESS_DISABLE[1]=RX_BUFFER[3];
     666:	80 91 87 0c 	lds	r24, 0x0C87
     66a:	80 93 6c 0e 	sts	0x0E6C, r24
		B_SENSOR_ADDRESS_DISABLE[2]=RX_BUFFER[2];
     66e:	80 91 86 0c 	lds	r24, 0x0C86
     672:	80 93 6d 0e 	sts	0x0E6D, r24
		B_SENSOR_ADDRESS_DISABLE[3]=RX_BUFFER[1];
     676:	80 91 85 0c 	lds	r24, 0x0C85
     67a:	80 93 6e 0e 	sts	0x0E6E, r24
		B_SENSOR_ADDRESS_DISABLE[4]=RX_BUFFER[0];
     67e:	80 91 84 0c 	lds	r24, 0x0C84
     682:	80 93 6f 0e 	sts	0x0E6F, r24
		/*B_SENSOR_ADDRESS_L_ENABLE=5;*/
		F_B_DISABLE_SENSOR=1;
     686:	81 e0       	ldi	r24, 0x01	; 1
     688:	80 93 73 0e 	sts	0x0E73, r24
	}
	COUNER_TX_BUFFER=0;
     68c:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     690:	10 92 96 04 	sts	0x0496, r1
	UDR0=ACK_COMMAND;
     694:	8a ea       	ldi	r24, 0xAA	; 170
     696:	8c b9       	out	0x0c, r24	; 12
     698:	08 95       	ret

0000069a <BLUETOOTH_RECIVING_DELETE_SENSOR_RX>:
}

void BLUETOOTH_RECIVING_DELETE_SENSOR_RX(unsigned char RECIVED)
{
	RX_BUFFER[COUNER_RX_BUFFER]=RECIVED;
     69a:	e0 91 95 04 	lds	r30, 0x0495
     69e:	f0 e0       	ldi	r31, 0x00	; 0
     6a0:	ec 57       	subi	r30, 0x7C	; 124
     6a2:	f3 4f       	sbci	r31, 0xF3	; 243
     6a4:	80 83       	st	Z, r24
	COUNER_RX_BUFFER++;
     6a6:	80 91 95 04 	lds	r24, 0x0495
     6aa:	8f 5f       	subi	r24, 0xFF	; 255
     6ac:	80 93 95 04 	sts	0x0495, r24
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
     6b0:	90 91 95 04 	lds	r25, 0x0495
     6b4:	80 91 94 04 	lds	r24, 0x0494
     6b8:	98 13       	cpse	r25, r24
     6ba:	19 c0       	rjmp	.+50     	; 0x6ee <BLUETOOTH_RECIVING_DELETE_SENSOR_RX+0x54>
	{
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     6bc:	10 92 98 04 	sts	0x0498, r1
		B_SENSOR_ADDRESS_DELETE[0]=RX_BUFFER[4];
     6c0:	80 91 88 0c 	lds	r24, 0x0C88
     6c4:	80 93 0e 0e 	sts	0x0E0E, r24
		B_SENSOR_ADDRESS_DELETE[1]=RX_BUFFER[3];
     6c8:	80 91 87 0c 	lds	r24, 0x0C87
     6cc:	80 93 0f 0e 	sts	0x0E0F, r24
		B_SENSOR_ADDRESS_DELETE[2]=RX_BUFFER[2];
     6d0:	80 91 86 0c 	lds	r24, 0x0C86
     6d4:	80 93 10 0e 	sts	0x0E10, r24
		B_SENSOR_ADDRESS_DELETE[3]=RX_BUFFER[1];
     6d8:	80 91 85 0c 	lds	r24, 0x0C85
     6dc:	80 93 11 0e 	sts	0x0E11, r24
		B_SENSOR_ADDRESS_DELETE[4]=RX_BUFFER[0];
     6e0:	80 91 84 0c 	lds	r24, 0x0C84
     6e4:	80 93 12 0e 	sts	0x0E12, r24
		/*B_SENSOR_ADDRESS_L_ENABLE=5;*/
		F_B_DELETE_SENSOR=1;
     6e8:	81 e0       	ldi	r24, 0x01	; 1
     6ea:	80 93 13 0e 	sts	0x0E13, r24
	}
	COUNER_TX_BUFFER=0;
     6ee:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     6f2:	10 92 96 04 	sts	0x0496, r1
	UDR0=ACK_COMMAND;
     6f6:	8a ea       	ldi	r24, 0xAA	; 170
     6f8:	8c b9       	out	0x0c, r24	; 12
     6fa:	08 95       	ret

000006fc <BLUETOOTH_RECIVING_ADJUST_LED_RX>:

#define  INVERTED_LED_GRID 1

void BLUETOOTH_RECIVING_ADJUST_LED_RX(unsigned char RECIVED)
{
	RX_BUFFER[COUNER_RX_BUFFER]=RECIVED;
     6fc:	e0 91 95 04 	lds	r30, 0x0495
     700:	f0 e0       	ldi	r31, 0x00	; 0
     702:	ec 57       	subi	r30, 0x7C	; 124
     704:	f3 4f       	sbci	r31, 0xF3	; 243
     706:	80 83       	st	Z, r24
	COUNER_RX_BUFFER++;
     708:	80 91 95 04 	lds	r24, 0x0495
     70c:	8f 5f       	subi	r24, 0xFF	; 255
     70e:	80 93 95 04 	sts	0x0495, r24
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
     712:	90 91 95 04 	lds	r25, 0x0495
     716:	80 91 94 04 	lds	r24, 0x0494
     71a:	98 13       	cpse	r25, r24
     71c:	25 c0       	rjmp	.+74     	; 0x768 <BLUETOOTH_RECIVING_ADJUST_LED_RX+0x6c>
	{
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     71e:	10 92 98 04 	sts	0x0498, r1
		#if INVERTED_LED_GRID
		CHANGE_LED_GRID(RX_BUFFER[0],7);
     722:	80 91 84 0c 	lds	r24, 0x0C84
     726:	80 93 07 01 	sts	0x0107, r24
		CHANGE_LED_GRID(RX_BUFFER[1],6);
     72a:	80 91 85 0c 	lds	r24, 0x0C85
     72e:	80 93 06 01 	sts	0x0106, r24
		CHANGE_LED_GRID(RX_BUFFER[2],5);
     732:	80 91 86 0c 	lds	r24, 0x0C86
     736:	80 93 05 01 	sts	0x0105, r24
		CHANGE_LED_GRID(RX_BUFFER[3],4);
     73a:	80 91 87 0c 	lds	r24, 0x0C87
     73e:	80 93 04 01 	sts	0x0104, r24
		CHANGE_LED_GRID(RX_BUFFER[4],3);
     742:	80 91 88 0c 	lds	r24, 0x0C88
     746:	80 93 03 01 	sts	0x0103, r24
		CHANGE_LED_GRID(RX_BUFFER[5],2);
     74a:	80 91 89 0c 	lds	r24, 0x0C89
     74e:	80 93 02 01 	sts	0x0102, r24
		CHANGE_LED_GRID(RX_BUFFER[6],1);
     752:	80 91 8a 0c 	lds	r24, 0x0C8A
     756:	80 93 01 01 	sts	0x0101, r24
		CHANGE_LED_GRID(RX_BUFFER[7],0);
     75a:	80 91 8b 0c 	lds	r24, 0x0C8B
     75e:	80 93 00 01 	sts	0x0100, r24
		CHANGE_LED_GRID(RX_BUFFER[6],6);
		CHANGE_LED_GRID(RX_BUFFER[7],7);
		#endif
		
		
		F_B_NEW_LED_GRID=1;
     762:	81 e0       	ldi	r24, 0x01	; 1
     764:	80 93 99 04 	sts	0x0499, r24
	}
	COUNER_TX_BUFFER=0;
     768:	10 92 97 04 	sts	0x0497, r1
	TX_BUFFER_SIZE=0;
     76c:	10 92 96 04 	sts	0x0496, r1
	UDR0=ACK_COMMAND;
     770:	8a ea       	ldi	r24, 0xAA	; 170
     772:	8c b9       	out	0x0c, r24	; 12
     774:	08 95       	ret

00000776 <BLUETOOTH_READING_STATE_SENSOR_RX>:

/*READING*/


void BLUETOOTH_READING_STATE_SENSOR_RX(unsigned char RECIVED)
{
     776:	cf 93       	push	r28
     778:	df 93       	push	r29
     77a:	1f 92       	push	r1
     77c:	cd b7       	in	r28, 0x3d	; 61
     77e:	de b7       	in	r29, 0x3e	; 62
	RX_BUFFER[COUNER_RX_BUFFER]=RECIVED;
     780:	e0 91 95 04 	lds	r30, 0x0495
     784:	f0 e0       	ldi	r31, 0x00	; 0
     786:	ec 57       	subi	r30, 0x7C	; 124
     788:	f3 4f       	sbci	r31, 0xF3	; 243
     78a:	80 83       	st	Z, r24
	COUNER_RX_BUFFER++;
     78c:	80 91 95 04 	lds	r24, 0x0495
     790:	8f 5f       	subi	r24, 0xFF	; 255
     792:	80 93 95 04 	sts	0x0495, r24
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
     796:	90 91 95 04 	lds	r25, 0x0495
     79a:	80 91 94 04 	lds	r24, 0x0494
     79e:	98 13       	cpse	r25, r24
     7a0:	1c c0       	rjmp	.+56     	; 0x7da <BLUETOOTH_READING_STATE_SENSOR_RX+0x64>
	{	
		volatile char INDEX;
		INDEX=FIND_SENSOR(RX_BUFFER,5);
     7a2:	65 e0       	ldi	r22, 0x05	; 5
     7a4:	84 e8       	ldi	r24, 0x84	; 132
     7a6:	9c e0       	ldi	r25, 0x0C	; 12
     7a8:	0e 94 a3 36 	call	0x6d46	; 0x6d46 <FIND_SENSOR>
     7ac:	89 83       	std	Y+1, r24	; 0x01
		if (INDEX==-1)
     7ae:	89 81       	ldd	r24, Y+1	; 0x01
		{
			TX_BUFFER[1]=0;
		}
		else
		{
			TX_BUFFER[1]=MY_SENSORS[INDEX].SENSOR_STATE;
     7b0:	e9 81       	ldd	r30, Y+1	; 0x01
     7b2:	89 e1       	ldi	r24, 0x19	; 25
     7b4:	e8 9f       	mul	r30, r24
     7b6:	f0 01       	movw	r30, r0
     7b8:	11 24       	eor	r1, r1
     7ba:	ed 5e       	subi	r30, 0xED	; 237
     7bc:	f2 4f       	sbci	r31, 0xF2	; 242
     7be:	84 85       	ldd	r24, Z+12	; 0x0c
     7c0:	80 93 5d 0c 	sts	0x0C5D, r24
		}
		COUNER_TX_BUFFER=1;
     7c4:	81 e0       	ldi	r24, 0x01	; 1
     7c6:	80 93 97 04 	sts	0x0497, r24
		TX_BUFFER_SIZE=2;
     7ca:	82 e0       	ldi	r24, 0x02	; 2
     7cc:	80 93 96 04 	sts	0x0496, r24
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     7d0:	10 92 98 04 	sts	0x0498, r1
		UDR0=ACK_COMMAND;	
     7d4:	8a ea       	ldi	r24, 0xAA	; 170
     7d6:	8c b9       	out	0x0c, r24	; 12
     7d8:	06 c0       	rjmp	.+12     	; 0x7e6 <BLUETOOTH_READING_STATE_SENSOR_RX+0x70>
	}
	else
	{
			COUNER_TX_BUFFER=0;
     7da:	10 92 97 04 	sts	0x0497, r1
			TX_BUFFER_SIZE=0;
     7de:	10 92 96 04 	sts	0x0496, r1
			UDR0=ACK_COMMAND;
     7e2:	8a ea       	ldi	r24, 0xAA	; 170
     7e4:	8c b9       	out	0x0c, r24	; 12
	}

}
     7e6:	0f 90       	pop	r0
     7e8:	df 91       	pop	r29
     7ea:	cf 91       	pop	r28
     7ec:	08 95       	ret

000007ee <BLUETOOTH_READING_CONNECTED_SENSOR_RX>:



void BLUETOOTH_READING_CONNECTED_SENSOR_RX(unsigned char RECIVED)
{
     7ee:	cf 93       	push	r28
     7f0:	df 93       	push	r29
     7f2:	1f 92       	push	r1
     7f4:	cd b7       	in	r28, 0x3d	; 61
     7f6:	de b7       	in	r29, 0x3e	; 62
	RX_BUFFER[COUNER_RX_BUFFER]=RECIVED;
     7f8:	e0 91 95 04 	lds	r30, 0x0495
     7fc:	f0 e0       	ldi	r31, 0x00	; 0
     7fe:	ec 57       	subi	r30, 0x7C	; 124
     800:	f3 4f       	sbci	r31, 0xF3	; 243
     802:	80 83       	st	Z, r24
	COUNER_RX_BUFFER++;
     804:	80 91 95 04 	lds	r24, 0x0495
     808:	8f 5f       	subi	r24, 0xFF	; 255
     80a:	80 93 95 04 	sts	0x0495, r24
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
     80e:	90 91 95 04 	lds	r25, 0x0495
     812:	80 91 94 04 	lds	r24, 0x0494
     816:	98 13       	cpse	r25, r24
     818:	1c c0       	rjmp	.+56     	; 0x852 <BLUETOOTH_READING_CONNECTED_SENSOR_RX+0x64>
	{
		volatile  char INDEX;
		INDEX=FIND_SENSOR(RX_BUFFER,5);
     81a:	65 e0       	ldi	r22, 0x05	; 5
     81c:	84 e8       	ldi	r24, 0x84	; 132
     81e:	9c e0       	ldi	r25, 0x0C	; 12
     820:	0e 94 a3 36 	call	0x6d46	; 0x6d46 <FIND_SENSOR>
     824:	89 83       	std	Y+1, r24	; 0x01
		if (INDEX==-1)
     826:	89 81       	ldd	r24, Y+1	; 0x01
		{
			TX_BUFFER[1]=0;
		}
		else
		{
			TX_BUFFER[1]=MY_SENSORS[INDEX].F_CONNECTED;
     828:	e9 81       	ldd	r30, Y+1	; 0x01
     82a:	89 e1       	ldi	r24, 0x19	; 25
     82c:	e8 9f       	mul	r30, r24
     82e:	f0 01       	movw	r30, r0
     830:	11 24       	eor	r1, r1
     832:	ed 5e       	subi	r30, 0xED	; 237
     834:	f2 4f       	sbci	r31, 0xF2	; 242
     836:	86 85       	ldd	r24, Z+14	; 0x0e
     838:	80 93 5d 0c 	sts	0x0C5D, r24
		}
		
		COUNER_TX_BUFFER=1;
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	80 93 97 04 	sts	0x0497, r24
		TX_BUFFER_SIZE=2;
     842:	82 e0       	ldi	r24, 0x02	; 2
     844:	80 93 96 04 	sts	0x0496, r24
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     848:	10 92 98 04 	sts	0x0498, r1
		UDR0=ACK_COMMAND;
     84c:	8a ea       	ldi	r24, 0xAA	; 170
     84e:	8c b9       	out	0x0c, r24	; 12
     850:	06 c0       	rjmp	.+12     	; 0x85e <BLUETOOTH_READING_CONNECTED_SENSOR_RX+0x70>
	}
	else
	{
		COUNER_TX_BUFFER=0;
     852:	10 92 97 04 	sts	0x0497, r1
		TX_BUFFER_SIZE=0;
     856:	10 92 96 04 	sts	0x0496, r1
		UDR0=ACK_COMMAND;
     85a:	8a ea       	ldi	r24, 0xAA	; 170
     85c:	8c b9       	out	0x0c, r24	; 12
	}

}
     85e:	0f 90       	pop	r0
     860:	df 91       	pop	r29
     862:	cf 91       	pop	r28
     864:	08 95       	ret

00000866 <BLUETOOTH_READING_SENSOR_INFO_RX>:

void BLUETOOTH_READING_SENSOR_INFO_RX(unsigned char RECIVED)
{
	RX_BUFFER[COUNER_RX_BUFFER]=RECIVED;
     866:	e0 91 95 04 	lds	r30, 0x0495
     86a:	f0 e0       	ldi	r31, 0x00	; 0
     86c:	ec 57       	subi	r30, 0x7C	; 124
     86e:	f3 4f       	sbci	r31, 0xF3	; 243
     870:	80 83       	st	Z, r24
	COUNER_RX_BUFFER++;
     872:	80 91 95 04 	lds	r24, 0x0495
     876:	8f 5f       	subi	r24, 0xFF	; 255
     878:	80 93 95 04 	sts	0x0495, r24
	if (COUNER_RX_BUFFER==RX_BUFFER_SIZE)
     87c:	90 91 95 04 	lds	r25, 0x0495
     880:	80 91 94 04 	lds	r24, 0x0494
     884:	98 13       	cpse	r25, r24
     886:	85 c0       	rjmp	.+266    	; 0x992 <BLUETOOTH_READING_SENSOR_INFO_RX+0x12c>
	{
		
		
		TX_BUFFER[1]=MY_SENSORS[RX_BUFFER[0]].SENSOR_ADDRESS[4];
     888:	e4 e8       	ldi	r30, 0x84	; 132
     88a:	fc e0       	ldi	r31, 0x0C	; 12
     88c:	a0 81       	ld	r26, Z
     88e:	89 e1       	ldi	r24, 0x19	; 25
     890:	8a 9f       	mul	r24, r26
     892:	d0 01       	movw	r26, r0
     894:	11 24       	eor	r1, r1
     896:	ad 5e       	subi	r26, 0xED	; 237
     898:	b2 4f       	sbci	r27, 0xF2	; 242
     89a:	15 96       	adiw	r26, 0x05	; 5
     89c:	9c 91       	ld	r25, X
     89e:	90 93 5d 0c 	sts	0x0C5D, r25
		TX_BUFFER[2]=MY_SENSORS[RX_BUFFER[0]].SENSOR_ADDRESS[3];
     8a2:	a0 81       	ld	r26, Z
     8a4:	8a 9f       	mul	r24, r26
     8a6:	d0 01       	movw	r26, r0
     8a8:	11 24       	eor	r1, r1
     8aa:	ad 5e       	subi	r26, 0xED	; 237
     8ac:	b2 4f       	sbci	r27, 0xF2	; 242
     8ae:	14 96       	adiw	r26, 0x04	; 4
     8b0:	9c 91       	ld	r25, X
     8b2:	90 93 5e 0c 	sts	0x0C5E, r25
		TX_BUFFER[3]=MY_SENSORS[RX_BUFFER[0]].SENSOR_ADDRESS[2];
     8b6:	a0 81       	ld	r26, Z
     8b8:	8a 9f       	mul	r24, r26
     8ba:	d0 01       	movw	r26, r0
     8bc:	11 24       	eor	r1, r1
     8be:	ad 5e       	subi	r26, 0xED	; 237
     8c0:	b2 4f       	sbci	r27, 0xF2	; 242
     8c2:	13 96       	adiw	r26, 0x03	; 3
     8c4:	9c 91       	ld	r25, X
     8c6:	90 93 5f 0c 	sts	0x0C5F, r25
		TX_BUFFER[4]=MY_SENSORS[RX_BUFFER[0]].SENSOR_ADDRESS[1];
     8ca:	a0 81       	ld	r26, Z
     8cc:	8a 9f       	mul	r24, r26
     8ce:	d0 01       	movw	r26, r0
     8d0:	11 24       	eor	r1, r1
     8d2:	ad 5e       	subi	r26, 0xED	; 237
     8d4:	b2 4f       	sbci	r27, 0xF2	; 242
     8d6:	12 96       	adiw	r26, 0x02	; 2
     8d8:	9c 91       	ld	r25, X
     8da:	90 93 60 0c 	sts	0x0C60, r25
		TX_BUFFER[5]=MY_SENSORS[RX_BUFFER[0]].SENSOR_ADDRESS[0];
     8de:	a0 81       	ld	r26, Z
     8e0:	8a 9f       	mul	r24, r26
     8e2:	d0 01       	movw	r26, r0
     8e4:	11 24       	eor	r1, r1
     8e6:	ad 5e       	subi	r26, 0xED	; 237
     8e8:	b2 4f       	sbci	r27, 0xF2	; 242
     8ea:	11 96       	adiw	r26, 0x01	; 1
     8ec:	9c 91       	ld	r25, X
     8ee:	90 93 61 0c 	sts	0x0C61, r25
	
		TX_BUFFER[6]=MY_SENSORS[RX_BUFFER[0]].SENSOR_PASSWORD[0];
     8f2:	a0 81       	ld	r26, Z
     8f4:	8a 9f       	mul	r24, r26
     8f6:	d0 01       	movw	r26, r0
     8f8:	11 24       	eor	r1, r1
     8fa:	ad 5e       	subi	r26, 0xED	; 237
     8fc:	b2 4f       	sbci	r27, 0xF2	; 242
     8fe:	16 96       	adiw	r26, 0x06	; 6
     900:	9c 91       	ld	r25, X
     902:	90 93 62 0c 	sts	0x0C62, r25
		TX_BUFFER[7]=MY_SENSORS[RX_BUFFER[0]].SENSOR_PASSWORD[1];
     906:	a0 81       	ld	r26, Z
     908:	8a 9f       	mul	r24, r26
     90a:	d0 01       	movw	r26, r0
     90c:	11 24       	eor	r1, r1
     90e:	ad 5e       	subi	r26, 0xED	; 237
     910:	b2 4f       	sbci	r27, 0xF2	; 242
     912:	17 96       	adiw	r26, 0x07	; 7
     914:	9c 91       	ld	r25, X
     916:	90 93 63 0c 	sts	0x0C63, r25
		TX_BUFFER[8]=MY_SENSORS[RX_BUFFER[0]].SENSOR_PASSWORD[2];
     91a:	a0 81       	ld	r26, Z
     91c:	8a 9f       	mul	r24, r26
     91e:	d0 01       	movw	r26, r0
     920:	11 24       	eor	r1, r1
     922:	ad 5e       	subi	r26, 0xED	; 237
     924:	b2 4f       	sbci	r27, 0xF2	; 242
     926:	18 96       	adiw	r26, 0x08	; 8
     928:	9c 91       	ld	r25, X
     92a:	90 93 64 0c 	sts	0x0C64, r25
		TX_BUFFER[9]=MY_SENSORS[RX_BUFFER[0]].SENSOR_PASSWORD[3];
     92e:	a0 81       	ld	r26, Z
     930:	8a 9f       	mul	r24, r26
     932:	d0 01       	movw	r26, r0
     934:	11 24       	eor	r1, r1
     936:	ad 5e       	subi	r26, 0xED	; 237
     938:	b2 4f       	sbci	r27, 0xF2	; 242
     93a:	19 96       	adiw	r26, 0x09	; 9
     93c:	9c 91       	ld	r25, X
     93e:	90 93 65 0c 	sts	0x0C65, r25
		TX_BUFFER[10]=MY_SENSORS[RX_BUFFER[0]].SENSOR_VERSION;
     942:	a0 81       	ld	r26, Z
     944:	8a 9f       	mul	r24, r26
     946:	d0 01       	movw	r26, r0
     948:	11 24       	eor	r1, r1
     94a:	ad 5e       	subi	r26, 0xED	; 237
     94c:	b2 4f       	sbci	r27, 0xF2	; 242
     94e:	1a 96       	adiw	r26, 0x0a	; 10
     950:	9c 91       	ld	r25, X
     952:	90 93 66 0c 	sts	0x0C66, r25
		TX_BUFFER[11]=MY_SENSORS[RX_BUFFER[0]].SENSOR_TYPE;
     956:	a0 81       	ld	r26, Z
     958:	8a 9f       	mul	r24, r26
     95a:	d0 01       	movw	r26, r0
     95c:	11 24       	eor	r1, r1
     95e:	ad 5e       	subi	r26, 0xED	; 237
     960:	b2 4f       	sbci	r27, 0xF2	; 242
     962:	1b 96       	adiw	r26, 0x0b	; 11
     964:	9c 91       	ld	r25, X
     966:	90 93 67 0c 	sts	0x0C67, r25
		TX_BUFFER[12]=MY_SENSORS[RX_BUFFER[0]].SENSOR_STATE;
     96a:	e0 81       	ld	r30, Z
     96c:	8e 9f       	mul	r24, r30
     96e:	f0 01       	movw	r30, r0
     970:	11 24       	eor	r1, r1
     972:	ed 5e       	subi	r30, 0xED	; 237
     974:	f2 4f       	sbci	r31, 0xF2	; 242
     976:	84 85       	ldd	r24, Z+12	; 0x0c
     978:	80 93 68 0c 	sts	0x0C68, r24
		
		
		COUNER_TX_BUFFER=1;
     97c:	81 e0       	ldi	r24, 0x01	; 1
     97e:	80 93 97 04 	sts	0x0497, r24
		TX_BUFFER_SIZE=13;
     982:	8d e0       	ldi	r24, 0x0D	; 13
     984:	80 93 96 04 	sts	0x0496, r24
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     988:	10 92 98 04 	sts	0x0498, r1
		UDR0=ACK_COMMAND;
     98c:	8a ea       	ldi	r24, 0xAA	; 170
     98e:	8c b9       	out	0x0c, r24	; 12
     990:	08 95       	ret
	}
	else
	{
		COUNER_TX_BUFFER=0;
     992:	10 92 97 04 	sts	0x0497, r1
		TX_BUFFER_SIZE=0;
     996:	10 92 96 04 	sts	0x0496, r1
		UDR0=ACK_COMMAND;
     99a:	8a ea       	ldi	r24, 0xAA	; 170
     99c:	8c b9       	out	0x0c, r24	; 12
     99e:	08 95       	ret

000009a0 <RX0_ISR>:
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
	}
}

void RX0_ISR()
{
     9a0:	cf 92       	push	r12
     9a2:	ef 92       	push	r14
     9a4:	0f 93       	push	r16
	if (isbitset(*CHECK_CONNECTED_IN_ADDRESS,CHECK_CONNECTED_PIN))
     9a6:	0a 9b       	sbis	0x01, 2	; 1
     9a8:	45 c0       	rjmp	.+138    	; 0xa34 <RX0_ISR+0x94>
	{
			if (TIMER2_WORKING_FLAG==0)
     9aa:	80 91 92 04 	lds	r24, 0x0492
     9ae:	81 11       	cpse	r24, r1
     9b0:	0d c0       	rjmp	.+26     	; 0x9cc <RX0_ISR+0x2c>
			{
				TIMER2_WORKING_FLAG=1;
     9b2:	81 e0       	ldi	r24, 0x01	; 1
     9b4:	80 93 92 04 	sts	0x0492, r24
				TIMER2_ENABLE(T2_NORMAL,T2_OC2_DISCONNECT,T2_TIMER_1024,0,DISABLE_TIMER2_INT,ENABLE_TIMER2_INT,0);
     9b8:	c1 2c       	mov	r12, r1
     9ba:	ee 24       	eor	r14, r14
     9bc:	e3 94       	inc	r14
     9be:	00 e0       	ldi	r16, 0x00	; 0
     9c0:	20 e0       	ldi	r18, 0x00	; 0
     9c2:	45 e0       	ldi	r20, 0x05	; 5
     9c4:	60 e0       	ldi	r22, 0x00	; 0
     9c6:	80 e0       	ldi	r24, 0x00	; 0
     9c8:	0e 94 2b 1d 	call	0x3a56	; 0x3a56 <TIMER2_ENABLE>
			}
			TIMER2_COUNTER=0;
     9cc:	10 92 93 04 	sts	0x0493, r1
			/*THIS PART IS TO RESTART TIMER FOR IDILING THE STATE OF RX WHEN PASSED 1.22 SEC*/
		switch(BLUETOOTH_STATE)
     9d0:	80 91 98 04 	lds	r24, 0x0498
     9d4:	90 e0       	ldi	r25, 0x00	; 0
     9d6:	8d 30       	cpi	r24, 0x0D	; 13
     9d8:	91 05       	cpc	r25, r1
     9da:	70 f5       	brcc	.+92     	; 0xa38 <RX0_ISR+0x98>
     9dc:	fc 01       	movw	r30, r24
     9de:	eb 5a       	subi	r30, 0xAB	; 171
     9e0:	ff 4f       	sbci	r31, 0xFF	; 255
     9e2:	0c 94 2c 42 	jmp	0x8458	; 0x8458 <__tablejump2__>
		{
			case BLUETOOTH_IDLE:BLUETOOTH_IDLE_RX(UDR0);
     9e6:	8c b1       	in	r24, 0x0c	; 12
     9e8:	bd dc       	rcall	.-1670   	; 0x364 <BLUETOOTH_IDLE_RX>
			break;
     9ea:	26 c0       	rjmp	.+76     	; 0xa38 <RX0_ISR+0x98>
			
			
			case BLUETOOTH_RESET_ALL:BLUETOOTH_RESET_ALL_SURE(UDR0);
     9ec:	8c b1       	in	r24, 0x0c	; 12
     9ee:	e2 dc       	rcall	.-1596   	; 0x3b4 <BLUETOOTH_RESET_ALL_SURE>
			break;
     9f0:	23 c0       	rjmp	.+70     	; 0xa38 <RX0_ISR+0x98>
			
			case BLUETOOTH_DELETE_ALL_SESNORS:BLUETOOTH_RECIVING_RESET_SURE(UDR0);
     9f2:	8c b1       	in	r24, 0x0c	; 12
     9f4:	f0 dc       	rcall	.-1568   	; 0x3d6 <BLUETOOTH_RECIVING_RESET_SURE>
			break;
     9f6:	20 c0       	rjmp	.+64     	; 0xa38 <RX0_ISR+0x98>
			
			case BLUETOOTH_RECIVING_USER_PASS:BLUETOOTH_RECIVING_USER_PASS_RX(UDR0);
     9f8:	8c b1       	in	r24, 0x0c	; 12
     9fa:	fe dc       	rcall	.-1540   	; 0x3f8 <BLUETOOTH_RECIVING_USER_PASS_RX>
			break;
     9fc:	1d c0       	rjmp	.+58     	; 0xa38 <RX0_ISR+0x98>
			case BLUETOOTH_RECIVING_IOT_PAR:BLUETOOTH_RECIVING_IOT_PAR_RX(UDR0);
     9fe:	8c b1       	in	r24, 0x0c	; 12
     a00:	48 dd       	rcall	.-1392   	; 0x492 <BLUETOOTH_RECIVING_IOT_PAR_RX>
			break;
     a02:	1a c0       	rjmp	.+52     	; 0xa38 <RX0_ISR+0x98>
			case BLUETOOTH_RECIVING_ADD_SENSOR:BLUETOOTH_RECIVING_ADD_SENSOR_RX(UDR0);
     a04:	8c b1       	in	r24, 0x0c	; 12
     a06:	9e dd       	rcall	.-1220   	; 0x544 <BLUETOOTH_RECIVING_ADD_SENSOR_RX>
			break;
     a08:	17 c0       	rjmp	.+46     	; 0xa38 <RX0_ISR+0x98>
			case BLUETOOTH_RECIVING_ENABLE_SENSOR:BLUETOOTH_RECIVING_ENABLE_SENSOR_RX(UDR0);
     a0a:	8c b1       	in	r24, 0x0c	; 12
     a0c:	e4 dd       	rcall	.-1080   	; 0x5d6 <BLUETOOTH_RECIVING_ENABLE_SENSOR_RX>
			break;
     a0e:	14 c0       	rjmp	.+40     	; 0xa38 <RX0_ISR+0x98>
			case BLUETOOTH_RECIVING_DISABLE_SENSOR:BLUETOOTH_RECIVING_DISABLE_SENSOR_RX(UDR0);
     a10:	8c b1       	in	r24, 0x0c	; 12
     a12:	12 de       	rcall	.-988    	; 0x638 <BLUETOOTH_RECIVING_DISABLE_SENSOR_RX>
			break;
     a14:	11 c0       	rjmp	.+34     	; 0xa38 <RX0_ISR+0x98>
			case BLUETOOTH_RECIVING_DELETE_SENSOR:BLUETOOTH_RECIVING_DELETE_SENSOR_RX(UDR0);
     a16:	8c b1       	in	r24, 0x0c	; 12
     a18:	40 de       	rcall	.-896    	; 0x69a <BLUETOOTH_RECIVING_DELETE_SENSOR_RX>
			break;
     a1a:	0e c0       	rjmp	.+28     	; 0xa38 <RX0_ISR+0x98>
			case BLUETOOTH_RECIVING_ADJUST_LED:BLUETOOTH_RECIVING_ADJUST_LED_RX(UDR0);
     a1c:	8c b1       	in	r24, 0x0c	; 12
     a1e:	6e de       	rcall	.-804    	; 0x6fc <BLUETOOTH_RECIVING_ADJUST_LED_RX>
			break;
     a20:	0b c0       	rjmp	.+22     	; 0xa38 <RX0_ISR+0x98>
			
			
			
			
			/*READING PREPARE THE RECIVED DATA*/
			case BLUETOOTH_READING_STATE_SENSOR:BLUETOOTH_READING_STATE_SENSOR_RX(UDR0);
     a22:	8c b1       	in	r24, 0x0c	; 12
     a24:	a8 de       	rcall	.-688    	; 0x776 <BLUETOOTH_READING_STATE_SENSOR_RX>
			break;
     a26:	08 c0       	rjmp	.+16     	; 0xa38 <RX0_ISR+0x98>
			
			case BLUETOOTH_READING_CONNECT_SENSOR:BLUETOOTH_READING_CONNECTED_SENSOR_RX(UDR0);
     a28:	8c b1       	in	r24, 0x0c	; 12
     a2a:	e1 de       	rcall	.-574    	; 0x7ee <BLUETOOTH_READING_CONNECTED_SENSOR_RX>
			break; 
     a2c:	05 c0       	rjmp	.+10     	; 0xa38 <RX0_ISR+0x98>
			
			case BLUETOOTH_READING_SENSOR_INFO:BLUETOOTH_READING_SENSOR_INFO_RX(UDR0);
     a2e:	8c b1       	in	r24, 0x0c	; 12
     a30:	1a df       	rcall	.-460    	; 0x866 <BLUETOOTH_READING_SENSOR_INFO_RX>
			break;
     a32:	02 c0       	rjmp	.+4      	; 0xa38 <RX0_ISR+0x98>
		}
			
	}
	else
	{
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     a34:	10 92 98 04 	sts	0x0498, r1
	}
}
     a38:	0f 91       	pop	r16
     a3a:	ef 90       	pop	r14
     a3c:	cf 90       	pop	r12
     a3e:	08 95       	ret

00000a40 <BLUETOOTH_IO_SETUP>:



void BLUETOOTH_IO_SETUP()
{
	gpio_inputconfg(CHECK_CONNECTED_DDR_ADDRESS,CHECK_CONNECTED_INMOD_ADDRESS,FLOAT_mod,CHECK_CONNECTED_PIN);
     a40:	22 e0       	ldi	r18, 0x02	; 2
     a42:	40 e0       	ldi	r20, 0x00	; 0
     a44:	63 e2       	ldi	r22, 0x23	; 35
     a46:	70 e0       	ldi	r23, 0x00	; 0
     a48:	82 e2       	ldi	r24, 0x22	; 34
     a4a:	90 e0       	ldi	r25, 0x00	; 0
     a4c:	2e d3       	rcall	.+1628   	; 0x10aa <gpio_inputconfg>
	gpio_outputconfg(FEED_BACK_DDR_ADDRESS,FEED_BACK_OUTMOD_ADDRESS,OUTPASS,FEED_BACK_PIN);
     a4e:	23 e0       	ldi	r18, 0x03	; 3
     a50:	40 e0       	ldi	r20, 0x00	; 0
     a52:	61 e2       	ldi	r22, 0x21	; 33
     a54:	70 e0       	ldi	r23, 0x00	; 0
     a56:	82 e2       	ldi	r24, 0x22	; 34
     a58:	90 e0       	ldi	r25, 0x00	; 0
     a5a:	44 c3       	rjmp	.+1672   	; 0x10e4 <gpio_outputconfg>
     a5c:	08 95       	ret

00000a5e <BLUETOOTH_LOOP>:
}

void BLUETOOTH_LOOP()
{
	
	if (isbitset(*CHECK_CONNECTED_IN_ADDRESS,CHECK_CONNECTED_PIN))
     a5e:	0a 9b       	sbis	0x01, 2	; 1
     a60:	02 c0       	rjmp	.+4      	; 0xa66 <BLUETOOTH_LOOP+0x8>
	{
		setbit(*FEED_BACK_OUT_ADDRESS,FEED_BACK_PIN);
     a62:	1b 9a       	sbi	0x03, 3	; 3
     a64:	08 95       	ret
	}
	else
	{
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     a66:	10 92 98 04 	sts	0x0498, r1
		clearbit(*FEED_BACK_OUT_ADDRESS,FEED_BACK_PIN);
     a6a:	1b 98       	cbi	0x03, 3	; 3
     a6c:	08 95       	ret

00000a6e <TIMER2_ISR>:

}

void TIMER2_ISR()
{
	TIMER2_COUNTER++;
     a6e:	80 91 93 04 	lds	r24, 0x0493
     a72:	8f 5f       	subi	r24, 0xFF	; 255
     a74:	80 93 93 04 	sts	0x0493, r24
	if (TIMER2_COUNTER==30)
     a78:	80 91 93 04 	lds	r24, 0x0493
     a7c:	8e 31       	cpi	r24, 0x1E	; 30
     a7e:	41 f4       	brne	.+16     	; 0xa90 <TIMER2_ISR+0x22>
	{
		TIMER2_DISABLE();
     a80:	0e 94 28 1d 	call	0x3a50	; 0x3a50 <TIMER2_DISABLE>
		TIMER2_COUNTER=0;
     a84:	10 92 93 04 	sts	0x0493, r1
		TIMER2_WORKING_FLAG=0;
     a88:	10 92 92 04 	sts	0x0492, r1
		BLUETOOTH_STATE=BLUETOOTH_IDLE;
     a8c:	10 92 98 04 	sts	0x0498, r1
     a90:	08 95       	ret

00000a92 <QUEUE_INTILIZE_ARRAY_U8>:
		
		
		return MY_QUEUE->THE_QUEUE[MY_QUEUE->REAR];
	}
	return 0;
}
     a92:	fc 01       	movw	r30, r24
     a94:	12 82       	std	Z+2, r1	; 0x02
     a96:	10 82       	st	Z, r1
     a98:	87 e0       	ldi	r24, 0x07	; 7
     a9a:	81 83       	std	Z+1, r24	; 0x01
     a9c:	08 95       	ret

00000a9e <QUEUE_ADD_ARRAY_U8>:
     a9e:	dc 01       	movw	r26, r24
     aa0:	12 96       	adiw	r26, 0x02	; 2
     aa2:	8c 91       	ld	r24, X
     aa4:	12 97       	sbiw	r26, 0x02	; 2
     aa6:	88 30       	cpi	r24, 0x08	; 8
     aa8:	29 f1       	breq	.+74     	; 0xaf4 <QUEUE_ADD_ARRAY_U8+0x56>
     aaa:	8f 5f       	subi	r24, 0xFF	; 255
     aac:	12 96       	adiw	r26, 0x02	; 2
     aae:	8c 93       	st	X, r24
     ab0:	12 97       	sbiw	r26, 0x02	; 2
     ab2:	11 96       	adiw	r26, 0x01	; 1
     ab4:	8c 91       	ld	r24, X
     ab6:	11 97       	sbiw	r26, 0x01	; 1
     ab8:	90 e0       	ldi	r25, 0x00	; 0
     aba:	01 96       	adiw	r24, 0x01	; 1
     abc:	87 70       	andi	r24, 0x07	; 7
     abe:	90 78       	andi	r25, 0x80	; 128
     ac0:	11 96       	adiw	r26, 0x01	; 1
     ac2:	8c 93       	st	X, r24
     ac4:	11 97       	sbiw	r26, 0x01	; 1
     ac6:	44 23       	and	r20, r20
     ac8:	a9 f0       	breq	.+42     	; 0xaf4 <QUEUE_ADD_ARRAY_U8+0x56>
     aca:	e6 2f       	mov	r30, r22
     acc:	f7 2f       	mov	r31, r23
     ace:	20 e0       	ldi	r18, 0x00	; 0
     ad0:	30 e0       	ldi	r19, 0x00	; 0
     ad2:	bd 01       	movw	r22, r26
     ad4:	58 e2       	ldi	r21, 0x28	; 40
     ad6:	85 9f       	mul	r24, r21
     ad8:	60 0d       	add	r22, r0
     ada:	71 1d       	adc	r23, r1
     adc:	11 24       	eor	r1, r1
     ade:	cb 01       	movw	r24, r22
     ae0:	51 91       	ld	r21, Z+
     ae2:	dc 01       	movw	r26, r24
     ae4:	a2 0f       	add	r26, r18
     ae6:	b3 1f       	adc	r27, r19
     ae8:	13 96       	adiw	r26, 0x03	; 3
     aea:	5c 93       	st	X, r21
     aec:	2f 5f       	subi	r18, 0xFF	; 255
     aee:	3f 4f       	sbci	r19, 0xFF	; 255
     af0:	24 17       	cp	r18, r20
     af2:	b0 f3       	brcs	.-20     	; 0xae0 <QUEUE_ADD_ARRAY_U8+0x42>
     af4:	08 95       	ret

00000af6 <QUEUE_GET_FRONT_ARRAY_U8>:
     af6:	fc 01       	movw	r30, r24
     af8:	22 81       	ldd	r18, Z+2	; 0x02
     afa:	22 23       	and	r18, r18
     afc:	41 f0       	breq	.+16     	; 0xb0e <QUEUE_GET_FRONT_ARRAY_U8+0x18>
     afe:	20 81       	ld	r18, Z
     b00:	f8 e2       	ldi	r31, 0x28	; 40
     b02:	2f 9f       	mul	r18, r31
     b04:	80 0d       	add	r24, r0
     b06:	91 1d       	adc	r25, r1
     b08:	11 24       	eor	r1, r1
     b0a:	03 96       	adiw	r24, 0x03	; 3
     b0c:	08 95       	ret
     b0e:	80 e0       	ldi	r24, 0x00	; 0
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	08 95       	ret

00000b14 <QUEUE_DELETE_FRONT_ARRAY_U8>:

void QUEUE_DELETE_FRONT_ARRAY_U8(QUEUE_ARRAY_UINT8*MY_QUEUE)
{
     b14:	fc 01       	movw	r30, r24
	if (MY_QUEUE->COUNT!=0)
     b16:	22 81       	ldd	r18, Z+2	; 0x02
     b18:	22 23       	and	r18, r18
     b1a:	41 f0       	breq	.+16     	; 0xb2c <QUEUE_DELETE_FRONT_ARRAY_U8+0x18>
	{
		MY_QUEUE->FRONT=(MY_QUEUE->FRONT+1)%max_Queue;
     b1c:	80 81       	ld	r24, Z
     b1e:	90 e0       	ldi	r25, 0x00	; 0
     b20:	01 96       	adiw	r24, 0x01	; 1
     b22:	87 70       	andi	r24, 0x07	; 7
     b24:	90 78       	andi	r25, 0x80	; 128
     b26:	80 83       	st	Z, r24
		(MY_QUEUE->COUNT)--;
     b28:	21 50       	subi	r18, 0x01	; 1
     b2a:	22 83       	std	Z+2, r18	; 0x02
     b2c:	08 95       	ret

00000b2e <LED_GRID_IO_SETUP>:
volatile unsigned char F_B_NEW_LED_GRID=0;


void LED_GRID_IO_SETUP()
{
	*PORT_DDR_LED_GRID=0XFF;
     b2e:	8f ef       	ldi	r24, 0xFF	; 255
     b30:	80 93 61 00 	sts	0x0061, r24
	*PORT_OUTMOD_LED_GRID=0X00;
     b34:	10 b8       	out	0x00, r1	; 0
	*PORT_OUT_LED_GRID=0X00;
     b36:	10 92 62 00 	sts	0x0062, r1
	gpio_outputconfg(PORT_DDR_LED_GRID_CONTROL,PORT_OUTMOD_LED_GRID_CONTROL,OUTPASS,0);
     b3a:	20 e0       	ldi	r18, 0x00	; 0
     b3c:	40 e0       	ldi	r20, 0x00	; 0
     b3e:	69 e3       	ldi	r22, 0x39	; 57
     b40:	70 e0       	ldi	r23, 0x00	; 0
     b42:	8a e3       	ldi	r24, 0x3A	; 58
     b44:	90 e0       	ldi	r25, 0x00	; 0
     b46:	ce d2       	rcall	.+1436   	; 0x10e4 <gpio_outputconfg>
	gpio_outputconfg(PORT_DDR_LED_GRID_CONTROL,PORT_OUTMOD_LED_GRID_CONTROL,OUTPASS,1);
     b48:	21 e0       	ldi	r18, 0x01	; 1
     b4a:	40 e0       	ldi	r20, 0x00	; 0
     b4c:	69 e3       	ldi	r22, 0x39	; 57
     b4e:	70 e0       	ldi	r23, 0x00	; 0
     b50:	8a e3       	ldi	r24, 0x3A	; 58
     b52:	90 e0       	ldi	r25, 0x00	; 0
     b54:	c7 d2       	rcall	.+1422   	; 0x10e4 <gpio_outputconfg>
	gpio_outputconfg(PORT_DDR_LED_GRID_CONTROL,PORT_OUTMOD_LED_GRID_CONTROL,OUTPASS,2);
     b56:	22 e0       	ldi	r18, 0x02	; 2
     b58:	40 e0       	ldi	r20, 0x00	; 0
     b5a:	69 e3       	ldi	r22, 0x39	; 57
     b5c:	70 e0       	ldi	r23, 0x00	; 0
     b5e:	8a e3       	ldi	r24, 0x3A	; 58
     b60:	90 e0       	ldi	r25, 0x00	; 0
     b62:	c0 c2       	rjmp	.+1408   	; 0x10e4 <gpio_outputconfg>
     b64:	08 95       	ret

00000b66 <LED_GRID_LOAD>:
{
	LED_GRID_LOAD();
}

void LED_GRID_LOAD()
{
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
	if (readeeprom(MY_EEPROM_LED_GRID_FIRST_USE)==LED_GRID_FIRST_USE_VALUE)
     b6a:	84 ef       	ldi	r24, 0xF4	; 244
     b6c:	91 e0       	ldi	r25, 0x01	; 1
     b6e:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
     b72:	84 34       	cpi	r24, 0x44	; 68
     b74:	81 f4       	brne	.+32     	; 0xb96 <LED_GRID_LOAD+0x30>
     b76:	c0 e0       	ldi	r28, 0x00	; 0
     b78:	d0 e0       	ldi	r29, 0x00	; 0
	{
		unsigned char i=0;
		for (i=0;i<LED_GRID_SIZE;i++)
		{
			LED_GRID_ARRAY[i]=readeeprom(MY_EEPROM_FIRST_LED_GRID+i);
     b7a:	ce 01       	movw	r24, r28
     b7c:	8b 50       	subi	r24, 0x0B	; 11
     b7e:	9e 4f       	sbci	r25, 0xFE	; 254
     b80:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
     b84:	fe 01       	movw	r30, r28
     b86:	e0 50       	subi	r30, 0x00	; 0
     b88:	ff 4f       	sbci	r31, 0xFF	; 255
     b8a:	80 83       	st	Z, r24
     b8c:	21 96       	adiw	r28, 0x01	; 1
void LED_GRID_LOAD()
{
	if (readeeprom(MY_EEPROM_LED_GRID_FIRST_USE)==LED_GRID_FIRST_USE_VALUE)
	{
		unsigned char i=0;
		for (i=0;i<LED_GRID_SIZE;i++)
     b8e:	c8 30       	cpi	r28, 0x08	; 8
     b90:	d1 05       	cpc	r29, r1
     b92:	99 f7       	brne	.-26     	; 0xb7a <LED_GRID_LOAD+0x14>
     b94:	14 c0       	rjmp	.+40     	; 0xbbe <LED_GRID_LOAD+0x58>
	LED_GRID_LOAD();
}

void LED_GRID_LOAD()
{
	if (readeeprom(MY_EEPROM_LED_GRID_FIRST_USE)==LED_GRID_FIRST_USE_VALUE)
     b96:	c0 e0       	ldi	r28, 0x00	; 0
     b98:	d0 e0       	ldi	r29, 0x00	; 0
	{
		unsigned char i=0;
		/*set the sensor array to zeros*/
		for (i=0;i<LED_GRID_SIZE;++i)
		{
			writeeeprom(MY_EEPROM_FIRST_LED_GRID+i,LED_GRID_ARRAY[i]);
     b9a:	fe 01       	movw	r30, r28
     b9c:	e0 50       	subi	r30, 0x00	; 0
     b9e:	ff 4f       	sbci	r31, 0xFF	; 255
     ba0:	60 81       	ld	r22, Z
     ba2:	ce 01       	movw	r24, r28
     ba4:	8b 50       	subi	r24, 0x0B	; 11
     ba6:	9e 4f       	sbci	r25, 0xFE	; 254
     ba8:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
     bac:	21 96       	adiw	r28, 0x01	; 1
	}
	else
	{
		unsigned char i=0;
		/*set the sensor array to zeros*/
		for (i=0;i<LED_GRID_SIZE;++i)
     bae:	c8 30       	cpi	r28, 0x08	; 8
     bb0:	d1 05       	cpc	r29, r1
     bb2:	99 f7       	brne	.-26     	; 0xb9a <LED_GRID_LOAD+0x34>
		{
			writeeeprom(MY_EEPROM_FIRST_LED_GRID+i,LED_GRID_ARRAY[i]);
		}
		/*set the value of checkfirst use to its value*/
		writeeeprom(MY_EEPROM_LED_GRID_FIRST_USE,LED_GRID_FIRST_USE_VALUE);
     bb4:	64 e4       	ldi	r22, 0x44	; 68
     bb6:	84 ef       	ldi	r24, 0xF4	; 244
     bb8:	91 e0       	ldi	r25, 0x01	; 1
     bba:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
	}
}
     bbe:	df 91       	pop	r29
     bc0:	cf 91       	pop	r28
     bc2:	08 95       	ret

00000bc4 <LED_GRID_SETUP>:
	
}

void LED_GRID_SETUP()
{
	LED_GRID_LOAD();
     bc4:	d0 cf       	rjmp	.-96     	; 0xb66 <LED_GRID_LOAD>
     bc6:	08 95       	ret

00000bc8 <LOOP_LED_GRID>:
		writeeeprom(MY_EEPROM_LED_GRID_FIRST_USE,LED_GRID_FIRST_USE_VALUE);
	}
}

 void  LOOP_LED_GRID()
{
     bc8:	cf 93       	push	r28
     bca:	df 93       	push	r29
	if(F_B_NEW_LED_GRID)
     bcc:	80 91 99 04 	lds	r24, 0x0499
     bd0:	88 23       	and	r24, r24
     bd2:	89 f0       	breq	.+34     	; 0xbf6 <LOOP_LED_GRID+0x2e>
	{
		F_B_NEW_LED_GRID=0;
     bd4:	10 92 99 04 	sts	0x0499, r1
     bd8:	c0 e0       	ldi	r28, 0x00	; 0
     bda:	d0 e0       	ldi	r29, 0x00	; 0
		unsigned char i=0;
		for (i=0;i<LED_GRID_SIZE;++i)
		{
			writeeeprom(MY_EEPROM_FIRST_LED_GRID+i,LED_GRID_ARRAY[i]);
     bdc:	fe 01       	movw	r30, r28
     bde:	e0 50       	subi	r30, 0x00	; 0
     be0:	ff 4f       	sbci	r31, 0xFF	; 255
     be2:	60 81       	ld	r22, Z
     be4:	ce 01       	movw	r24, r28
     be6:	8b 50       	subi	r24, 0x0B	; 11
     be8:	9e 4f       	sbci	r25, 0xFE	; 254
     bea:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
     bee:	21 96       	adiw	r28, 0x01	; 1
{
	if(F_B_NEW_LED_GRID)
	{
		F_B_NEW_LED_GRID=0;
		unsigned char i=0;
		for (i=0;i<LED_GRID_SIZE;++i)
     bf0:	c8 30       	cpi	r28, 0x08	; 8
     bf2:	d1 05       	cpc	r29, r1
     bf4:	99 f7       	brne	.-26     	; 0xbdc <LOOP_LED_GRID+0x14>
		{
			writeeeprom(MY_EEPROM_FIRST_LED_GRID+i,LED_GRID_ARRAY[i]);
		}
	}
	
}
     bf6:	df 91       	pop	r29
     bf8:	cf 91       	pop	r28
     bfa:	08 95       	ret

00000bfc <LED_GRID_TIMER_INT>:

void LED_GRID_TIMER_INT()
{
	
	
	LED_GRID_COUNTER=(LED_GRID_COUNTER+1)%LED_GRID_SIZE;
     bfc:	80 91 9a 04 	lds	r24, 0x049A
     c00:	90 e0       	ldi	r25, 0x00	; 0
     c02:	01 96       	adiw	r24, 0x01	; 1
     c04:	87 70       	andi	r24, 0x07	; 7
     c06:	90 78       	andi	r25, 0x80	; 128
     c08:	80 93 9a 04 	sts	0x049A, r24
	*PORT_OUT_LED_GRID=LED_GRID_ARRAY[LED_GRID_COUNTER];
     c0c:	e0 91 9a 04 	lds	r30, 0x049A
     c10:	f0 e0       	ldi	r31, 0x00	; 0
     c12:	e0 50       	subi	r30, 0x00	; 0
     c14:	ff 4f       	sbci	r31, 0xFF	; 255
     c16:	80 81       	ld	r24, Z
     c18:	80 93 62 00 	sts	0x0062, r24
	*PORT_OUT_LED_GRID_CONTROL=(((*PORT_OUT_LED_GRID_CONTROL)&0B11111000)|LED_GRID_COUNTER);
     c1c:	8b b3       	in	r24, 0x1b	; 27
     c1e:	90 91 9a 04 	lds	r25, 0x049A
     c22:	88 7f       	andi	r24, 0xF8	; 248
     c24:	89 2b       	or	r24, r25
     c26:	8b bb       	out	0x1b, r24	; 27
     c28:	08 95       	ret

00000c2a <LOOP>:

void LOOP(void *pd)
{
	while (1)
	{
		LOOP_LED_GRID();
     c2a:	ce df       	rcall	.-100    	; 0xbc8 <LOOP_LED_GRID>
		BLUETOOTH_LOOP();
     c2c:	18 df       	rcall	.-464    	; 0xa5e <BLUETOOTH_LOOP>
		vTaskDelay(100);
     c2e:	64 e6       	ldi	r22, 0x64	; 100
     c30:	70 e0       	ldi	r23, 0x00	; 0
     c32:	80 e0       	ldi	r24, 0x00	; 0
     c34:	90 e0       	ldi	r25, 0x00	; 0
     c36:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
     c3a:	f7 cf       	rjmp	.-18     	; 0xc2a <LOOP>

00000c3c <OTHER_SETUPS_IO>:
	}
}

void OTHER_SETUPS_IO()
{
	gpio_outputconfg(PORT_DDR_READY_LED,PORT_OUTMOD_READY_LED,OUTPASS,READY_LED_PIN);
     c3c:	20 e0       	ldi	r18, 0x00	; 0
     c3e:	40 e0       	ldi	r20, 0x00	; 0
     c40:	63 e6       	ldi	r22, 0x63	; 99
     c42:	70 e0       	ldi	r23, 0x00	; 0
     c44:	84 e6       	ldi	r24, 0x64	; 100
     c46:	90 e0       	ldi	r25, 0x00	; 0
     c48:	4d d2       	rcall	.+1178   	; 0x10e4 <gpio_outputconfg>
	gpio_outputconfg(PORT_DDR_TOGGLE_LED,PORT_OUTMOD_TOGGLE_LED,OUTPASS,TOGGLE_LED_PIN);
     c4a:	25 e0       	ldi	r18, 0x05	; 5
     c4c:	40 e0       	ldi	r20, 0x00	; 0
     c4e:	61 e2       	ldi	r22, 0x21	; 33
     c50:	70 e0       	ldi	r23, 0x00	; 0
     c52:	82 e2       	ldi	r24, 0x22	; 34
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	46 c2       	rjmp	.+1164   	; 0x10e4 <gpio_outputconfg>
     c58:	08 95       	ret

00000c5a <SETUP>:


xTaskHandle loop_handle;

void SETUP()
{
     c5a:	8f 92       	push	r8
     c5c:	9f 92       	push	r9
     c5e:	af 92       	push	r10
     c60:	bf 92       	push	r11
     c62:	cf 92       	push	r12
     c64:	df 92       	push	r13
     c66:	ef 92       	push	r14
     c68:	ff 92       	push	r15
     c6a:	0f 93       	push	r16
	
	SPI_INT(SPI_MASTER,SPI_SCALE_16,SPI_MODE_0,SPI_INT_DISABLE,SPI_MSF);
     c6c:	00 e0       	ldi	r16, 0x00	; 0
     c6e:	20 e0       	ldi	r18, 0x00	; 0
     c70:	40 e0       	ldi	r20, 0x00	; 0
     c72:	61 e0       	ldi	r22, 0x01	; 1
     c74:	70 e0       	ldi	r23, 0x00	; 0
     c76:	80 e1       	ldi	r24, 0x10	; 16
     c78:	0e 94 d5 1c 	call	0x39aa	; 0x39aa <SPI_INT>
	BLUETOOTH_IO_SETUP();
     c7c:	e1 de       	rcall	.-574    	; 0xa40 <BLUETOOTH_IO_SETUP>
	LED_GRID_IO_SETUP();
     c7e:	57 df       	rcall	.-338    	; 0xb2e <LED_GRID_IO_SETUP>
	PROTOCOL_IO_SETUP();
     c80:	0e 94 06 20 	call	0x400c	; 0x400c <PROTOCOL_IO_SETUP>
	SENSORS_IO_SETUP();
     c84:	0e 94 e6 34 	call	0x69cc	; 0x69cc <SENSORS_IO_SETUP>
	WIFI_SETUP_IO();
     c88:	0e 94 7c 3d 	call	0x7af8	; 0x7af8 <WIFI_SETUP_IO>
	OTHER_SETUPS_IO();
     c8c:	d7 df       	rcall	.-82     	; 0xc3c <OTHER_SETUPS_IO>
	TEST_IO_SETUP();
     c8e:	0e 94 9e 3b 	call	0x773c	; 0x773c <TEST_IO_SETUP>
	
	
	/*BLUETOOTH_SETUP();*/
	
	/*TESTING*/
	USART0_INIT(ASYNCHRONOUS_DOUBLE,UART_INT_DISABLE,UART_INT_DISABLE,UART_INT_DISABLE,TX_RX_ENABLE,PARITY_DISABLE_1STOP,DATA_8,500000U);
     c92:	0f 2e       	mov	r0, r31
     c94:	f0 e2       	ldi	r31, 0x20	; 32
     c96:	8f 2e       	mov	r8, r31
     c98:	f1 ea       	ldi	r31, 0xA1	; 161
     c9a:	9f 2e       	mov	r9, r31
     c9c:	f7 e0       	ldi	r31, 0x07	; 7
     c9e:	af 2e       	mov	r10, r31
     ca0:	b1 2c       	mov	r11, r1
     ca2:	f0 2d       	mov	r31, r0
     ca4:	0f 2e       	mov	r0, r31
     ca6:	f6 e0       	ldi	r31, 0x06	; 6
     ca8:	cf 2e       	mov	r12, r31
     caa:	d1 2c       	mov	r13, r1
     cac:	f0 2d       	mov	r31, r0
     cae:	e1 2c       	mov	r14, r1
     cb0:	08 e1       	ldi	r16, 0x18	; 24
     cb2:	20 e0       	ldi	r18, 0x00	; 0
     cb4:	40 e0       	ldi	r20, 0x00	; 0
     cb6:	60 e0       	ldi	r22, 0x00	; 0
     cb8:	80 e0       	ldi	r24, 0x00	; 0
     cba:	92 e0       	ldi	r25, 0x02	; 2
     cbc:	0e 94 24 1e 	call	0x3c48	; 0x3c48 <USART0_INIT>
	/*TESING*/
	
	
	TEST_UART_SEND_str("hello");
     cc0:	8c e1       	ldi	r24, 0x1C	; 28
     cc2:	91 e0       	ldi	r25, 0x01	; 1
     cc4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	
	/*WIFI*/
	USART1_INIT(ASYNCHRONOUS_NORMAL,UART_INT_ENABLE,UART_INT_ENABLE,UART_INT_DISABLE,TX_RX_ENABLE,PARITY_DISABLE_1STOP,DATA_8,UART1_BAUD_RATE);
     cc8:	0f 2e       	mov	r0, r31
     cca:	f0 e8       	ldi	r31, 0x80	; 128
     ccc:	8f 2e       	mov	r8, r31
     cce:	f5 e2       	ldi	r31, 0x25	; 37
     cd0:	9f 2e       	mov	r9, r31
     cd2:	a1 2c       	mov	r10, r1
     cd4:	b1 2c       	mov	r11, r1
     cd6:	f0 2d       	mov	r31, r0
     cd8:	20 e0       	ldi	r18, 0x00	; 0
     cda:	41 e0       	ldi	r20, 0x01	; 1
     cdc:	61 e0       	ldi	r22, 0x01	; 1
     cde:	80 e0       	ldi	r24, 0x00	; 0
     ce0:	90 e0       	ldi	r25, 0x00	; 0
     ce2:	0e 94 da 1e 	call	0x3db4	; 0x3db4 <USART1_INIT>
	/**************/
	TEST3_SET();
     ce6:	aa 9a       	sbi	0x15, 2	; 21
	LED_GRID_SETUP();
     ce8:	6d df       	rcall	.-294    	; 0xbc4 <LED_GRID_SETUP>
	TIMERS_SETUP();
     cea:	0e 94 45 3d 	call	0x7a8a	; 0x7a8a <TIMERS_SETUP>
	{
		toggybit(*PORT_OUT_TOGGLE_LED,TOGGLE_LED_PIN);
		_delay_ms(1000);
	}*/
	
	setbit(*PORT_OUT_READY_LED,READY_LED_PIN);
     cee:	e5 e6       	ldi	r30, 0x65	; 101
     cf0:	f0 e0       	ldi	r31, 0x00	; 0
     cf2:	80 81       	ld	r24, Z
     cf4:	81 60       	ori	r24, 0x01	; 1
     cf6:	80 83       	st	Z, r24
	
	TEST_UART_SEND_VALUE(xTaskCreate(LOOP,"W",80,NULL,1,&loop_handle)) ;
     cf8:	0f 2e       	mov	r0, r31
     cfa:	fc ea       	ldi	r31, 0xAC	; 172
     cfc:	ef 2e       	mov	r14, r31
     cfe:	fc e0       	ldi	r31, 0x0C	; 12
     d00:	ff 2e       	mov	r15, r31
     d02:	f0 2d       	mov	r31, r0
     d04:	01 e0       	ldi	r16, 0x01	; 1
     d06:	20 e0       	ldi	r18, 0x00	; 0
     d08:	30 e0       	ldi	r19, 0x00	; 0
     d0a:	40 e5       	ldi	r20, 0x50	; 80
     d0c:	50 e0       	ldi	r21, 0x00	; 0
     d0e:	62 e2       	ldi	r22, 0x22	; 34
     d10:	71 e0       	ldi	r23, 0x01	; 1
     d12:	85 e1       	ldi	r24, 0x15	; 21
     d14:	96 e0       	ldi	r25, 0x06	; 6
     d16:	0e 94 96 18 	call	0x312c	; 0x312c <xTaskCreate>
     d1a:	98 2f       	mov	r25, r24
     d1c:	99 0f       	add	r25, r25
     d1e:	99 0b       	sbc	r25, r25
     d20:	28 2f       	mov	r18, r24
     d22:	39 2f       	mov	r19, r25
     d24:	49 2f       	mov	r20, r25
     d26:	59 2f       	mov	r21, r25
     d28:	69 2f       	mov	r22, r25
     d2a:	79 2f       	mov	r23, r25
     d2c:	89 2f       	mov	r24, r25
     d2e:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
}
     d32:	0f 91       	pop	r16
     d34:	ff 90       	pop	r15
     d36:	ef 90       	pop	r14
     d38:	df 90       	pop	r13
     d3a:	cf 90       	pop	r12
     d3c:	bf 90       	pop	r11
     d3e:	af 90       	pop	r10
     d40:	9f 90       	pop	r9
     d42:	8f 90       	pop	r8
     d44:	08 95       	ret

00000d46 <__vector_1>:
/*testing rtos*/
volatile  char r;


ISR(INT0_vect)
{
     d46:	1f 92       	push	r1
     d48:	0f 92       	push	r0
     d4a:	0f b6       	in	r0, 0x3f	; 63
     d4c:	0f 92       	push	r0
     d4e:	11 24       	eor	r1, r1
     d50:	0b b6       	in	r0, 0x3b	; 59
     d52:	0f 92       	push	r0
     d54:	2f 93       	push	r18
     d56:	3f 93       	push	r19
     d58:	4f 93       	push	r20
     d5a:	5f 93       	push	r21
     d5c:	6f 93       	push	r22
     d5e:	7f 93       	push	r23
     d60:	8f 93       	push	r24
     d62:	9f 93       	push	r25
     d64:	af 93       	push	r26
     d66:	bf 93       	push	r27
     d68:	ef 93       	push	r30
     d6a:	ff 93       	push	r31
	INT0_NRF_ISR();
     d6c:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <INT0_NRF_ISR>
}
     d70:	ff 91       	pop	r31
     d72:	ef 91       	pop	r30
     d74:	bf 91       	pop	r27
     d76:	af 91       	pop	r26
     d78:	9f 91       	pop	r25
     d7a:	8f 91       	pop	r24
     d7c:	7f 91       	pop	r23
     d7e:	6f 91       	pop	r22
     d80:	5f 91       	pop	r21
     d82:	4f 91       	pop	r20
     d84:	3f 91       	pop	r19
     d86:	2f 91       	pop	r18
     d88:	0f 90       	pop	r0
     d8a:	0b be       	out	0x3b, r0	; 59
     d8c:	0f 90       	pop	r0
     d8e:	0f be       	out	0x3f, r0	; 63
     d90:	0f 90       	pop	r0
     d92:	1f 90       	pop	r1
     d94:	18 95       	reti

00000d96 <__vector_30>:

ISR(USART1_RX_vect)
{
     d96:	1f 92       	push	r1
     d98:	0f 92       	push	r0
     d9a:	0f b6       	in	r0, 0x3f	; 63
     d9c:	0f 92       	push	r0
     d9e:	11 24       	eor	r1, r1
     da0:	0b b6       	in	r0, 0x3b	; 59
     da2:	0f 92       	push	r0
     da4:	2f 93       	push	r18
     da6:	3f 93       	push	r19
     da8:	4f 93       	push	r20
     daa:	5f 93       	push	r21
     dac:	6f 93       	push	r22
     dae:	7f 93       	push	r23
     db0:	8f 93       	push	r24
     db2:	9f 93       	push	r25
     db4:	af 93       	push	r26
     db6:	bf 93       	push	r27
     db8:	ef 93       	push	r30
     dba:	ff 93       	push	r31

	RX_ESP_ISR();
     dbc:	b0 d1       	rcall	.+864    	; 0x111e <RX_ESP_ISR>
}
     dbe:	ff 91       	pop	r31
     dc0:	ef 91       	pop	r30
     dc2:	bf 91       	pop	r27
     dc4:	af 91       	pop	r26
     dc6:	9f 91       	pop	r25
     dc8:	8f 91       	pop	r24
     dca:	7f 91       	pop	r23
     dcc:	6f 91       	pop	r22
     dce:	5f 91       	pop	r21
     dd0:	4f 91       	pop	r20
     dd2:	3f 91       	pop	r19
     dd4:	2f 91       	pop	r18
     dd6:	0f 90       	pop	r0
     dd8:	0b be       	out	0x3b, r0	; 59
     dda:	0f 90       	pop	r0
     ddc:	0f be       	out	0x3f, r0	; 63
     dde:	0f 90       	pop	r0
     de0:	1f 90       	pop	r1
     de2:	18 95       	reti

00000de4 <__vector_32>:
ISR(USART1_TX_vect)
{
     de4:	1f 92       	push	r1
     de6:	0f 92       	push	r0
     de8:	0f b6       	in	r0, 0x3f	; 63
     dea:	0f 92       	push	r0
     dec:	11 24       	eor	r1, r1
     dee:	0b b6       	in	r0, 0x3b	; 59
     df0:	0f 92       	push	r0
     df2:	2f 93       	push	r18
     df4:	3f 93       	push	r19
     df6:	4f 93       	push	r20
     df8:	5f 93       	push	r21
     dfa:	6f 93       	push	r22
     dfc:	7f 93       	push	r23
     dfe:	8f 93       	push	r24
     e00:	9f 93       	push	r25
     e02:	af 93       	push	r26
     e04:	bf 93       	push	r27
     e06:	ef 93       	push	r30
     e08:	ff 93       	push	r31

	TX_ESP_ISR();
     e0a:	95 d1       	rcall	.+810    	; 0x1136 <TX_ESP_ISR>
}
     e0c:	ff 91       	pop	r31
     e0e:	ef 91       	pop	r30
     e10:	bf 91       	pop	r27
     e12:	af 91       	pop	r26
     e14:	9f 91       	pop	r25
     e16:	8f 91       	pop	r24
     e18:	7f 91       	pop	r23
     e1a:	6f 91       	pop	r22
     e1c:	5f 91       	pop	r21
     e1e:	4f 91       	pop	r20
     e20:	3f 91       	pop	r19
     e22:	2f 91       	pop	r18
     e24:	0f 90       	pop	r0
     e26:	0b be       	out	0x3b, r0	; 59
     e28:	0f 90       	pop	r0
     e2a:	0f be       	out	0x3f, r0	; 63
     e2c:	0f 90       	pop	r0
     e2e:	1f 90       	pop	r1
     e30:	18 95       	reti

00000e32 <__vector_16>:


ISR(TIMER0_OVF_vect)
{
     e32:	1f 92       	push	r1
     e34:	0f 92       	push	r0
     e36:	0f b6       	in	r0, 0x3f	; 63
     e38:	0f 92       	push	r0
     e3a:	11 24       	eor	r1, r1
     e3c:	0b b6       	in	r0, 0x3b	; 59
     e3e:	0f 92       	push	r0
     e40:	2f 93       	push	r18
     e42:	3f 93       	push	r19
     e44:	4f 93       	push	r20
     e46:	5f 93       	push	r21
     e48:	6f 93       	push	r22
     e4a:	7f 93       	push	r23
     e4c:	8f 93       	push	r24
     e4e:	9f 93       	push	r25
     e50:	af 93       	push	r26
     e52:	bf 93       	push	r27
     e54:	ef 93       	push	r30
     e56:	ff 93       	push	r31
	TIMER0_INT_EVENT();
     e58:	0e 94 76 3d 	call	0x7aec	; 0x7aec <TIMER0_INT_EVENT>
}
     e5c:	ff 91       	pop	r31
     e5e:	ef 91       	pop	r30
     e60:	bf 91       	pop	r27
     e62:	af 91       	pop	r26
     e64:	9f 91       	pop	r25
     e66:	8f 91       	pop	r24
     e68:	7f 91       	pop	r23
     e6a:	6f 91       	pop	r22
     e6c:	5f 91       	pop	r21
     e6e:	4f 91       	pop	r20
     e70:	3f 91       	pop	r19
     e72:	2f 91       	pop	r18
     e74:	0f 90       	pop	r0
     e76:	0b be       	out	0x3b, r0	; 59
     e78:	0f 90       	pop	r0
     e7a:	0f be       	out	0x3f, r0	; 63
     e7c:	0f 90       	pop	r0
     e7e:	1f 90       	pop	r1
     e80:	18 95       	reti

00000e82 <__vector_29>:

ISR(TIMER3_OVF_vect)
{
     e82:	1f 92       	push	r1
     e84:	0f 92       	push	r0
     e86:	0f b6       	in	r0, 0x3f	; 63
     e88:	0f 92       	push	r0
     e8a:	11 24       	eor	r1, r1
     e8c:	0b b6       	in	r0, 0x3b	; 59
     e8e:	0f 92       	push	r0
     e90:	2f 93       	push	r18
     e92:	3f 93       	push	r19
     e94:	4f 93       	push	r20
     e96:	5f 93       	push	r21
     e98:	6f 93       	push	r22
     e9a:	7f 93       	push	r23
     e9c:	8f 93       	push	r24
     e9e:	9f 93       	push	r25
     ea0:	af 93       	push	r26
     ea2:	bf 93       	push	r27
     ea4:	ef 93       	push	r30
     ea6:	ff 93       	push	r31
	TIMER3_INT_EVENT();
     ea8:	0e 94 79 3d 	call	0x7af2	; 0x7af2 <TIMER3_INT_EVENT>
}
     eac:	ff 91       	pop	r31
     eae:	ef 91       	pop	r30
     eb0:	bf 91       	pop	r27
     eb2:	af 91       	pop	r26
     eb4:	9f 91       	pop	r25
     eb6:	8f 91       	pop	r24
     eb8:	7f 91       	pop	r23
     eba:	6f 91       	pop	r22
     ebc:	5f 91       	pop	r21
     ebe:	4f 91       	pop	r20
     ec0:	3f 91       	pop	r19
     ec2:	2f 91       	pop	r18
     ec4:	0f 90       	pop	r0
     ec6:	0b be       	out	0x3b, r0	; 59
     ec8:	0f 90       	pop	r0
     eca:	0f be       	out	0x3f, r0	; 63
     ecc:	0f 90       	pop	r0
     ece:	1f 90       	pop	r1
     ed0:	18 95       	reti

00000ed2 <__vector_18>:

ISR(USART0_RX_vect)
{
     ed2:	1f 92       	push	r1
     ed4:	0f 92       	push	r0
     ed6:	0f b6       	in	r0, 0x3f	; 63
     ed8:	0f 92       	push	r0
     eda:	11 24       	eor	r1, r1
     edc:	0b b6       	in	r0, 0x3b	; 59
     ede:	0f 92       	push	r0
     ee0:	2f 93       	push	r18
     ee2:	3f 93       	push	r19
     ee4:	4f 93       	push	r20
     ee6:	5f 93       	push	r21
     ee8:	6f 93       	push	r22
     eea:	7f 93       	push	r23
     eec:	8f 93       	push	r24
     eee:	9f 93       	push	r25
     ef0:	af 93       	push	r26
     ef2:	bf 93       	push	r27
     ef4:	ef 93       	push	r30
     ef6:	ff 93       	push	r31

	RX0_ISR();
     ef8:	53 dd       	rcall	.-1370   	; 0x9a0 <RX0_ISR>
}
     efa:	ff 91       	pop	r31
     efc:	ef 91       	pop	r30
     efe:	bf 91       	pop	r27
     f00:	af 91       	pop	r26
     f02:	9f 91       	pop	r25
     f04:	8f 91       	pop	r24
     f06:	7f 91       	pop	r23
     f08:	6f 91       	pop	r22
     f0a:	5f 91       	pop	r21
     f0c:	4f 91       	pop	r20
     f0e:	3f 91       	pop	r19
     f10:	2f 91       	pop	r18
     f12:	0f 90       	pop	r0
     f14:	0b be       	out	0x3b, r0	; 59
     f16:	0f 90       	pop	r0
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	0f 90       	pop	r0
     f1c:	1f 90       	pop	r1
     f1e:	18 95       	reti

00000f20 <__vector_10>:

ISR(TIMER2_OVF_vect)
{
     f20:	1f 92       	push	r1
     f22:	0f 92       	push	r0
     f24:	0f b6       	in	r0, 0x3f	; 63
     f26:	0f 92       	push	r0
     f28:	11 24       	eor	r1, r1
     f2a:	0b b6       	in	r0, 0x3b	; 59
     f2c:	0f 92       	push	r0
     f2e:	2f 93       	push	r18
     f30:	3f 93       	push	r19
     f32:	4f 93       	push	r20
     f34:	5f 93       	push	r21
     f36:	6f 93       	push	r22
     f38:	7f 93       	push	r23
     f3a:	8f 93       	push	r24
     f3c:	9f 93       	push	r25
     f3e:	af 93       	push	r26
     f40:	bf 93       	push	r27
     f42:	ef 93       	push	r30
     f44:	ff 93       	push	r31
	TIMER2_ISR();
     f46:	93 dd       	rcall	.-1242   	; 0xa6e <TIMER2_ISR>
}
     f48:	ff 91       	pop	r31
     f4a:	ef 91       	pop	r30
     f4c:	bf 91       	pop	r27
     f4e:	af 91       	pop	r26
     f50:	9f 91       	pop	r25
     f52:	8f 91       	pop	r24
     f54:	7f 91       	pop	r23
     f56:	6f 91       	pop	r22
     f58:	5f 91       	pop	r21
     f5a:	4f 91       	pop	r20
     f5c:	3f 91       	pop	r19
     f5e:	2f 91       	pop	r18
     f60:	0f 90       	pop	r0
     f62:	0b be       	out	0x3b, r0	; 59
     f64:	0f 90       	pop	r0
     f66:	0f be       	out	0x3f, r0	; 63
     f68:	0f 90       	pop	r0
     f6a:	1f 90       	pop	r1
     f6c:	18 95       	reti

00000f6e <__vector_7>:

ISR(INT6_vect)
{
     f6e:	1f 92       	push	r1
     f70:	0f 92       	push	r0
     f72:	0f b6       	in	r0, 0x3f	; 63
     f74:	0f 92       	push	r0
     f76:	11 24       	eor	r1, r1
     f78:	0b b6       	in	r0, 0x3b	; 59
     f7a:	0f 92       	push	r0
     f7c:	2f 93       	push	r18
     f7e:	3f 93       	push	r19
     f80:	4f 93       	push	r20
     f82:	5f 93       	push	r21
     f84:	6f 93       	push	r22
     f86:	7f 93       	push	r23
     f88:	8f 93       	push	r24
     f8a:	9f 93       	push	r25
     f8c:	af 93       	push	r26
     f8e:	bf 93       	push	r27
     f90:	ef 93       	push	r30
     f92:	ff 93       	push	r31
	INT6_ISR();
     f94:	0e 94 14 3b 	call	0x7628	; 0x7628 <INT6_ISR>
}
     f98:	ff 91       	pop	r31
     f9a:	ef 91       	pop	r30
     f9c:	bf 91       	pop	r27
     f9e:	af 91       	pop	r26
     fa0:	9f 91       	pop	r25
     fa2:	8f 91       	pop	r24
     fa4:	7f 91       	pop	r23
     fa6:	6f 91       	pop	r22
     fa8:	5f 91       	pop	r21
     faa:	4f 91       	pop	r20
     fac:	3f 91       	pop	r19
     fae:	2f 91       	pop	r18
     fb0:	0f 90       	pop	r0
     fb2:	0b be       	out	0x3b, r0	; 59
     fb4:	0f 90       	pop	r0
     fb6:	0f be       	out	0x3f, r0	; 63
     fb8:	0f 90       	pop	r0
     fba:	1f 90       	pop	r1
     fbc:	18 95       	reti

00000fbe <__vector_20>:

ISR(USART0_TX_vect)
{
     fbe:	1f 92       	push	r1
     fc0:	0f 92       	push	r0
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	0f 92       	push	r0
     fc6:	11 24       	eor	r1, r1
     fc8:	0b b6       	in	r0, 0x3b	; 59
     fca:	0f 92       	push	r0
     fcc:	2f 93       	push	r18
     fce:	3f 93       	push	r19
     fd0:	4f 93       	push	r20
     fd2:	5f 93       	push	r21
     fd4:	6f 93       	push	r22
     fd6:	7f 93       	push	r23
     fd8:	8f 93       	push	r24
     fda:	9f 93       	push	r25
     fdc:	af 93       	push	r26
     fde:	bf 93       	push	r27
     fe0:	ef 93       	push	r30
     fe2:	ff 93       	push	r31
	TX0_ISR();
     fe4:	8e d8       	rcall	.-3812   	; 0x102 <TX0_ISR>
}
     fe6:	ff 91       	pop	r31
     fe8:	ef 91       	pop	r30
     fea:	bf 91       	pop	r27
     fec:	af 91       	pop	r26
     fee:	9f 91       	pop	r25
     ff0:	8f 91       	pop	r24
     ff2:	7f 91       	pop	r23
     ff4:	6f 91       	pop	r22
     ff6:	5f 91       	pop	r21
     ff8:	4f 91       	pop	r20
     ffa:	3f 91       	pop	r19
     ffc:	2f 91       	pop	r18
     ffe:	0f 90       	pop	r0
    1000:	0b be       	out	0x3b, r0	; 59
    1002:	0f 90       	pop	r0
    1004:	0f be       	out	0x3f, r0	; 63
    1006:	0f 90       	pop	r0
    1008:	1f 90       	pop	r1
    100a:	18 95       	reti

0000100c <__vector_default>:

ISR(BADISR_vect)
{
    100c:	1f 92       	push	r1
    100e:	0f 92       	push	r0
    1010:	0f b6       	in	r0, 0x3f	; 63
    1012:	0f 92       	push	r0
    1014:	11 24       	eor	r1, r1
;
}
    1016:	0f 90       	pop	r0
    1018:	0f be       	out	0x3f, r0	; 63
    101a:	0f 90       	pop	r0
    101c:	1f 90       	pop	r1
    101e:	18 95       	reti

00001020 <main>:
xTaskHandle WIFI_handle,SENSOR_MANAGE_handle;


int main(void)
{
	SETUP();
    1020:	1c de       	rcall	.-968    	; 0xc5a <SETUP>
	TEST_UART_SEND_str("WIFI STACK=");
    1022:	84 e2       	ldi	r24, 0x24	; 36
    1024:	91 e0       	ldi	r25, 0x01	; 1
    1026:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	TEST_UART_SEND_VALUE(xTaskCreate(WIFI_TASK,"W",400,NULL,1,&WIFI_handle));
    102a:	0f 2e       	mov	r0, r31
    102c:	f1 eb       	ldi	r31, 0xB1	; 177
    102e:	ef 2e       	mov	r14, r31
    1030:	fc e0       	ldi	r31, 0x0C	; 12
    1032:	ff 2e       	mov	r15, r31
    1034:	f0 2d       	mov	r31, r0
    1036:	01 e0       	ldi	r16, 0x01	; 1
    1038:	20 e0       	ldi	r18, 0x00	; 0
    103a:	30 e0       	ldi	r19, 0x00	; 0
    103c:	40 e9       	ldi	r20, 0x90	; 144
    103e:	51 e0       	ldi	r21, 0x01	; 1
    1040:	62 e2       	ldi	r22, 0x22	; 34
    1042:	71 e0       	ldi	r23, 0x01	; 1
    1044:	84 ed       	ldi	r24, 0xD4	; 212
    1046:	9f e3       	ldi	r25, 0x3F	; 63
    1048:	0e 94 96 18 	call	0x312c	; 0x312c <xTaskCreate>
    104c:	98 2f       	mov	r25, r24
    104e:	99 0f       	add	r25, r25
    1050:	99 0b       	sbc	r25, r25
    1052:	28 2f       	mov	r18, r24
    1054:	39 2f       	mov	r19, r25
    1056:	49 2f       	mov	r20, r25
    1058:	59 2f       	mov	r21, r25
    105a:	69 2f       	mov	r22, r25
    105c:	79 2f       	mov	r23, r25
    105e:	89 2f       	mov	r24, r25
    1060:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
	TEST_UART_SEND_str("SENSOR STACK=");
    1064:	80 e3       	ldi	r24, 0x30	; 48
    1066:	91 e0       	ldi	r25, 0x01	; 1
    1068:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	TEST_UART_SEND_VALUE(xTaskCreate(SENSOR_MANAGE_TASK,"k",550,NULL,1,&SENSOR_MANAGE_handle));
    106c:	0f 2e       	mov	r0, r31
    106e:	fe ea       	ldi	r31, 0xAE	; 174
    1070:	ef 2e       	mov	r14, r31
    1072:	fc e0       	ldi	r31, 0x0C	; 12
    1074:	ff 2e       	mov	r15, r31
    1076:	f0 2d       	mov	r31, r0
    1078:	20 e0       	ldi	r18, 0x00	; 0
    107a:	30 e0       	ldi	r19, 0x00	; 0
    107c:	46 e2       	ldi	r20, 0x26	; 38
    107e:	52 e0       	ldi	r21, 0x02	; 2
    1080:	6e e3       	ldi	r22, 0x3E	; 62
    1082:	71 e0       	ldi	r23, 0x01	; 1
    1084:	84 ef       	ldi	r24, 0xF4	; 244
    1086:	9a e3       	ldi	r25, 0x3A	; 58
    1088:	0e 94 96 18 	call	0x312c	; 0x312c <xTaskCreate>
    108c:	98 2f       	mov	r25, r24
    108e:	99 0f       	add	r25, r25
    1090:	99 0b       	sbc	r25, r25
    1092:	28 2f       	mov	r18, r24
    1094:	39 2f       	mov	r19, r25
    1096:	49 2f       	mov	r20, r25
    1098:	59 2f       	mov	r21, r25
    109a:	69 2f       	mov	r22, r25
    109c:	79 2f       	mov	r23, r25
    109e:	89 2f       	mov	r24, r25
    10a0:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
	
	
	// Start the RTOS kernel
	vTaskStartScheduler();
    10a4:	0e 94 90 19 	call	0x3320	; 0x3320 <vTaskStartScheduler>
    10a8:	ff cf       	rjmp	.-2      	; 0x10a8 <main+0x88>

000010aa <gpio_inputconfg>:
 * Created: 04/09/2018 01:28:50 
 *  Author: ideapad510
 */ 
#include "microconfigrations.h"
	void gpio_inputconfg(volatile uint8 * DiR_address,volatile uint8 * inputmodreg_address,INPUT_MOD mod,uint8 pin)
	{
    10aa:	fb 01       	movw	r30, r22
		clearbit(*DiR_address,pin);
    10ac:	dc 01       	movw	r26, r24
    10ae:	3c 91       	ld	r19, X
    10b0:	61 e0       	ldi	r22, 0x01	; 1
    10b2:	70 e0       	ldi	r23, 0x00	; 0
    10b4:	02 2e       	mov	r0, r18
    10b6:	02 c0       	rjmp	.+4      	; 0x10bc <gpio_inputconfg+0x12>
    10b8:	66 0f       	add	r22, r22
    10ba:	77 1f       	adc	r23, r23
    10bc:	0a 94       	dec	r0
    10be:	e2 f7       	brpl	.-8      	; 0x10b8 <gpio_inputconfg+0xe>
    10c0:	60 95       	com	r22
    10c2:	36 23       	and	r19, r22
    10c4:	3c 93       	st	X, r19
		clearbit(*inputmodreg_address,pin);
    10c6:	80 81       	ld	r24, Z
    10c8:	68 23       	and	r22, r24
    10ca:	60 83       	st	Z, r22
				*inputmodreg_address|=mod<<pin;
    10cc:	80 81       	ld	r24, Z
    10ce:	50 e0       	ldi	r21, 0x00	; 0
    10d0:	ba 01       	movw	r22, r20
    10d2:	02 c0       	rjmp	.+4      	; 0x10d8 <gpio_inputconfg+0x2e>
    10d4:	66 0f       	add	r22, r22
    10d6:	77 1f       	adc	r23, r23
    10d8:	2a 95       	dec	r18
    10da:	e2 f7       	brpl	.-8      	; 0x10d4 <gpio_inputconfg+0x2a>
    10dc:	9b 01       	movw	r18, r22
    10de:	28 2b       	or	r18, r24
    10e0:	20 83       	st	Z, r18
    10e2:	08 95       	ret

000010e4 <gpio_outputconfg>:
	
	
	
	
	void gpio_outputconfg(volatile uint8 * DiR_address,volatile uint8 * outputmodreg_address,OUTPUTMOD mod,uint8 pin)
	{
    10e4:	fb 01       	movw	r30, r22
		
		setbit(*DiR_address,pin);
    10e6:	dc 01       	movw	r26, r24
    10e8:	3c 91       	ld	r19, X
    10ea:	61 e0       	ldi	r22, 0x01	; 1
    10ec:	70 e0       	ldi	r23, 0x00	; 0
    10ee:	02 2e       	mov	r0, r18
    10f0:	02 c0       	rjmp	.+4      	; 0x10f6 <gpio_outputconfg+0x12>
    10f2:	66 0f       	add	r22, r22
    10f4:	77 1f       	adc	r23, r23
    10f6:	0a 94       	dec	r0
    10f8:	e2 f7       	brpl	.-8      	; 0x10f2 <gpio_outputconfg+0xe>
    10fa:	36 2b       	or	r19, r22
    10fc:	3c 93       	st	X, r19
		clearbit(*outputmodreg_address,pin);
    10fe:	80 81       	ld	r24, Z
    1100:	60 95       	com	r22
    1102:	68 23       	and	r22, r24
    1104:	60 83       	st	Z, r22
		*outputmodreg_address|=mod<<pin;
    1106:	80 81       	ld	r24, Z
    1108:	50 e0       	ldi	r21, 0x00	; 0
    110a:	ba 01       	movw	r22, r20
    110c:	02 c0       	rjmp	.+4      	; 0x1112 <__stack+0x13>
    110e:	66 0f       	add	r22, r22
    1110:	77 1f       	adc	r23, r23
    1112:	2a 95       	dec	r18
    1114:	e2 f7       	brpl	.-8      	; 0x110e <__stack+0xf>
    1116:	9b 01       	movw	r18, r22
    1118:	28 2b       	or	r18, r24
    111a:	20 83       	st	Z, r18
    111c:	08 95       	ret

0000111e <RX_ESP_ISR>:


void RX_ESP_ISR()
{
	/*TEST_UART_SEND_str("E");*/
	if (pdTRUE!=xQueueSendFromISR(RX_ESP_QUEUE,&UDR1,NULL))
    111e:	80 91 6e 10 	lds	r24, 0x106E
    1122:	90 91 6f 10 	lds	r25, 0x106F
    1126:	20 e0       	ldi	r18, 0x00	; 0
    1128:	40 e0       	ldi	r20, 0x00	; 0
    112a:	50 e0       	ldi	r21, 0x00	; 0
    112c:	6c e9       	ldi	r22, 0x9C	; 156
    112e:	70 e0       	ldi	r23, 0x00	; 0
    1130:	0c 94 54 16 	jmp	0x2ca8	; 0x2ca8 <xQueueGenericSendFromISR>
    1134:	08 95       	ret

00001136 <TX_ESP_ISR>:
	}
	
}
void TX_ESP_ISR()
{
	xSemaphoreGiveFromISR(TX_ESP_SEMAPHORE,NULL);
    1136:	80 91 e5 10 	lds	r24, 0x10E5
    113a:	90 91 e6 10 	lds	r25, 0x10E6
    113e:	60 e0       	ldi	r22, 0x00	; 0
    1140:	70 e0       	ldi	r23, 0x00	; 0
    1142:	0c 94 88 16 	jmp	0x2d10	; 0x2d10 <xQueueGiveFromISR>
    1146:	08 95       	ret

00001148 <ESP_UART_SEND_BYTE>:
		ESP_UART_SEND_BYTE(ptr[i]);
	}
}

void ESP_UART_SEND_BYTE(char data)
{
    1148:	cf 93       	push	r28
    114a:	c8 2f       	mov	r28, r24
	{
		;
	} while (pdTRUE!=xSemaphoreTake(TX_ESP_SEMAPHORE,portMAX_DELAY));
	UDR1=data;*/
	
	xSemaphoreTake(TX_ESP_SEMAPHORE,portMAX_DELAY);
    114c:	80 91 e5 10 	lds	r24, 0x10E5
    1150:	90 91 e6 10 	lds	r25, 0x10E6
    1154:	4f ef       	ldi	r20, 0xFF	; 255
    1156:	5f ef       	ldi	r21, 0xFF	; 255
    1158:	ba 01       	movw	r22, r20
    115a:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
	UDR1=data;
    115e:	c0 93 9c 00 	sts	0x009C, r28
	
	
}
    1162:	cf 91       	pop	r28
    1164:	08 95       	ret

00001166 <ESP_UART_SEND_ARRAY>:
{
	xSemaphoreGiveFromISR(TX_ESP_SEMAPHORE,NULL);
}

void ESP_UART_SEND_ARRAY(char *ptr,unsigned char size)
{
    1166:	0f 93       	push	r16
    1168:	1f 93       	push	r17
    116a:	cf 93       	push	r28
    116c:	df 93       	push	r29
    116e:	06 2f       	mov	r16, r22
	unsigned char i=0;
	for(i=0;i<size;i++)
    1170:	66 23       	and	r22, r22
    1172:	41 f0       	breq	.+16     	; 0x1184 <ESP_UART_SEND_ARRAY+0x1e>
    1174:	c8 2f       	mov	r28, r24
    1176:	d9 2f       	mov	r29, r25
    1178:	10 e0       	ldi	r17, 0x00	; 0
	{
		ESP_UART_SEND_BYTE(ptr[i]);
    117a:	89 91       	ld	r24, Y+
    117c:	e5 df       	rcall	.-54     	; 0x1148 <ESP_UART_SEND_BYTE>
}

void ESP_UART_SEND_ARRAY(char *ptr,unsigned char size)
{
	unsigned char i=0;
	for(i=0;i<size;i++)
    117e:	1f 5f       	subi	r17, 0xFF	; 255
    1180:	10 13       	cpse	r17, r16
    1182:	fb cf       	rjmp	.-10     	; 0x117a <ESP_UART_SEND_ARRAY+0x14>
	{
		ESP_UART_SEND_BYTE(ptr[i]);
	}
}
    1184:	df 91       	pop	r29
    1186:	cf 91       	pop	r28
    1188:	1f 91       	pop	r17
    118a:	0f 91       	pop	r16
    118c:	08 95       	ret

0000118e <ESP_UART_RECIVE_BYTE>:
	
	
}

unsigned char ESP_UART_RECIVE_BYTE(volatile unsigned char*V,unsigned short COUNTER)
{
    118e:	ef 92       	push	r14
    1190:	ff 92       	push	r15
    1192:	0f 93       	push	r16
    1194:	1f 93       	push	r17
    1196:	cf 93       	push	r28
    1198:	df 93       	push	r29
    119a:	1f 92       	push	r1
    119c:	cd b7       	in	r28, 0x3d	; 61
    119e:	de b7       	in	r29, 0x3e	; 62
    11a0:	7c 01       	movw	r14, r24
    11a2:	9b 01       	movw	r18, r22
	unsigned char DATA;
	
	if (pdPASS==xQueueReceive(RX_ESP_QUEUE,&DATA,pdMS_TO_TICKS(COUNTER)))
    11a4:	00 91 6e 10 	lds	r16, 0x106E
    11a8:	10 91 6f 10 	lds	r17, 0x106F
    11ac:	a4 e6       	ldi	r26, 0x64	; 100
    11ae:	b0 e0       	ldi	r27, 0x00	; 0
    11b0:	0e 94 32 42 	call	0x8464	; 0x8464 <__umulhisi3>
    11b4:	28 ee       	ldi	r18, 0xE8	; 232
    11b6:	33 e0       	ldi	r19, 0x03	; 3
    11b8:	40 e0       	ldi	r20, 0x00	; 0
    11ba:	50 e0       	ldi	r21, 0x00	; 0
    11bc:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
    11c0:	be 01       	movw	r22, r28
    11c2:	6f 5f       	subi	r22, 0xFF	; 255
    11c4:	7f 4f       	sbci	r23, 0xFF	; 255
    11c6:	c8 01       	movw	r24, r16
    11c8:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <xQueueReceive>
    11cc:	81 30       	cpi	r24, 0x01	; 1
    11ce:	19 f4       	brne	.+6      	; 0x11d6 <ESP_UART_RECIVE_BYTE+0x48>
	{
		/*TEST_UART_SEND_str("YES");*/
		*V=1;
    11d0:	f7 01       	movw	r30, r14
    11d2:	80 83       	st	Z, r24
    11d4:	02 c0       	rjmp	.+4      	; 0x11da <ESP_UART_RECIVE_BYTE+0x4c>
	}
	else
	{
		/*TEST_UART_SEND_str("NO");*/
		*V=0;
    11d6:	f7 01       	movw	r30, r14
    11d8:	10 82       	st	Z, r1
	{
		TEST_UART_SEND_str("NO");	
		*V=0;
	}
	return RX_BUFFER_VALUE;*/
}
    11da:	89 81       	ldd	r24, Y+1	; 0x01
    11dc:	0f 90       	pop	r0
    11de:	df 91       	pop	r29
    11e0:	cf 91       	pop	r28
    11e2:	1f 91       	pop	r17
    11e4:	0f 91       	pop	r16
    11e6:	ff 90       	pop	r15
    11e8:	ef 90       	pop	r14
    11ea:	08 95       	ret

000011ec <ESP_READ_CHAR_AND_CHECK>:


extern volatile QueueHandle_t RX_ESP_QUEUE;

unsigned char ESP_READ_CHAR_AND_CHECK(unsigned char X)
{
    11ec:	1f 93       	push	r17
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
    11f2:	1f 92       	push	r1
    11f4:	cd b7       	in	r28, 0x3d	; 61
    11f6:	de b7       	in	r29, 0x3e	; 62
    11f8:	18 2f       	mov	r17, r24
	unsigned char RECIVE_TEMP_DATA;
	unsigned char V;
	RECIVE_TEMP_DATA=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    11fa:	60 ed       	ldi	r22, 0xD0	; 208
    11fc:	77 e0       	ldi	r23, 0x07	; 7
    11fe:	ce 01       	movw	r24, r28
    1200:	01 96       	adiw	r24, 0x01	; 1
    1202:	c5 df       	rcall	.-118    	; 0x118e <ESP_UART_RECIVE_BYTE>
	if (V==0)
    1204:	99 81       	ldd	r25, Y+1	; 0x01
    1206:	99 23       	and	r25, r25
    1208:	21 f0       	breq	.+8      	; 0x1212 <ESP_READ_CHAR_AND_CHECK+0x26>
	{
		return 1;//WIFI MODULE NOT CONNECTED
	}
	if (RECIVE_TEMP_DATA!=X)
    120a:	81 17       	cp	r24, r17
    120c:	21 f0       	breq	.+8      	; 0x1216 <ESP_READ_CHAR_AND_CHECK+0x2a>
	{
		
		return 2;//wrong data
    120e:	82 e0       	ldi	r24, 0x02	; 2
    1210:	03 c0       	rjmp	.+6      	; 0x1218 <ESP_READ_CHAR_AND_CHECK+0x2c>
	unsigned char RECIVE_TEMP_DATA;
	unsigned char V;
	RECIVE_TEMP_DATA=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
	if (V==0)
	{
		return 1;//WIFI MODULE NOT CONNECTED
    1212:	81 e0       	ldi	r24, 0x01	; 1
    1214:	01 c0       	rjmp	.+2      	; 0x1218 <ESP_READ_CHAR_AND_CHECK+0x2c>
	if (RECIVE_TEMP_DATA!=X)
	{
		
		return 2;//wrong data
	}
	return 0;
    1216:	80 e0       	ldi	r24, 0x00	; 0
}
    1218:	0f 90       	pop	r0
    121a:	df 91       	pop	r29
    121c:	cf 91       	pop	r28
    121e:	1f 91       	pop	r17
    1220:	08 95       	ret

00001222 <ESP_CHECK_OK_RESP>:
	}
	return 0; /*done*/
}

unsigned char ESP_CHECK_OK_RESP()
{
    1222:	cf 93       	push	r28
    1224:	df 93       	push	r29
    1226:	1f 92       	push	r1
    1228:	cd b7       	in	r28, 0x3d	; 61
    122a:	de b7       	in	r29, 0x3e	; 62
	volatile unsigned char TEST;
	TEST=ESP_READ_CHAR_AND_CHECK('\r');
    122c:	8d e0       	ldi	r24, 0x0D	; 13
    122e:	de df       	rcall	.-68     	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
    1230:	89 83       	std	Y+1, r24	; 0x01
	if (TEST)
    1232:	89 81       	ldd	r24, Y+1	; 0x01
    1234:	88 23       	and	r24, r24
    1236:	11 f0       	breq	.+4      	; 0x123c <ESP_CHECK_OK_RESP+0x1a>
	{
		return TEST;
    1238:	89 81       	ldd	r24, Y+1	; 0x01
    123a:	29 c0       	rjmp	.+82     	; 0x128e <ESP_CHECK_OK_RESP+0x6c>
	}
	TEST=ESP_READ_CHAR_AND_CHECK('\n');
    123c:	8a e0       	ldi	r24, 0x0A	; 10
    123e:	d6 df       	rcall	.-84     	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
    1240:	89 83       	std	Y+1, r24	; 0x01
	if (TEST)
    1242:	89 81       	ldd	r24, Y+1	; 0x01
    1244:	88 23       	and	r24, r24
    1246:	11 f0       	breq	.+4      	; 0x124c <ESP_CHECK_OK_RESP+0x2a>
	{
		return TEST;
    1248:	89 81       	ldd	r24, Y+1	; 0x01
    124a:	21 c0       	rjmp	.+66     	; 0x128e <ESP_CHECK_OK_RESP+0x6c>
	}
	TEST=ESP_READ_CHAR_AND_CHECK('O');
    124c:	8f e4       	ldi	r24, 0x4F	; 79
    124e:	ce df       	rcall	.-100    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
    1250:	89 83       	std	Y+1, r24	; 0x01
	if (TEST)
    1252:	89 81       	ldd	r24, Y+1	; 0x01
    1254:	88 23       	and	r24, r24
    1256:	11 f0       	breq	.+4      	; 0x125c <ESP_CHECK_OK_RESP+0x3a>
	{
		return TEST;
    1258:	89 81       	ldd	r24, Y+1	; 0x01
    125a:	19 c0       	rjmp	.+50     	; 0x128e <ESP_CHECK_OK_RESP+0x6c>
	}
	TEST=ESP_READ_CHAR_AND_CHECK('K');
    125c:	8b e4       	ldi	r24, 0x4B	; 75
    125e:	c6 df       	rcall	.-116    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
    1260:	89 83       	std	Y+1, r24	; 0x01
	if (TEST)
    1262:	89 81       	ldd	r24, Y+1	; 0x01
    1264:	88 23       	and	r24, r24
    1266:	11 f0       	breq	.+4      	; 0x126c <ESP_CHECK_OK_RESP+0x4a>
	{
		return TEST;
    1268:	89 81       	ldd	r24, Y+1	; 0x01
    126a:	11 c0       	rjmp	.+34     	; 0x128e <ESP_CHECK_OK_RESP+0x6c>
	}
	TEST=ESP_READ_CHAR_AND_CHECK('\r');
    126c:	8d e0       	ldi	r24, 0x0D	; 13
    126e:	be df       	rcall	.-132    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
    1270:	89 83       	std	Y+1, r24	; 0x01
	if (TEST)
    1272:	89 81       	ldd	r24, Y+1	; 0x01
    1274:	88 23       	and	r24, r24
    1276:	11 f0       	breq	.+4      	; 0x127c <ESP_CHECK_OK_RESP+0x5a>
	{
		return TEST;
    1278:	89 81       	ldd	r24, Y+1	; 0x01
    127a:	09 c0       	rjmp	.+18     	; 0x128e <ESP_CHECK_OK_RESP+0x6c>
	}
	TEST=ESP_READ_CHAR_AND_CHECK('\n');
    127c:	8a e0       	ldi	r24, 0x0A	; 10
    127e:	b6 df       	rcall	.-148    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
    1280:	89 83       	std	Y+1, r24	; 0x01
	if (TEST)
    1282:	89 81       	ldd	r24, Y+1	; 0x01
    1284:	88 23       	and	r24, r24
    1286:	11 f0       	breq	.+4      	; 0x128c <ESP_CHECK_OK_RESP+0x6a>
	{
		return TEST;
    1288:	89 81       	ldd	r24, Y+1	; 0x01
    128a:	01 c0       	rjmp	.+2      	; 0x128e <ESP_CHECK_OK_RESP+0x6c>
	}
	return 0; /*done*/
    128c:	80 e0       	ldi	r24, 0x00	; 0
}
    128e:	0f 90       	pop	r0
    1290:	df 91       	pop	r29
    1292:	cf 91       	pop	r28
    1294:	08 95       	ret

00001296 <ESP_AT_COMMAND>:
}



unsigned char ESP_AT_COMMAND()
{
    1296:	cf 93       	push	r28
    1298:	df 93       	push	r29
    129a:	00 d0       	rcall	.+0      	; 0x129c <ESP_AT_COMMAND+0x6>
    129c:	cd b7       	in	r28, 0x3d	; 61
    129e:	de b7       	in	r29, 0x3e	; 62
	unsigned char RECIVE_TEMP_DATA;
	volatile unsigned char V;
	unsigned char TEST;
	ESP_UART_EMPTY_BUFFER();
    12a0:	61 e0       	ldi	r22, 0x01	; 1
    12a2:	70 e0       	ldi	r23, 0x00	; 0
    12a4:	ce 01       	movw	r24, r28
    12a6:	02 96       	adiw	r24, 0x02	; 2
    12a8:	72 df       	rcall	.-284    	; 0x118e <ESP_UART_RECIVE_BYTE>
    12aa:	8a 81       	ldd	r24, Y+2	; 0x02
    12ac:	81 11       	cpse	r24, r1
    12ae:	f8 cf       	rjmp	.-16     	; 0x12a0 <ESP_AT_COMMAND+0xa>
	ESP_UART_SEND_ARRAY("AT\r\n",4);
    12b0:	64 e0       	ldi	r22, 0x04	; 4
    12b2:	80 e4       	ldi	r24, 0x40	; 64
    12b4:	91 e0       	ldi	r25, 0x01	; 1
    12b6:	57 df       	rcall	.-338    	; 0x1166 <ESP_UART_SEND_ARRAY>
	RECIVE_TEMP_DATA=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    12b8:	60 ed       	ldi	r22, 0xD0	; 208
    12ba:	77 e0       	ldi	r23, 0x07	; 7
    12bc:	ce 01       	movw	r24, r28
    12be:	01 96       	adiw	r24, 0x01	; 1
    12c0:	66 df       	rcall	.-308    	; 0x118e <ESP_UART_RECIVE_BYTE>
	if (V==0)
    12c2:	99 81       	ldd	r25, Y+1	; 0x01
    12c4:	99 23       	and	r25, r25
    12c6:	59 f1       	breq	.+86     	; 0x131e <ESP_AT_COMMAND+0x88>
	{
		/*TEST_UART_SEND_str("B1");*/
		return 1;//WIFI MODULE NOT CONNECTED
	}
	
	if (RECIVE_TEMP_DATA=='b')
    12c8:	82 36       	cpi	r24, 0x62	; 98
    12ca:	59 f1       	breq	.+86     	; 0x1322 <ESP_AT_COMMAND+0x8c>
	{
		/*TEST_UART_SEND_str("B2");*/
		return 3;//busy
	}
	
	if (RECIVE_TEMP_DATA=='A')
    12cc:	81 34       	cpi	r24, 0x41	; 65
    12ce:	a1 f4       	brne	.+40     	; 0x12f8 <ESP_AT_COMMAND+0x62>
	{
		/*
		WAITING AT/r/r/n 
		*/
		/*TEST_UART_SEND_str("B3");*/
		TEST=ESP_READ_CHAR_AND_CHECK('T');
    12d0:	84 e5       	ldi	r24, 0x54	; 84
    12d2:	8c df       	rcall	.-232    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
		if (TEST)
    12d4:	81 11       	cpse	r24, r1
    12d6:	26 c0       	rjmp	.+76     	; 0x1324 <ESP_AT_COMMAND+0x8e>
		{
			return TEST;
		}
		/*TEST_UART_SEND_str("B4");*/
		TEST=ESP_READ_CHAR_AND_CHECK('\r');
    12d8:	8d e0       	ldi	r24, 0x0D	; 13
    12da:	88 df       	rcall	.-240    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
		if (TEST)
    12dc:	81 11       	cpse	r24, r1
    12de:	22 c0       	rjmp	.+68     	; 0x1324 <ESP_AT_COMMAND+0x8e>
		{
			return TEST;
		}
		/*TEST_UART_SEND_str("B5");*/
		TEST=ESP_READ_CHAR_AND_CHECK('\r');
    12e0:	8d e0       	ldi	r24, 0x0D	; 13
    12e2:	84 df       	rcall	.-248    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
		if (TEST)
    12e4:	81 11       	cpse	r24, r1
    12e6:	1e c0       	rjmp	.+60     	; 0x1324 <ESP_AT_COMMAND+0x8e>
		{
			return TEST;
		}
		TEST=ESP_READ_CHAR_AND_CHECK('\n');
    12e8:	8a e0       	ldi	r24, 0x0A	; 10
    12ea:	80 df       	rcall	.-256    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
		if (TEST)
    12ec:	81 11       	cpse	r24, r1
    12ee:	1a c0       	rjmp	.+52     	; 0x1324 <ESP_AT_COMMAND+0x8e>
		{
			return TEST;
		}
		TEST=ESP_READ_CHAR_AND_CHECK('\r');
    12f0:	8d e0       	ldi	r24, 0x0D	; 13
    12f2:	7c df       	rcall	.-264    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
		if (TEST)
    12f4:	81 11       	cpse	r24, r1
    12f6:	16 c0       	rjmp	.+44     	; 0x1324 <ESP_AT_COMMAND+0x8e>
	}
		/*   /r/nOK/r/n	  */
		
		
		
		TEST=ESP_READ_CHAR_AND_CHECK('\n');
    12f8:	8a e0       	ldi	r24, 0x0A	; 10
    12fa:	78 df       	rcall	.-272    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
		if (TEST)
    12fc:	81 11       	cpse	r24, r1
    12fe:	12 c0       	rjmp	.+36     	; 0x1324 <ESP_AT_COMMAND+0x8e>
		{/*TEST_UART_SEND_VALUE(TEST);*/
			/*TEST_UART_SEND_str("G1");*/
			return TEST;
		}
		TEST=ESP_READ_CHAR_AND_CHECK('O');
    1300:	8f e4       	ldi	r24, 0x4F	; 79
    1302:	74 df       	rcall	.-280    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
		if (TEST)
    1304:	81 11       	cpse	r24, r1
    1306:	0e c0       	rjmp	.+28     	; 0x1324 <ESP_AT_COMMAND+0x8e>
		{/*TEST_UART_SEND_VALUE(TEST);*/
			/*TEST_UART_SEND_str("G2");*/
			return TEST;
		}
		TEST=ESP_READ_CHAR_AND_CHECK('K');
    1308:	8b e4       	ldi	r24, 0x4B	; 75
    130a:	70 df       	rcall	.-288    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
		if (TEST)
    130c:	81 11       	cpse	r24, r1
    130e:	0a c0       	rjmp	.+20     	; 0x1324 <ESP_AT_COMMAND+0x8e>
		{/*TEST_UART_SEND_VALUE(TEST);*/
			/*TEST_UART_SEND_str("G3");*/
			return TEST;
		}
		TEST=ESP_READ_CHAR_AND_CHECK('\r');
    1310:	8d e0       	ldi	r24, 0x0D	; 13
    1312:	6c df       	rcall	.-296    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
		if (TEST)
    1314:	81 11       	cpse	r24, r1
    1316:	06 c0       	rjmp	.+12     	; 0x1324 <ESP_AT_COMMAND+0x8e>
		{
		/*	TEST_UART_SEND_VALUE(TEST);
			TEST_UART_SEND_str("G4");*/
			return TEST;
		}
		TEST=ESP_READ_CHAR_AND_CHECK('\n');
    1318:	8a e0       	ldi	r24, 0x0A	; 10
    131a:	68 df       	rcall	.-304    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
    131c:	03 c0       	rjmp	.+6      	; 0x1324 <ESP_AT_COMMAND+0x8e>
	ESP_UART_SEND_ARRAY("AT\r\n",4);
	RECIVE_TEMP_DATA=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
	if (V==0)
	{
		/*TEST_UART_SEND_str("B1");*/
		return 1;//WIFI MODULE NOT CONNECTED
    131e:	81 e0       	ldi	r24, 0x01	; 1
    1320:	01 c0       	rjmp	.+2      	; 0x1324 <ESP_AT_COMMAND+0x8e>
	}
	
	if (RECIVE_TEMP_DATA=='b')
	{
		/*TEST_UART_SEND_str("B2");*/
		return 3;//busy
    1322:	83 e0       	ldi	r24, 0x03	; 3
		{/*TEST_UART_SEND_VALUE(TEST);
			TEST_UART_SEND_str("G5");*/
			return TEST;
		}
		return 0; /*done*/
}
    1324:	0f 90       	pop	r0
    1326:	0f 90       	pop	r0
    1328:	df 91       	pop	r29
    132a:	cf 91       	pop	r28
    132c:	08 95       	ret

0000132e <ESP_ATE_COMMAND>:

unsigned char ESP_ATE_COMMAND()
{
    132e:	cf 93       	push	r28
    1330:	df 93       	push	r29
    1332:	1f 92       	push	r1
    1334:	cd b7       	in	r28, 0x3d	; 61
    1336:	de b7       	in	r29, 0x3e	; 62
	ESP_UART_EMPTY_BUFFER();
    1338:	61 e0       	ldi	r22, 0x01	; 1
    133a:	70 e0       	ldi	r23, 0x00	; 0
    133c:	ce 01       	movw	r24, r28
    133e:	01 96       	adiw	r24, 0x01	; 1
    1340:	26 df       	rcall	.-436    	; 0x118e <ESP_UART_RECIVE_BYTE>
    1342:	89 81       	ldd	r24, Y+1	; 0x01
    1344:	81 11       	cpse	r24, r1
    1346:	f8 cf       	rjmp	.-16     	; 0x1338 <ESP_ATE_COMMAND+0xa>
	ESP_UART_SEND_ARRAY("ATE0\r\n",6);
    1348:	66 e0       	ldi	r22, 0x06	; 6
    134a:	85 e4       	ldi	r24, 0x45	; 69
    134c:	91 e0       	ldi	r25, 0x01	; 1
    134e:	0b df       	rcall	.-490    	; 0x1166 <ESP_UART_SEND_ARRAY>
	vTaskDelay(pdMS_TO_TICKS(1000));
    1350:	64 e6       	ldi	r22, 0x64	; 100
    1352:	70 e0       	ldi	r23, 0x00	; 0
    1354:	80 e0       	ldi	r24, 0x00	; 0
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
	return 0;
}
    135c:	80 e0       	ldi	r24, 0x00	; 0
    135e:	0f 90       	pop	r0
    1360:	df 91       	pop	r29
    1362:	cf 91       	pop	r28
    1364:	08 95       	ret

00001366 <ESP_CWMODE_1>:

unsigned char ESP_CWMODE_1()
{
    1366:	cf 93       	push	r28
    1368:	df 93       	push	r29
    136a:	1f 92       	push	r1
    136c:	cd b7       	in	r28, 0x3d	; 61
    136e:	de b7       	in	r29, 0x3e	; 62
	unsigned char test;
	ESP_UART_EMPTY_BUFFER();
    1370:	61 e0       	ldi	r22, 0x01	; 1
    1372:	70 e0       	ldi	r23, 0x00	; 0
    1374:	ce 01       	movw	r24, r28
    1376:	01 96       	adiw	r24, 0x01	; 1
    1378:	0a df       	rcall	.-492    	; 0x118e <ESP_UART_RECIVE_BYTE>
    137a:	89 81       	ldd	r24, Y+1	; 0x01
    137c:	81 11       	cpse	r24, r1
    137e:	f8 cf       	rjmp	.-16     	; 0x1370 <ESP_CWMODE_1+0xa>
	ESP_UART_SEND_ARRAY("AT+CWMODE_CUR=1\r\n",17);
    1380:	61 e1       	ldi	r22, 0x11	; 17
    1382:	8c e4       	ldi	r24, 0x4C	; 76
    1384:	91 e0       	ldi	r25, 0x01	; 1
    1386:	ef de       	rcall	.-546    	; 0x1166 <ESP_UART_SEND_ARRAY>
	test=ESP_CHECK_OK_RESP();
    1388:	4c df       	rcall	.-360    	; 0x1222 <ESP_CHECK_OK_RESP>
	if (test)
	{
		return test;
	}
	return 0; /*done*/
}
    138a:	0f 90       	pop	r0
    138c:	df 91       	pop	r29
    138e:	cf 91       	pop	r28
    1390:	08 95       	ret

00001392 <ESP_CWLAPOPT_1>:

unsigned char ESP_CWLAPOPT_1()
{
    1392:	cf 93       	push	r28
    1394:	df 93       	push	r29
    1396:	1f 92       	push	r1
    1398:	cd b7       	in	r28, 0x3d	; 61
    139a:	de b7       	in	r29, 0x3e	; 62
	unsigned char test;
	ESP_UART_EMPTY_BUFFER();
    139c:	61 e0       	ldi	r22, 0x01	; 1
    139e:	70 e0       	ldi	r23, 0x00	; 0
    13a0:	ce 01       	movw	r24, r28
    13a2:	01 96       	adiw	r24, 0x01	; 1
    13a4:	f4 de       	rcall	.-536    	; 0x118e <ESP_UART_RECIVE_BYTE>
    13a6:	89 81       	ldd	r24, Y+1	; 0x01
    13a8:	81 11       	cpse	r24, r1
    13aa:	f8 cf       	rjmp	.-16     	; 0x139c <ESP_CWLAPOPT_1+0xa>
	ESP_UART_SEND_ARRAY("AT+CWLAPOPT=1,2\r\n",17);
    13ac:	61 e1       	ldi	r22, 0x11	; 17
    13ae:	8e e5       	ldi	r24, 0x5E	; 94
    13b0:	91 e0       	ldi	r25, 0x01	; 1
    13b2:	d9 de       	rcall	.-590    	; 0x1166 <ESP_UART_SEND_ARRAY>
	test=ESP_CHECK_OK_RESP();
    13b4:	36 df       	rcall	.-404    	; 0x1222 <ESP_CHECK_OK_RESP>
	if (test)
	{
		return test;
	}
	return 0; /*done*/
}
    13b6:	0f 90       	pop	r0
    13b8:	df 91       	pop	r29
    13ba:	cf 91       	pop	r28
    13bc:	08 95       	ret

000013be <ESP_SETUP>:



unsigned char ESP_SETUP()
{
	vTaskDelay(pdMS_TO_TICKS(100));
    13be:	6a e0       	ldi	r22, 0x0A	; 10
    13c0:	70 e0       	ldi	r23, 0x00	; 0
    13c2:	80 e0       	ldi	r24, 0x00	; 0
    13c4:	90 e0       	ldi	r25, 0x00	; 0
    13c6:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
	
	
	unsigned char test;
	test=ESP_AT_COMMAND();
    13ca:	65 df       	rcall	.-310    	; 0x1296 <ESP_AT_COMMAND>
	if (test)
    13cc:	81 11       	cpse	r24, r1
    13ce:	07 c0       	rjmp	.+14     	; 0x13de <ESP_SETUP+0x20>
	{
		/*TEST_UART_SEND_str("X1");*/
		return test;
	}

	test=ESP_ATE_COMMAND();
    13d0:	ae df       	rcall	.-164    	; 0x132e <ESP_ATE_COMMAND>
	if (test)
    13d2:	81 11       	cpse	r24, r1
    13d4:	04 c0       	rjmp	.+8      	; 0x13de <ESP_SETUP+0x20>
	{/*TEST_UART_SEND_str("X2");*/
		return test;
	}
	
	test=ESP_CWMODE_1();
    13d6:	c7 df       	rcall	.-114    	; 0x1366 <ESP_CWMODE_1>
	if (test)
    13d8:	81 11       	cpse	r24, r1
    13da:	01 c0       	rjmp	.+2      	; 0x13de <ESP_SETUP+0x20>
	{
		return test;
	}
	
	test=ESP_CWLAPOPT_1();
    13dc:	da cf       	rjmp	.-76     	; 0x1392 <ESP_CWLAPOPT_1>
	{
		return test;
	}
	
	return 0;
}
    13de:	08 95       	ret

000013e0 <ESP_CIPSTATUS>:
	return 0; /*done*/
}


unsigned char ESP_CIPSTATUS(unsigned char *RETURN_VALUE)
{
    13e0:	0f 93       	push	r16
    13e2:	1f 93       	push	r17
    13e4:	cf 93       	push	r28
    13e6:	df 93       	push	r29
    13e8:	00 d0       	rcall	.+0      	; 0x13ea <ESP_CIPSTATUS+0xa>
    13ea:	cd b7       	in	r28, 0x3d	; 61
    13ec:	de b7       	in	r29, 0x3e	; 62
    13ee:	8c 01       	movw	r16, r24
	unsigned char RECIVE_TEMP_DATA[1];
	unsigned char V;
	unsigned char TEST;
	ESP_UART_EMPTY_BUFFER();
    13f0:	61 e0       	ldi	r22, 0x01	; 1
    13f2:	70 e0       	ldi	r23, 0x00	; 0
    13f4:	ce 01       	movw	r24, r28
    13f6:	02 96       	adiw	r24, 0x02	; 2
    13f8:	ca de       	rcall	.-620    	; 0x118e <ESP_UART_RECIVE_BYTE>
    13fa:	8a 81       	ldd	r24, Y+2	; 0x02
    13fc:	81 11       	cpse	r24, r1
    13fe:	f8 cf       	rjmp	.-16     	; 0x13f0 <ESP_CIPSTATUS+0x10>
	ESP_UART_SEND_ARRAY("AT+CIPSTATUS\r\n",14);
    1400:	6e e0       	ldi	r22, 0x0E	; 14
    1402:	80 e7       	ldi	r24, 0x70	; 112
    1404:	91 e0       	ldi	r25, 0x01	; 1
    1406:	af de       	rcall	.-674    	; 0x1166 <ESP_UART_SEND_ARRAY>
	TEST=ESP_READ_CHAR_AND_CHECK('S');
    1408:	83 e5       	ldi	r24, 0x53	; 83
    140a:	f0 de       	rcall	.-544    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
	if (TEST)
    140c:	81 11       	cpse	r24, r1
    140e:	32 c0       	rjmp	.+100    	; 0x1474 <ESP_CIPSTATUS+0x94>
	{
		return TEST;
	}
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    1410:	60 ed       	ldi	r22, 0xD0	; 208
    1412:	77 e0       	ldi	r23, 0x07	; 7
    1414:	ce 01       	movw	r24, r28
    1416:	01 96       	adiw	r24, 0x01	; 1
    1418:	ba de       	rcall	.-652    	; 0x118e <ESP_UART_RECIVE_BYTE>
		if (V==0)
    141a:	99 81       	ldd	r25, Y+1	; 0x01
    141c:	99 23       	and	r25, r25
    141e:	29 f1       	breq	.+74     	; 0x146a <ESP_CIPSTATUS+0x8a>
		{
			return 1;//WIFI MODULE NOT CONNECTED
		}
	} while (RECIVE_TEMP_DATA[0]!=':');
    1420:	8a 33       	cpi	r24, 0x3A	; 58
    1422:	b1 f7       	brne	.-20     	; 0x1410 <ESP_CIPSTATUS+0x30>
	RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    1424:	60 ed       	ldi	r22, 0xD0	; 208
    1426:	77 e0       	ldi	r23, 0x07	; 7
    1428:	ce 01       	movw	r24, r28
    142a:	01 96       	adiw	r24, 0x01	; 1
    142c:	b0 de       	rcall	.-672    	; 0x118e <ESP_UART_RECIVE_BYTE>
	if (V==0)
    142e:	99 81       	ldd	r25, Y+1	; 0x01
    1430:	99 23       	and	r25, r25
    1432:	e9 f0       	breq	.+58     	; 0x146e <ESP_CIPSTATUS+0x8e>
	{
		return 1;//WIFI MODULE NOT CONNECTED
	}
	*RETURN_VALUE=RECIVE_TEMP_DATA[0]-48;
    1434:	80 53       	subi	r24, 0x30	; 48
    1436:	f8 01       	movw	r30, r16
    1438:	80 83       	st	Z, r24
	TEST=ESP_READ_CHAR_AND_CHECK('\r');
    143a:	8d e0       	ldi	r24, 0x0D	; 13
    143c:	d7 de       	rcall	.-594    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
	if (TEST)
    143e:	81 11       	cpse	r24, r1
    1440:	19 c0       	rjmp	.+50     	; 0x1474 <ESP_CIPSTATUS+0x94>
	{
		return TEST;
	}
	TEST=ESP_READ_CHAR_AND_CHECK('\n');
    1442:	8a e0       	ldi	r24, 0x0A	; 10
    1444:	d3 de       	rcall	.-602    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
	if (TEST)
    1446:	81 11       	cpse	r24, r1
    1448:	15 c0       	rjmp	.+42     	; 0x1474 <ESP_CIPSTATUS+0x94>
	{
		return TEST;
	}
	
	if(*RETURN_VALUE==3)
    144a:	f8 01       	movw	r30, r16
    144c:	80 81       	ld	r24, Z
    144e:	83 30       	cpi	r24, 0x03	; 3
    1450:	51 f4       	brne	.+20     	; 0x1466 <ESP_CIPSTATUS+0x86>
	{
		do
		{
			RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    1452:	60 ed       	ldi	r22, 0xD0	; 208
    1454:	77 e0       	ldi	r23, 0x07	; 7
    1456:	ce 01       	movw	r24, r28
    1458:	01 96       	adiw	r24, 0x01	; 1
    145a:	99 de       	rcall	.-718    	; 0x118e <ESP_UART_RECIVE_BYTE>
			if (V==0)
    145c:	99 81       	ldd	r25, Y+1	; 0x01
    145e:	99 23       	and	r25, r25
    1460:	41 f0       	breq	.+16     	; 0x1472 <ESP_CIPSTATUS+0x92>
			{
				return 1;//WIFI MODULE NOT CONNECTED
			}
		} while (RECIVE_TEMP_DATA[0]!='\n');
    1462:	8a 30       	cpi	r24, 0x0A	; 10
    1464:	b1 f7       	brne	.-20     	; 0x1452 <ESP_CIPSTATUS+0x72>
	}
	
	TEST=ESP_CHECK_OK_RESP();
    1466:	dd de       	rcall	.-582    	; 0x1222 <ESP_CHECK_OK_RESP>
    1468:	05 c0       	rjmp	.+10     	; 0x1474 <ESP_CIPSTATUS+0x94>
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
		if (V==0)
		{
			return 1;//WIFI MODULE NOT CONNECTED
    146a:	81 e0       	ldi	r24, 0x01	; 1
    146c:	03 c0       	rjmp	.+6      	; 0x1474 <ESP_CIPSTATUS+0x94>
		}
	} while (RECIVE_TEMP_DATA[0]!=':');
	RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
	if (V==0)
	{
		return 1;//WIFI MODULE NOT CONNECTED
    146e:	81 e0       	ldi	r24, 0x01	; 1
    1470:	01 c0       	rjmp	.+2      	; 0x1474 <ESP_CIPSTATUS+0x94>
		do
		{
			RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
			if (V==0)
			{
				return 1;//WIFI MODULE NOT CONNECTED
    1472:	81 e0       	ldi	r24, 0x01	; 1
	/**/
	
	
	/**/
	return 0; /*done*/
}
    1474:	0f 90       	pop	r0
    1476:	0f 90       	pop	r0
    1478:	df 91       	pop	r29
    147a:	cf 91       	pop	r28
    147c:	1f 91       	pop	r17
    147e:	0f 91       	pop	r16
    1480:	08 95       	ret

00001482 <ESP_CWJAP_CUR>:

unsigned char ESP_CWJAP_CUR(unsigned char *AP_NAME,unsigned char AP_LENGTH,unsigned char *PASS_NAME,unsigned char PASS_LENGTH)
{
    1482:	cf 92       	push	r12
    1484:	df 92       	push	r13
    1486:	ef 92       	push	r14
    1488:	ff 92       	push	r15
    148a:	0f 93       	push	r16
    148c:	1f 93       	push	r17
    148e:	cf 93       	push	r28
    1490:	df 93       	push	r29
    1492:	00 d0       	rcall	.+0      	; 0x1494 <ESP_CWJAP_CUR+0x12>
    1494:	cd b7       	in	r28, 0x3d	; 61
    1496:	de b7       	in	r29, 0x3e	; 62
    1498:	7c 01       	movw	r14, r24
    149a:	c6 2e       	mov	r12, r22
    149c:	8a 01       	movw	r16, r20
    149e:	d2 2e       	mov	r13, r18
	
	unsigned char test;
	ESP_UART_EMPTY_BUFFER();
    14a0:	61 e0       	ldi	r22, 0x01	; 1
    14a2:	70 e0       	ldi	r23, 0x00	; 0
    14a4:	ce 01       	movw	r24, r28
    14a6:	02 96       	adiw	r24, 0x02	; 2
    14a8:	72 de       	rcall	.-796    	; 0x118e <ESP_UART_RECIVE_BYTE>
    14aa:	8a 81       	ldd	r24, Y+2	; 0x02
    14ac:	81 11       	cpse	r24, r1
    14ae:	f8 cf       	rjmp	.-16     	; 0x14a0 <ESP_CWJAP_CUR+0x1e>
	ESP_UART_SEND_ARRAY("AT+CWJAP_CUR=\"",14);
    14b0:	6e e0       	ldi	r22, 0x0E	; 14
    14b2:	8f e7       	ldi	r24, 0x7F	; 127
    14b4:	91 e0       	ldi	r25, 0x01	; 1
    14b6:	57 de       	rcall	.-850    	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY((char*)AP_NAME,AP_LENGTH);
    14b8:	6c 2d       	mov	r22, r12
    14ba:	c7 01       	movw	r24, r14
    14bc:	54 de       	rcall	.-856    	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY("\",\"",3);
    14be:	63 e0       	ldi	r22, 0x03	; 3
    14c0:	8e e8       	ldi	r24, 0x8E	; 142
    14c2:	91 e0       	ldi	r25, 0x01	; 1
    14c4:	50 de       	rcall	.-864    	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY((char*)PASS_NAME,PASS_LENGTH);
    14c6:	6d 2d       	mov	r22, r13
    14c8:	c8 01       	movw	r24, r16
    14ca:	4d de       	rcall	.-870    	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY("\"\r\n",3);
    14cc:	63 e0       	ldi	r22, 0x03	; 3
    14ce:	82 e9       	ldi	r24, 0x92	; 146
    14d0:	91 e0       	ldi	r25, 0x01	; 1
    14d2:	49 de       	rcall	.-878    	; 0x1166 <ESP_UART_SEND_ARRAY>
	do
	{
		vTaskDelay(pdMS_TO_TICKS(4000));
    14d4:	60 e9       	ldi	r22, 0x90	; 144
    14d6:	71 e0       	ldi	r23, 0x01	; 1
    14d8:	80 e0       	ldi	r24, 0x00	; 0
    14da:	90 e0       	ldi	r25, 0x00	; 0
    14dc:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
		vTaskDelay(pdMS_TO_TICKS(4000));
    14e0:	60 e9       	ldi	r22, 0x90	; 144
    14e2:	71 e0       	ldi	r23, 0x01	; 1
    14e4:	80 e0       	ldi	r24, 0x00	; 0
    14e6:	90 e0       	ldi	r25, 0x00	; 0
    14e8:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
		
		ESP_UART_EMPTY_BUFFER();
    14ec:	61 e0       	ldi	r22, 0x01	; 1
    14ee:	70 e0       	ldi	r23, 0x00	; 0
    14f0:	ce 01       	movw	r24, r28
    14f2:	01 96       	adiw	r24, 0x01	; 1
    14f4:	4c de       	rcall	.-872    	; 0x118e <ESP_UART_RECIVE_BYTE>
    14f6:	89 81       	ldd	r24, Y+1	; 0x01
    14f8:	81 11       	cpse	r24, r1
    14fa:	f8 cf       	rjmp	.-16     	; 0x14ec <ESP_CWJAP_CUR+0x6a>
		test=ESP_AT_COMMAND();
    14fc:	cc de       	rcall	.-616    	; 0x1296 <ESP_AT_COMMAND>
		
	} while (test==3);
    14fe:	83 30       	cpi	r24, 0x03	; 3
    1500:	49 f3       	breq	.-46     	; 0x14d4 <ESP_CWJAP_CUR+0x52>
	return test;
}
    1502:	0f 90       	pop	r0
    1504:	0f 90       	pop	r0
    1506:	df 91       	pop	r29
    1508:	cf 91       	pop	r28
    150a:	1f 91       	pop	r17
    150c:	0f 91       	pop	r16
    150e:	ff 90       	pop	r15
    1510:	ef 90       	pop	r14
    1512:	df 90       	pop	r13
    1514:	cf 90       	pop	r12
    1516:	08 95       	ret

00001518 <ESP_CONNECT_AP>:
	return 0;
}


unsigned char ESP_CONNECT_AP(unsigned char *AP_NAME,unsigned char AP_LENGTH,unsigned char *PASS_NAME,unsigned char PASS_LENGTH, unsigned char *connection_state)
{
    1518:	af 92       	push	r10
    151a:	bf 92       	push	r11
    151c:	cf 92       	push	r12
    151e:	df 92       	push	r13
    1520:	ef 92       	push	r14
    1522:	ff 92       	push	r15
    1524:	0f 93       	push	r16
    1526:	1f 93       	push	r17
    1528:	cf 93       	push	r28
    152a:	df 93       	push	r29
    152c:	1f 92       	push	r1
    152e:	cd b7       	in	r28, 0x3d	; 61
    1530:	de b7       	in	r29, 0x3e	; 62
    1532:	7c 01       	movw	r14, r24
    1534:	b6 2e       	mov	r11, r22
    1536:	6a 01       	movw	r12, r20
    1538:	a2 2e       	mov	r10, r18
	unsigned char test,test2;
	test=ESP_AT_COMMAND();
    153a:	ad de       	rcall	.-678    	; 0x1296 <ESP_AT_COMMAND>
	if (test)
    153c:	81 11       	cpse	r24, r1
    153e:	21 c0       	rjmp	.+66     	; 0x1582 <ESP_CONNECT_AP+0x6a>
	{/*TEST_UART_SEND_str("A1");*/
		return test;
	}
	test=ESP_CIPSTATUS(&test2);
    1540:	ce 01       	movw	r24, r28
    1542:	01 96       	adiw	r24, 0x01	; 1
    1544:	4d df       	rcall	.-358    	; 0x13e0 <ESP_CIPSTATUS>
	if (test)
    1546:	81 11       	cpse	r24, r1
    1548:	1c c0       	rjmp	.+56     	; 0x1582 <ESP_CONNECT_AP+0x6a>
	{
		return test;
	}
	*connection_state=1;
    154a:	81 e0       	ldi	r24, 0x01	; 1
    154c:	f8 01       	movw	r30, r16
    154e:	80 83       	st	Z, r24
	if (test2==5)
    1550:	89 81       	ldd	r24, Y+1	; 0x01
    1552:	85 30       	cpi	r24, 0x05	; 5
    1554:	99 f4       	brne	.+38     	; 0x157c <ESP_CONNECT_AP+0x64>
	{
		test=ESP_CWJAP_CUR(AP_NAME,AP_LENGTH,PASS_NAME,PASS_LENGTH);
    1556:	2a 2d       	mov	r18, r10
    1558:	a6 01       	movw	r20, r12
    155a:	6b 2d       	mov	r22, r11
    155c:	c7 01       	movw	r24, r14
    155e:	91 df       	rcall	.-222    	; 0x1482 <ESP_CWJAP_CUR>
		if (test)
    1560:	81 11       	cpse	r24, r1
    1562:	0f c0       	rjmp	.+30     	; 0x1582 <ESP_CONNECT_AP+0x6a>
		{/*TEST_UART_SEND_str("A3");*/
			return test;
		}
		test=ESP_CIPSTATUS(&test2);
    1564:	ce 01       	movw	r24, r28
    1566:	01 96       	adiw	r24, 0x01	; 1
    1568:	3b df       	rcall	.-394    	; 0x13e0 <ESP_CIPSTATUS>
		if (test)
    156a:	81 11       	cpse	r24, r1
    156c:	0a c0       	rjmp	.+20     	; 0x1582 <ESP_CONNECT_AP+0x6a>
		{/*TEST_UART_SEND_str("A4");*/
			return test;
		}
		if (test2==5)
    156e:	89 81       	ldd	r24, Y+1	; 0x01
    1570:	85 30       	cpi	r24, 0x05	; 5
    1572:	31 f4       	brne	.+12     	; 0x1580 <ESP_CONNECT_AP+0x68>
		{
			*connection_state=0;
    1574:	f8 01       	movw	r30, r16
    1576:	10 82       	st	Z, r1
		}
		
	}
	/*TEST_UART_SEND_str("A5");*/
	return 0;//done
    1578:	80 e0       	ldi	r24, 0x00	; 0
    157a:	03 c0       	rjmp	.+6      	; 0x1582 <ESP_CONNECT_AP+0x6a>
    157c:	80 e0       	ldi	r24, 0x00	; 0
    157e:	01 c0       	rjmp	.+2      	; 0x1582 <ESP_CONNECT_AP+0x6a>
    1580:	80 e0       	ldi	r24, 0x00	; 0
	
}
    1582:	0f 90       	pop	r0
    1584:	df 91       	pop	r29
    1586:	cf 91       	pop	r28
    1588:	1f 91       	pop	r17
    158a:	0f 91       	pop	r16
    158c:	ff 90       	pop	r15
    158e:	ef 90       	pop	r14
    1590:	df 90       	pop	r13
    1592:	cf 90       	pop	r12
    1594:	bf 90       	pop	r11
    1596:	af 90       	pop	r10
    1598:	08 95       	ret

0000159a <ESP_OPEN_SOCKET>:
	return test;
}


unsigned char ESP_OPEN_SOCKET() /*SIMPLIFIED*/
{
    159a:	1f 93       	push	r17
    159c:	cf 93       	push	r28
    159e:	df 93       	push	r29
    15a0:	00 d0       	rcall	.+0      	; 0x15a2 <ESP_OPEN_SOCKET+0x8>
    15a2:	cd b7       	in	r28, 0x3d	; 61
    15a4:	de b7       	in	r29, 0x3e	; 62
	unsigned char RECIVE_TEMP_DATA[1];
	unsigned char V;
	unsigned char TEST;
	ESP_UART_EMPTY_BUFFER();
    15a6:	61 e0       	ldi	r22, 0x01	; 1
    15a8:	70 e0       	ldi	r23, 0x00	; 0
    15aa:	ce 01       	movw	r24, r28
    15ac:	02 96       	adiw	r24, 0x02	; 2
    15ae:	ef dd       	rcall	.-1058   	; 0x118e <ESP_UART_RECIVE_BYTE>
    15b0:	8a 81       	ldd	r24, Y+2	; 0x02
    15b2:	81 11       	cpse	r24, r1
    15b4:	f8 cf       	rjmp	.-16     	; 0x15a6 <ESP_OPEN_SOCKET+0xc>
	ESP_UART_SEND_ARRAY("AT+CIPSTART=\"TCP\",\"api.thingspeak.com\",80\r\n",43);
    15b6:	6b e2       	ldi	r22, 0x2B	; 43
    15b8:	86 e9       	ldi	r24, 0x96	; 150
    15ba:	91 e0       	ldi	r25, 0x01	; 1
    15bc:	d4 dd       	rcall	.-1112   	; 0x1166 <ESP_UART_SEND_ARRAY>
	/*CONNECT\r\n\r\nOK\r\n*/
	/*vTaskDelay(pdMS_TO_TICKS(1000));*/
	TEST=ESP_READ_CHAR_AND_CHECK('C');
    15be:	83 e4       	ldi	r24, 0x43	; 67
    15c0:	15 de       	rcall	.-982    	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
    15c2:	18 2f       	mov	r17, r24
	if (TEST)
    15c4:	88 23       	and	r24, r24
    15c6:	81 f0       	breq	.+32     	; 0x15e8 <ESP_OPEN_SOCKET+0x4e>
	{	TEST_UART_SEND_VALUE(TEST);
    15c8:	28 2f       	mov	r18, r24
    15ca:	30 e0       	ldi	r19, 0x00	; 0
    15cc:	40 e0       	ldi	r20, 0x00	; 0
    15ce:	50 e0       	ldi	r21, 0x00	; 0
    15d0:	60 e0       	ldi	r22, 0x00	; 0
    15d2:	70 e0       	ldi	r23, 0x00	; 0
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	90 e0       	ldi	r25, 0x00	; 0
    15d8:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
		TEST_UART_SEND_str("SSS\n");
    15dc:	82 ec       	ldi	r24, 0xC2	; 194
    15de:	91 e0       	ldi	r25, 0x01	; 1
    15e0:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
		return TEST;
    15e4:	81 2f       	mov	r24, r17
    15e6:	1a c0       	rjmp	.+52     	; 0x161c <ESP_OPEN_SOCKET+0x82>
	}
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    15e8:	60 ed       	ldi	r22, 0xD0	; 208
    15ea:	77 e0       	ldi	r23, 0x07	; 7
    15ec:	ce 01       	movw	r24, r28
    15ee:	01 96       	adiw	r24, 0x01	; 1
    15f0:	ce dd       	rcall	.-1124   	; 0x118e <ESP_UART_RECIVE_BYTE>
		if (V==0)
    15f2:	99 81       	ldd	r25, Y+1	; 0x01
    15f4:	91 11       	cpse	r25, r1
    15f6:	06 c0       	rjmp	.+12     	; 0x1604 <ESP_OPEN_SOCKET+0x6a>
		{
			TEST_UART_SEND_str("FFF\n");
    15f8:	87 ec       	ldi	r24, 0xC7	; 199
    15fa:	91 e0       	ldi	r25, 0x01	; 1
    15fc:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
			return 1;//WIFI MODULE NOT CONNECTED
    1600:	81 e0       	ldi	r24, 0x01	; 1
    1602:	0c c0       	rjmp	.+24     	; 0x161c <ESP_OPEN_SOCKET+0x82>
		}
	} while (RECIVE_TEMP_DATA[0]!='\n');
    1604:	8a 30       	cpi	r24, 0x0A	; 10
    1606:	81 f7       	brne	.-32     	; 0x15e8 <ESP_OPEN_SOCKET+0x4e>
	TEST=ESP_CHECK_OK_RESP();
    1608:	0c de       	rcall	.-1000   	; 0x1222 <ESP_CHECK_OK_RESP>
    160a:	18 2f       	mov	r17, r24
	if (TEST)
    160c:	88 23       	and	r24, r24
    160e:	31 f0       	breq	.+12     	; 0x161c <ESP_OPEN_SOCKET+0x82>
	{
		TEST_UART_SEND_str("OKKKK\n");
    1610:	8c ec       	ldi	r24, 0xCC	; 204
    1612:	91 e0       	ldi	r25, 0x01	; 1
    1614:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
		return TEST;
    1618:	81 2f       	mov	r24, r17
    161a:	00 c0       	rjmp	.+0      	; 0x161c <ESP_OPEN_SOCKET+0x82>
	}
	return 0;//done
}
    161c:	0f 90       	pop	r0
    161e:	0f 90       	pop	r0
    1620:	df 91       	pop	r29
    1622:	cf 91       	pop	r28
    1624:	1f 91       	pop	r17
    1626:	08 95       	ret

00001628 <ESP_SEND_WRITE_HTTP_DATA>:



unsigned char ESP_SEND_WRITE_HTTP_DATA(unsigned char *API_WRITE_KEY,unsigned char API_WRITE_KEY_LENGTH,unsigned char FIELD_NUM,unsigned char *DATA,unsigned char DATA_LENGTH)
{
    1628:	9f 92       	push	r9
    162a:	af 92       	push	r10
    162c:	bf 92       	push	r11
    162e:	cf 92       	push	r12
    1630:	df 92       	push	r13
    1632:	ef 92       	push	r14
    1634:	ff 92       	push	r15
    1636:	0f 93       	push	r16
    1638:	1f 93       	push	r17
    163a:	cf 93       	push	r28
    163c:	df 93       	push	r29
    163e:	cd b7       	in	r28, 0x3d	; 61
    1640:	de b7       	in	r29, 0x3e	; 62
    1642:	27 97       	sbiw	r28, 0x07	; 7
    1644:	0f b6       	in	r0, 0x3f	; 63
    1646:	f8 94       	cli
    1648:	de bf       	out	0x3e, r29	; 62
    164a:	0f be       	out	0x3f, r0	; 63
    164c:	cd bf       	out	0x3d, r28	; 61
    164e:	6c 01       	movw	r12, r24
    1650:	a6 2e       	mov	r10, r22
    1652:	94 2e       	mov	r9, r20
    1654:	79 01       	movw	r14, r18
    1656:	b0 2e       	mov	r11, r16
	unsigned char TOTAL_LENGTH;
	unsigned char TEMP[5];
	unsigned char TEMP_length;
	unsigned char FIELD_NUM_LENGTH;
	unsigned char TEST;
	FIELD_NUM_LENGTH=inttostring(TEMP,FIELD_NUM);
    1658:	04 2f       	mov	r16, r20
    165a:	10 e0       	ldi	r17, 0x00	; 0
    165c:	20 e0       	ldi	r18, 0x00	; 0
    165e:	30 e0       	ldi	r19, 0x00	; 0
    1660:	40 e0       	ldi	r20, 0x00	; 0
    1662:	50 e0       	ldi	r21, 0x00	; 0
    1664:	60 e0       	ldi	r22, 0x00	; 0
    1666:	70 e0       	ldi	r23, 0x00	; 0
    1668:	ce 01       	movw	r24, r28
    166a:	01 96       	adiw	r24, 0x01	; 1
    166c:	29 d2       	rcall	.+1106   	; 0x1ac0 <inttostring>
	TOTAL_LENGTH=20+API_WRITE_KEY_LENGTH+6+FIELD_NUM_LENGTH+1+DATA_LENGTH+2;
    166e:	0d e1       	ldi	r16, 0x1D	; 29
    1670:	0b 0d       	add	r16, r11
    1672:	0a 0d       	add	r16, r10
    1674:	08 0f       	add	r16, r24
	TEMP_length=inttostring(TEMP,TOTAL_LENGTH);
    1676:	20 e0       	ldi	r18, 0x00	; 0
    1678:	30 e0       	ldi	r19, 0x00	; 0
    167a:	40 e0       	ldi	r20, 0x00	; 0
    167c:	50 e0       	ldi	r21, 0x00	; 0
    167e:	60 e0       	ldi	r22, 0x00	; 0
    1680:	70 e0       	ldi	r23, 0x00	; 0
    1682:	ce 01       	movw	r24, r28
    1684:	01 96       	adiw	r24, 0x01	; 1
    1686:	1c d2       	rcall	.+1080   	; 0x1ac0 <inttostring>
    1688:	18 2f       	mov	r17, r24
	ESP_UART_EMPTY_BUFFER();
    168a:	61 e0       	ldi	r22, 0x01	; 1
    168c:	70 e0       	ldi	r23, 0x00	; 0
    168e:	ce 01       	movw	r24, r28
    1690:	07 96       	adiw	r24, 0x07	; 7
    1692:	7d dd       	rcall	.-1286   	; 0x118e <ESP_UART_RECIVE_BYTE>
    1694:	9f 81       	ldd	r25, Y+7	; 0x07
    1696:	91 11       	cpse	r25, r1
    1698:	f8 cf       	rjmp	.-16     	; 0x168a <ESP_SEND_WRITE_HTTP_DATA+0x62>
	
	ESP_UART_SEND_ARRAY("AT+CIPSEND=",11);
    169a:	6b e0       	ldi	r22, 0x0B	; 11
    169c:	83 ed       	ldi	r24, 0xD3	; 211
    169e:	91 e0       	ldi	r25, 0x01	; 1
    16a0:	62 dd       	rcall	.-1340   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY(TEMP,TEMP_length);
    16a2:	61 2f       	mov	r22, r17
    16a4:	ce 01       	movw	r24, r28
    16a6:	01 96       	adiw	r24, 0x01	; 1
    16a8:	5e dd       	rcall	.-1348   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY("\r\n",2);
    16aa:	62 e0       	ldi	r22, 0x02	; 2
    16ac:	83 e9       	ldi	r24, 0x93	; 147
    16ae:	91 e0       	ldi	r25, 0x01	; 1
    16b0:	5a dd       	rcall	.-1356   	; 0x1166 <ESP_UART_SEND_ARRAY>
	TEST=ESP_CHECK_OK_RESP();
    16b2:	b7 dd       	rcall	.-1170   	; 0x1222 <ESP_CHECK_OK_RESP>
	if (TEST)
    16b4:	81 11       	cpse	r24, r1
    16b6:	36 c0       	rjmp	.+108    	; 0x1724 <ESP_SEND_WRITE_HTTP_DATA+0xfc>
	{
		/*put for loop*/
		return TEST;
	}
	TEST=ESP_READ_CHAR_AND_CHECK('>');
    16b8:	8e e3       	ldi	r24, 0x3E	; 62
    16ba:	98 dd       	rcall	.-1232   	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
	if (TEST)
    16bc:	81 11       	cpse	r24, r1
    16be:	32 c0       	rjmp	.+100    	; 0x1724 <ESP_SEND_WRITE_HTTP_DATA+0xfc>
	{
		return TEST;
	}
	
	FIELD_NUM_LENGTH=inttostring(TEMP,FIELD_NUM);
    16c0:	09 2d       	mov	r16, r9
    16c2:	10 e0       	ldi	r17, 0x00	; 0
    16c4:	20 e0       	ldi	r18, 0x00	; 0
    16c6:	30 e0       	ldi	r19, 0x00	; 0
    16c8:	40 e0       	ldi	r20, 0x00	; 0
    16ca:	50 e0       	ldi	r21, 0x00	; 0
    16cc:	60 e0       	ldi	r22, 0x00	; 0
    16ce:	70 e0       	ldi	r23, 0x00	; 0
    16d0:	ce 01       	movw	r24, r28
    16d2:	01 96       	adiw	r24, 0x01	; 1
    16d4:	f5 d1       	rcall	.+1002   	; 0x1ac0 <inttostring>
    16d6:	18 2f       	mov	r17, r24
	ESP_UART_SEND_ARRAY("GET /update?api_key=",20);
    16d8:	64 e1       	ldi	r22, 0x14	; 20
    16da:	8f ed       	ldi	r24, 0xDF	; 223
    16dc:	91 e0       	ldi	r25, 0x01	; 1
    16de:	43 dd       	rcall	.-1402   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY(API_WRITE_KEY,API_WRITE_KEY_LENGTH);
    16e0:	6a 2d       	mov	r22, r10
    16e2:	c6 01       	movw	r24, r12
    16e4:	40 dd       	rcall	.-1408   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY("&field",6);
    16e6:	66 e0       	ldi	r22, 0x06	; 6
    16e8:	84 ef       	ldi	r24, 0xF4	; 244
    16ea:	91 e0       	ldi	r25, 0x01	; 1
    16ec:	3c dd       	rcall	.-1416   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY(TEMP,FIELD_NUM_LENGTH);
    16ee:	61 2f       	mov	r22, r17
    16f0:	ce 01       	movw	r24, r28
    16f2:	01 96       	adiw	r24, 0x01	; 1
    16f4:	38 dd       	rcall	.-1424   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_BYTE('=');
    16f6:	8d e3       	ldi	r24, 0x3D	; 61
    16f8:	27 dd       	rcall	.-1458   	; 0x1148 <ESP_UART_SEND_BYTE>
	ESP_UART_SEND_ARRAY(DATA,DATA_LENGTH);	
    16fa:	6b 2d       	mov	r22, r11
    16fc:	c7 01       	movw	r24, r14
    16fe:	33 dd       	rcall	.-1434   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY("\r\n",2);	
    1700:	62 e0       	ldi	r22, 0x02	; 2
    1702:	83 e9       	ldi	r24, 0x93	; 147
    1704:	91 e0       	ldi	r25, 0x01	; 1
    1706:	2f dd       	rcall	.-1442   	; 0x1166 <ESP_UART_SEND_ARRAY>
	/*ESCAPE*/
	vTaskDelay(pdMS_TO_TICKS(100));
    1708:	6a e0       	ldi	r22, 0x0A	; 10
    170a:	70 e0       	ldi	r23, 0x00	; 0
    170c:	80 e0       	ldi	r24, 0x00	; 0
    170e:	90 e0       	ldi	r25, 0x00	; 0
    1710:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
	ESP_UART_EMPTY_BUFFER();
    1714:	61 e0       	ldi	r22, 0x01	; 1
    1716:	70 e0       	ldi	r23, 0x00	; 0
    1718:	ce 01       	movw	r24, r28
    171a:	06 96       	adiw	r24, 0x06	; 6
    171c:	38 dd       	rcall	.-1424   	; 0x118e <ESP_UART_RECIVE_BYTE>
    171e:	8e 81       	ldd	r24, Y+6	; 0x06
    1720:	81 11       	cpse	r24, r1
    1722:	f8 cf       	rjmp	.-16     	; 0x1714 <ESP_SEND_WRITE_HTTP_DATA+0xec>
	
	return 0;//done
}
    1724:	27 96       	adiw	r28, 0x07	; 7
    1726:	0f b6       	in	r0, 0x3f	; 63
    1728:	f8 94       	cli
    172a:	de bf       	out	0x3e, r29	; 62
    172c:	0f be       	out	0x3f, r0	; 63
    172e:	cd bf       	out	0x3d, r28	; 61
    1730:	df 91       	pop	r29
    1732:	cf 91       	pop	r28
    1734:	1f 91       	pop	r17
    1736:	0f 91       	pop	r16
    1738:	ff 90       	pop	r15
    173a:	ef 90       	pop	r14
    173c:	df 90       	pop	r13
    173e:	cf 90       	pop	r12
    1740:	bf 90       	pop	r11
    1742:	af 90       	pop	r10
    1744:	9f 90       	pop	r9
    1746:	08 95       	ret

00001748 <ESP_WRITE_HTTP>:
}



unsigned char ESP_WRITE_HTTP(unsigned char *API_WRITE_KEY,unsigned char API_WRITE_KEY_LENGTH,unsigned char FIELD_NUM,unsigned char *DATA,unsigned char DATA_LENGTH)
{
    1748:	bf 92       	push	r11
    174a:	cf 92       	push	r12
    174c:	df 92       	push	r13
    174e:	ef 92       	push	r14
    1750:	ff 92       	push	r15
    1752:	0f 93       	push	r16
    1754:	1f 93       	push	r17
    1756:	cf 93       	push	r28
    1758:	df 93       	push	r29
    175a:	1f 92       	push	r1
    175c:	cd b7       	in	r28, 0x3d	; 61
    175e:	de b7       	in	r29, 0x3e	; 62
    1760:	6c 01       	movw	r12, r24
    1762:	16 2f       	mov	r17, r22
    1764:	b4 2e       	mov	r11, r20
    1766:	79 01       	movw	r14, r18
	unsigned char test,test2;
	test=ESP_AT_COMMAND();
    1768:	96 dd       	rcall	.-1236   	; 0x1296 <ESP_AT_COMMAND>
	if (test)
    176a:	81 11       	cpse	r24, r1
    176c:	16 c0       	rjmp	.+44     	; 0x179a <ESP_WRITE_HTTP+0x52>
	{
		return test;
	}
	test=ESP_CIPSTATUS(&test2);
    176e:	ce 01       	movw	r24, r28
    1770:	01 96       	adiw	r24, 0x01	; 1
    1772:	36 de       	rcall	.-916    	; 0x13e0 <ESP_CIPSTATUS>
	if (test)
    1774:	81 11       	cpse	r24, r1
    1776:	11 c0       	rjmp	.+34     	; 0x179a <ESP_WRITE_HTTP+0x52>
	{
		return test;
	}
	
	if (test2==5)
    1778:	89 81       	ldd	r24, Y+1	; 0x01
    177a:	85 30       	cpi	r24, 0x05	; 5
    177c:	59 f0       	breq	.+22     	; 0x1794 <ESP_WRITE_HTTP+0x4c>
	{
		return 4;// not connected
	}
	if (test2==3)
    177e:	83 30       	cpi	r24, 0x03	; 3
    1780:	59 f0       	breq	.+22     	; 0x1798 <ESP_WRITE_HTTP+0x50>
	{
		return 5;// tcp connected
	}
	test=ESP_OPEN_SOCKET();
    1782:	0b df       	rcall	.-490    	; 0x159a <ESP_OPEN_SOCKET>
	if (test)
    1784:	81 11       	cpse	r24, r1
    1786:	09 c0       	rjmp	.+18     	; 0x179a <ESP_WRITE_HTTP+0x52>
	{
		return test;
	}
	test=ESP_SEND_WRITE_HTTP_DATA(API_WRITE_KEY,API_WRITE_KEY_LENGTH,FIELD_NUM,DATA, DATA_LENGTH);
    1788:	97 01       	movw	r18, r14
    178a:	4b 2d       	mov	r20, r11
    178c:	61 2f       	mov	r22, r17
    178e:	c6 01       	movw	r24, r12
    1790:	4b df       	rcall	.-362    	; 0x1628 <ESP_SEND_WRITE_HTTP_DATA>
    1792:	03 c0       	rjmp	.+6      	; 0x179a <ESP_WRITE_HTTP+0x52>
		return test;
	}
	
	if (test2==5)
	{
		return 4;// not connected
    1794:	84 e0       	ldi	r24, 0x04	; 4
    1796:	01 c0       	rjmp	.+2      	; 0x179a <ESP_WRITE_HTTP+0x52>
	}
	if (test2==3)
	{
		return 5;// tcp connected
    1798:	85 e0       	ldi	r24, 0x05	; 5
	{
		return test;
	}
	return 0;//done
	
}
    179a:	0f 90       	pop	r0
    179c:	df 91       	pop	r29
    179e:	cf 91       	pop	r28
    17a0:	1f 91       	pop	r17
    17a2:	0f 91       	pop	r16
    17a4:	ff 90       	pop	r15
    17a6:	ef 90       	pop	r14
    17a8:	df 90       	pop	r13
    17aa:	cf 90       	pop	r12
    17ac:	bf 90       	pop	r11
    17ae:	08 95       	ret

000017b0 <ESP_SEND_READ_HTTP_DATA>:




unsigned char ESP_SEND_READ_HTTP_DATA(unsigned char *CHANNEL_ID,unsigned char CHANNEL_ID_LENGTH,unsigned char FIELD_NUM,ESP_RECIVED_DATA_DT *DATA)
{
    17b0:	6f 92       	push	r6
    17b2:	7f 92       	push	r7
    17b4:	8f 92       	push	r8
    17b6:	9f 92       	push	r9
    17b8:	af 92       	push	r10
    17ba:	bf 92       	push	r11
    17bc:	cf 92       	push	r12
    17be:	df 92       	push	r13
    17c0:	ef 92       	push	r14
    17c2:	ff 92       	push	r15
    17c4:	0f 93       	push	r16
    17c6:	1f 93       	push	r17
    17c8:	cf 93       	push	r28
    17ca:	df 93       	push	r29
    17cc:	cd b7       	in	r28, 0x3d	; 61
    17ce:	de b7       	in	r29, 0x3e	; 62
    17d0:	2c 97       	sbiw	r28, 0x0c	; 12
    17d2:	0f b6       	in	r0, 0x3f	; 63
    17d4:	f8 94       	cli
    17d6:	de bf       	out	0x3e, r29	; 62
    17d8:	0f be       	out	0x3f, r0	; 63
    17da:	cd bf       	out	0x3d, r28	; 61
    17dc:	7c 01       	movw	r14, r24
    17de:	b6 2e       	mov	r11, r22
    17e0:	a4 2e       	mov	r10, r20
    17e2:	69 01       	movw	r12, r18
	unsigned char TEMP_length;
	unsigned char FIELD_NUM_LENGTH;
	unsigned char RECIVE_TEMP_DATA[1];
	unsigned char V,i,k;
	unsigned char TEST;
	FIELD_NUM_LENGTH=inttostring(TEMP,FIELD_NUM);
    17e4:	04 2f       	mov	r16, r20
    17e6:	10 e0       	ldi	r17, 0x00	; 0
    17e8:	20 e0       	ldi	r18, 0x00	; 0
    17ea:	30 e0       	ldi	r19, 0x00	; 0
    17ec:	40 e0       	ldi	r20, 0x00	; 0
    17ee:	50 e0       	ldi	r21, 0x00	; 0
    17f0:	60 e0       	ldi	r22, 0x00	; 0
    17f2:	70 e0       	ldi	r23, 0x00	; 0
    17f4:	ce 01       	movw	r24, r28
    17f6:	01 96       	adiw	r24, 0x01	; 1
    17f8:	63 d1       	rcall	.+710    	; 0x1ac0 <inttostring>
	TOTAL_LENGTH=40+CHANNEL_ID_LENGTH+8+FIELD_NUM_LENGTH+16;
    17fa:	00 e4       	ldi	r16, 0x40	; 64
    17fc:	0b 0d       	add	r16, r11
    17fe:	08 0f       	add	r16, r24
	TEMP_length=inttostring(TEMP,TOTAL_LENGTH);
    1800:	20 e0       	ldi	r18, 0x00	; 0
    1802:	30 e0       	ldi	r19, 0x00	; 0
    1804:	40 e0       	ldi	r20, 0x00	; 0
    1806:	50 e0       	ldi	r21, 0x00	; 0
    1808:	60 e0       	ldi	r22, 0x00	; 0
    180a:	70 e0       	ldi	r23, 0x00	; 0
    180c:	ce 01       	movw	r24, r28
    180e:	01 96       	adiw	r24, 0x01	; 1
    1810:	57 d1       	rcall	.+686    	; 0x1ac0 <inttostring>
    1812:	18 2f       	mov	r17, r24
	ESP_UART_EMPTY_BUFFER();
    1814:	61 e0       	ldi	r22, 0x01	; 1
    1816:	70 e0       	ldi	r23, 0x00	; 0
    1818:	ce 01       	movw	r24, r28
    181a:	0c 96       	adiw	r24, 0x0c	; 12
    181c:	b8 dc       	rcall	.-1680   	; 0x118e <ESP_UART_RECIVE_BYTE>
    181e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1820:	91 11       	cpse	r25, r1
    1822:	f8 cf       	rjmp	.-16     	; 0x1814 <ESP_SEND_READ_HTTP_DATA+0x64>
	ESP_UART_SEND_ARRAY("AT+CIPSEND=",11);
    1824:	6b e0       	ldi	r22, 0x0B	; 11
    1826:	83 ed       	ldi	r24, 0xD3	; 211
    1828:	91 e0       	ldi	r25, 0x01	; 1
    182a:	9d dc       	rcall	.-1734   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY(TEMP,TEMP_length);
    182c:	61 2f       	mov	r22, r17
    182e:	ce 01       	movw	r24, r28
    1830:	01 96       	adiw	r24, 0x01	; 1
    1832:	99 dc       	rcall	.-1742   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY("\r\n",2);
    1834:	62 e0       	ldi	r22, 0x02	; 2
    1836:	83 e9       	ldi	r24, 0x93	; 147
    1838:	91 e0       	ldi	r25, 0x01	; 1
    183a:	95 dc       	rcall	.-1750   	; 0x1166 <ESP_UART_SEND_ARRAY>
	TEST=ESP_CHECK_OK_RESP();
    183c:	f2 dc       	rcall	.-1564   	; 0x1222 <ESP_CHECK_OK_RESP>
	if (TEST)
    183e:	81 11       	cpse	r24, r1
    1840:	dc c0       	rjmp	.+440    	; 0x19fa <ESP_SEND_READ_HTTP_DATA+0x24a>
	{
		/*put for loop*/
		return TEST;
	}
	TEST=ESP_READ_CHAR_AND_CHECK('>');
    1842:	8e e3       	ldi	r24, 0x3E	; 62
    1844:	d3 dc       	rcall	.-1626   	; 0x11ec <ESP_READ_CHAR_AND_CHECK>
	if (TEST)
    1846:	81 11       	cpse	r24, r1
    1848:	da c0       	rjmp	.+436    	; 0x19fe <ESP_SEND_READ_HTTP_DATA+0x24e>
	{
		return TEST;
	}
	
	FIELD_NUM_LENGTH=inttostring(TEMP,FIELD_NUM);
    184a:	0a 2d       	mov	r16, r10
    184c:	10 e0       	ldi	r17, 0x00	; 0
    184e:	20 e0       	ldi	r18, 0x00	; 0
    1850:	30 e0       	ldi	r19, 0x00	; 0
    1852:	40 e0       	ldi	r20, 0x00	; 0
    1854:	50 e0       	ldi	r21, 0x00	; 0
    1856:	60 e0       	ldi	r22, 0x00	; 0
    1858:	70 e0       	ldi	r23, 0x00	; 0
    185a:	ce 01       	movw	r24, r28
    185c:	01 96       	adiw	r24, 0x01	; 1
    185e:	30 d1       	rcall	.+608    	; 0x1ac0 <inttostring>
    1860:	18 2f       	mov	r17, r24
	ESP_UART_SEND_ARRAY("GET https://api.thingspeak.com/channels/" ,40);
    1862:	68 e2       	ldi	r22, 0x28	; 40
    1864:	8b ef       	ldi	r24, 0xFB	; 251
    1866:	91 e0       	ldi	r25, 0x01	; 1
    1868:	7e dc       	rcall	.-1796   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY(CHANNEL_ID,CHANNEL_ID_LENGTH);
    186a:	6b 2d       	mov	r22, r11
    186c:	c7 01       	movw	r24, r14
    186e:	7b dc       	rcall	.-1802   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY("/fields/",8);
    1870:	68 e0       	ldi	r22, 0x08	; 8
    1872:	84 e2       	ldi	r24, 0x24	; 36
    1874:	92 e0       	ldi	r25, 0x02	; 2
    1876:	77 dc       	rcall	.-1810   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY(TEMP,FIELD_NUM_LENGTH);
    1878:	61 2f       	mov	r22, r17
    187a:	ce 01       	movw	r24, r28
    187c:	01 96       	adiw	r24, 0x01	; 1
    187e:	73 dc       	rcall	.-1818   	; 0x1166 <ESP_UART_SEND_ARRAY>
	ESP_UART_SEND_ARRAY(".csv?results=5\r\n",16);
    1880:	60 e1       	ldi	r22, 0x10	; 16
    1882:	8d e2       	ldi	r24, 0x2D	; 45
    1884:	92 e0       	ldi	r25, 0x02	; 2
    1886:	6f dc       	rcall	.-1826   	; 0x1166 <ESP_UART_SEND_ARRAY>
	
	/*vTaskDelay(pdMS_TO_TICKS(300));*/
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    1888:	60 ed       	ldi	r22, 0xD0	; 208
    188a:	77 e0       	ldi	r23, 0x07	; 7
    188c:	ce 01       	movw	r24, r28
    188e:	0b 96       	adiw	r24, 0x0b	; 11
    1890:	7e dc       	rcall	.-1796   	; 0x118e <ESP_UART_RECIVE_BYTE>
		if (V==0)
    1892:	9b 85       	ldd	r25, Y+11	; 0x0b
    1894:	91 11       	cpse	r25, r1
    1896:	07 c0       	rjmp	.+14     	; 0x18a6 <ESP_SEND_READ_HTTP_DATA+0xf6>
		{
			TEST_UART_SEND_str("not hereeeeeeeeeeeeeeeeeeeeeeeee");
    1898:	8e e3       	ldi	r24, 0x3E	; 62
    189a:	92 e0       	ldi	r25, 0x02	; 2
    189c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
			return 1;//WIFI MODULE NOT CONNECTED
    18a0:	99 24       	eor	r9, r9
    18a2:	93 94       	inc	r9
    18a4:	c5 c0       	rjmp	.+394    	; 0x1a30 <ESP_SEND_READ_HTTP_DATA+0x280>
		}
	} while (RECIVE_TEMP_DATA[0]!='+');
    18a6:	8b 32       	cpi	r24, 0x2B	; 43
    18a8:	79 f7       	brne	.-34     	; 0x1888 <ESP_SEND_READ_HTTP_DATA+0xd8>
	
	
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    18aa:	60 ed       	ldi	r22, 0xD0	; 208
    18ac:	77 e0       	ldi	r23, 0x07	; 7
    18ae:	ce 01       	movw	r24, r28
    18b0:	0b 96       	adiw	r24, 0x0b	; 11
    18b2:	6d dc       	rcall	.-1830   	; 0x118e <ESP_UART_RECIVE_BYTE>
		if (V==0)
    18b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    18b6:	99 23       	and	r25, r25
    18b8:	09 f4       	brne	.+2      	; 0x18bc <ESP_SEND_READ_HTTP_DATA+0x10c>
    18ba:	a3 c0       	rjmp	.+326    	; 0x1a02 <ESP_SEND_READ_HTTP_DATA+0x252>
		{
			return 1;//WIFI MODULE NOT CONNECTED
		}
	} while (RECIVE_TEMP_DATA[0]!='\n');
    18bc:	8a 30       	cpi	r24, 0x0A	; 10
    18be:	a9 f7       	brne	.-22     	; 0x18aa <ESP_SEND_READ_HTTP_DATA+0xfa>
    18c0:	56 01       	movw	r10, r12
    18c2:	68 94       	set
    18c4:	99 24       	eor	r9, r9
    18c6:	92 f8       	bld	r9, 2
			RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
			if (V==0)
			{
				return 1;//WIFI MODULE NOT CONNECTED
			}
			DATA[i].DATA_ELEMENT[k]=RECIVE_TEMP_DATA[0];
    18c8:	71 2c       	mov	r7, r1
    18ca:	81 2c       	mov	r8, r1
	
	for (i=0;i<4;i++)
	{	/*TIME i*/
		do
		{
			RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    18cc:	60 ed       	ldi	r22, 0xD0	; 208
    18ce:	77 e0       	ldi	r23, 0x07	; 7
    18d0:	ce 01       	movw	r24, r28
    18d2:	0b 96       	adiw	r24, 0x0b	; 11
    18d4:	5c dc       	rcall	.-1864   	; 0x118e <ESP_UART_RECIVE_BYTE>
			if (V==0)
    18d6:	9b 85       	ldd	r25, Y+11	; 0x0b
    18d8:	99 23       	and	r25, r25
    18da:	09 f4       	brne	.+2      	; 0x18de <ESP_SEND_READ_HTTP_DATA+0x12e>
    18dc:	95 c0       	rjmp	.+298    	; 0x1a08 <ESP_SEND_READ_HTTP_DATA+0x258>
			{
				return 1;//WIFI MODULE NOT CONNECTED
			}
		} while (RECIVE_TEMP_DATA[0]!=',');
    18de:	8c 32       	cpi	r24, 0x2C	; 44
    18e0:	a9 f7       	brne	.-22     	; 0x18cc <ESP_SEND_READ_HTTP_DATA+0x11c>
		/*ENTRY I*/
		do
		{
			RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    18e2:	60 ed       	ldi	r22, 0xD0	; 208
    18e4:	77 e0       	ldi	r23, 0x07	; 7
    18e6:	ce 01       	movw	r24, r28
    18e8:	0b 96       	adiw	r24, 0x0b	; 11
    18ea:	51 dc       	rcall	.-1886   	; 0x118e <ESP_UART_RECIVE_BYTE>
			if (V==0)
    18ec:	9b 85       	ldd	r25, Y+11	; 0x0b
    18ee:	99 23       	and	r25, r25
    18f0:	09 f4       	brne	.+2      	; 0x18f4 <ESP_SEND_READ_HTTP_DATA+0x144>
    18f2:	8d c0       	rjmp	.+282    	; 0x1a0e <ESP_SEND_READ_HTTP_DATA+0x25e>
			{
				return 1;//WIFI MODULE NOT CONNECTED
			}
		} while (RECIVE_TEMP_DATA[0]!=',');
    18f4:	8c 32       	cpi	r24, 0x2C	; 44
    18f6:	a9 f7       	brne	.-22     	; 0x18e2 <ESP_SEND_READ_HTTP_DATA+0x132>
			RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
			if (V==0)
			{
				return 1;//WIFI MODULE NOT CONNECTED
			}
			DATA[i].DATA_ELEMENT[k]=RECIVE_TEMP_DATA[0];
    18f8:	85 01       	movw	r16, r10
    18fa:	e7 2c       	mov	r14, r7
    18fc:	f8 2c       	mov	r15, r8
    18fe:	6e 2c       	mov	r6, r14
		/*DATA i*/
		k=0;
		do
		{
			
			RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    1900:	60 ed       	ldi	r22, 0xD0	; 208
    1902:	77 e0       	ldi	r23, 0x07	; 7
    1904:	ce 01       	movw	r24, r28
    1906:	0b 96       	adiw	r24, 0x0b	; 11
    1908:	42 dc       	rcall	.-1916   	; 0x118e <ESP_UART_RECIVE_BYTE>
			if (V==0)
    190a:	9b 85       	ldd	r25, Y+11	; 0x0b
    190c:	99 23       	and	r25, r25
    190e:	09 f4       	brne	.+2      	; 0x1912 <ESP_SEND_READ_HTTP_DATA+0x162>
    1910:	81 c0       	rjmp	.+258    	; 0x1a14 <ESP_SEND_READ_HTTP_DATA+0x264>
			{
				return 1;//WIFI MODULE NOT CONNECTED
			}
			DATA[i].DATA_ELEMENT[k]=RECIVE_TEMP_DATA[0];
    1912:	f8 01       	movw	r30, r16
    1914:	ee 0d       	add	r30, r14
    1916:	ff 1d       	adc	r31, r15
    1918:	80 83       	st	Z, r24
			++k;
			if (k>MAX_CHAR_DATA)
    191a:	9e e1       	ldi	r25, 0x1E	; 30
    191c:	e9 16       	cp	r14, r25
    191e:	f1 04       	cpc	r15, r1
    1920:	29 f0       	breq	.+10     	; 0x192c <ESP_SEND_READ_HTTP_DATA+0x17c>
    1922:	ef ef       	ldi	r30, 0xFF	; 255
    1924:	ee 1a       	sub	r14, r30
    1926:	fe 0a       	sbc	r15, r30
			{
				break;
			}
		} while (RECIVE_TEMP_DATA[0]!='\n');
    1928:	8a 30       	cpi	r24, 0x0A	; 10
    192a:	49 f7       	brne	.-46     	; 0x18fe <ESP_SEND_READ_HTTP_DATA+0x14e>
		DATA[i].length=k-1;
    192c:	f8 01       	movw	r30, r16
    192e:	66 8e       	std	Z+30, r6	; 0x1e
    1930:	9a 94       	dec	r9
    1932:	ff e1       	ldi	r31, 0x1F	; 31
    1934:	af 0e       	add	r10, r31
    1936:	b1 1c       	adc	r11, r1
	
	
	
	
	
	for (i=0;i<4;i++)
    1938:	91 10       	cpse	r9, r1
    193a:	c8 cf       	rjmp	.-112    	; 0x18cc <ESP_SEND_READ_HTTP_DATA+0x11c>

	}
	/*TIME 4*/
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    193c:	60 ed       	ldi	r22, 0xD0	; 208
    193e:	77 e0       	ldi	r23, 0x07	; 7
    1940:	ce 01       	movw	r24, r28
    1942:	0b 96       	adiw	r24, 0x0b	; 11
    1944:	24 dc       	rcall	.-1976   	; 0x118e <ESP_UART_RECIVE_BYTE>
		if (V==0)
    1946:	9b 85       	ldd	r25, Y+11	; 0x0b
    1948:	99 23       	and	r25, r25
    194a:	09 f4       	brne	.+2      	; 0x194e <ESP_SEND_READ_HTTP_DATA+0x19e>
    194c:	66 c0       	rjmp	.+204    	; 0x1a1a <ESP_SEND_READ_HTTP_DATA+0x26a>
		{
			return 1;//WIFI MODULE NOT CONNECTED
		}
	} while (RECIVE_TEMP_DATA[0]!=',');
    194e:	8c 32       	cpi	r24, 0x2C	; 44
    1950:	a9 f7       	brne	.-22     	; 0x193c <ESP_SEND_READ_HTTP_DATA+0x18c>
    1952:	10 e0       	ldi	r17, 0x00	; 0
	
	k=0;
	/*LAST ENTRY*/
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    1954:	60 ed       	ldi	r22, 0xD0	; 208
    1956:	77 e0       	ldi	r23, 0x07	; 7
    1958:	ce 01       	movw	r24, r28
    195a:	0b 96       	adiw	r24, 0x0b	; 11
    195c:	18 dc       	rcall	.-2000   	; 0x118e <ESP_UART_RECIVE_BYTE>
		if (V==0)
    195e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1960:	99 23       	and	r25, r25
    1962:	09 f4       	brne	.+2      	; 0x1966 <ESP_SEND_READ_HTTP_DATA+0x1b6>
    1964:	5d c0       	rjmp	.+186    	; 0x1a20 <ESP_SEND_READ_HTTP_DATA+0x270>
		{
			return 1;//WIFI MODULE NOT CONNECTED
		}
		TEMP[k]=RECIVE_TEMP_DATA[0];
    1966:	e1 e0       	ldi	r30, 0x01	; 1
    1968:	f0 e0       	ldi	r31, 0x00	; 0
    196a:	ec 0f       	add	r30, r28
    196c:	fd 1f       	adc	r31, r29
    196e:	e1 0f       	add	r30, r17
    1970:	f1 1d       	adc	r31, r1
    1972:	80 83       	st	Z, r24
		++k;
    1974:	91 e0       	ldi	r25, 0x01	; 1
    1976:	91 0f       	add	r25, r17
		if (k>10)
    1978:	9b 30       	cpi	r25, 0x0B	; 11
    197a:	08 f4       	brcc	.+2      	; 0x197e <ESP_SEND_READ_HTTP_DATA+0x1ce>
		if (V==0)
		{
			return 1;//WIFI MODULE NOT CONNECTED
		}
		TEMP[k]=RECIVE_TEMP_DATA[0];
		++k;
    197c:	19 2f       	mov	r17, r25
		if (k>10)
		{
			k--;
		}
	} while (RECIVE_TEMP_DATA[0]!=',');
    197e:	8c 32       	cpi	r24, 0x2C	; 44
    1980:	49 f7       	brne	.-46     	; 0x1954 <ESP_SEND_READ_HTTP_DATA+0x1a4>
	
	NEW_LAST_ENTRY=STRINGTOINT(TEMP,k-1);
    1982:	6f ef       	ldi	r22, 0xFF	; 255
    1984:	61 0f       	add	r22, r17
    1986:	ce 01       	movw	r24, r28
    1988:	01 96       	adiw	r24, 0x01	; 1
    198a:	6b d2       	rcall	.+1238   	; 0x1e62 <STRINGTOINT>
    198c:	84 2f       	mov	r24, r20
    198e:	95 2f       	mov	r25, r21
    1990:	42 2f       	mov	r20, r18
    1992:	53 2f       	mov	r21, r19
    1994:	68 2f       	mov	r22, r24
    1996:	79 2f       	mov	r23, r25
    1998:	40 93 b3 0c 	sts	0x0CB3, r20
    199c:	50 93 b4 0c 	sts	0x0CB4, r21
    19a0:	60 93 b5 0c 	sts	0x0CB5, r22
    19a4:	70 93 b6 0c 	sts	0x0CB6, r23
    19a8:	00 e0       	ldi	r16, 0x00	; 0
    19aa:	10 e0       	ldi	r17, 0x00	; 0
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
		if (V==0)
		{
			return 1;//WIFI MODULE NOT CONNECTED
		}
		DATA[4].DATA_ELEMENT[k]=RECIVE_TEMP_DATA[0];
    19ac:	76 01       	movw	r14, r12
    19ae:	8c e7       	ldi	r24, 0x7C	; 124
    19b0:	e8 0e       	add	r14, r24
    19b2:	f1 1c       	adc	r15, r1
    19b4:	b0 2e       	mov	r11, r16
	k=0;
	/*DATA 4*/
	do
	{
		
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    19b6:	60 ed       	ldi	r22, 0xD0	; 208
    19b8:	77 e0       	ldi	r23, 0x07	; 7
    19ba:	ce 01       	movw	r24, r28
    19bc:	0b 96       	adiw	r24, 0x0b	; 11
    19be:	e7 db       	rcall	.-2098   	; 0x118e <ESP_UART_RECIVE_BYTE>
		if (V==0)
    19c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    19c2:	99 23       	and	r25, r25
    19c4:	81 f1       	breq	.+96     	; 0x1a26 <ESP_SEND_READ_HTTP_DATA+0x276>
		{
			return 1;//WIFI MODULE NOT CONNECTED
		}
		DATA[4].DATA_ELEMENT[k]=RECIVE_TEMP_DATA[0];
    19c6:	f7 01       	movw	r30, r14
    19c8:	e0 0f       	add	r30, r16
    19ca:	f1 1f       	adc	r31, r17
    19cc:	80 83       	st	Z, r24
		++k;
		if (k>MAX_CHAR_DATA)
    19ce:	0e 31       	cpi	r16, 0x1E	; 30
    19d0:	11 05       	cpc	r17, r1
    19d2:	21 f0       	breq	.+8      	; 0x19dc <ESP_SEND_READ_HTTP_DATA+0x22c>
    19d4:	0f 5f       	subi	r16, 0xFF	; 255
    19d6:	1f 4f       	sbci	r17, 0xFF	; 255
		{
			break;
		}
	} while (RECIVE_TEMP_DATA[0]!='\n');
    19d8:	8a 30       	cpi	r24, 0x0A	; 10
    19da:	61 f7       	brne	.-40     	; 0x19b4 <ESP_SEND_READ_HTTP_DATA+0x204>
	DATA[4].length=k-1;
    19dc:	f6 01       	movw	r30, r12
    19de:	e4 58       	subi	r30, 0x84	; 132
    19e0:	ff 4f       	sbci	r31, 0xFF	; 255
    19e2:	b6 8e       	std	Z+30, r11	; 0x1e

	/*CLOSED\r\n*/
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
    19e4:	60 ed       	ldi	r22, 0xD0	; 208
    19e6:	77 e0       	ldi	r23, 0x07	; 7
    19e8:	ce 01       	movw	r24, r28
    19ea:	0b 96       	adiw	r24, 0x0b	; 11
    19ec:	d0 db       	rcall	.-2144   	; 0x118e <ESP_UART_RECIVE_BYTE>
		if (V==0)
    19ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    19f0:	99 23       	and	r25, r25
    19f2:	e1 f0       	breq	.+56     	; 0x1a2c <ESP_SEND_READ_HTTP_DATA+0x27c>
		{
			return 1;//WIFI MODULE NOT CONNECTED
		}
	} while (RECIVE_TEMP_DATA[0]!='\n');
    19f4:	8a 30       	cpi	r24, 0x0A	; 10
    19f6:	b1 f7       	brne	.-20     	; 0x19e4 <ESP_SEND_READ_HTTP_DATA+0x234>
    19f8:	1b c0       	rjmp	.+54     	; 0x1a30 <ESP_SEND_READ_HTTP_DATA+0x280>
	ESP_UART_SEND_ARRAY("\r\n",2);
	TEST=ESP_CHECK_OK_RESP();
	if (TEST)
	{
		/*put for loop*/
		return TEST;
    19fa:	98 2e       	mov	r9, r24
    19fc:	19 c0       	rjmp	.+50     	; 0x1a30 <ESP_SEND_READ_HTTP_DATA+0x280>
	}
	TEST=ESP_READ_CHAR_AND_CHECK('>');
	if (TEST)
	{
		return TEST;
    19fe:	98 2e       	mov	r9, r24
    1a00:	17 c0       	rjmp	.+46     	; 0x1a30 <ESP_SEND_READ_HTTP_DATA+0x280>
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
		if (V==0)
		{
			return 1;//WIFI MODULE NOT CONNECTED
    1a02:	99 24       	eor	r9, r9
    1a04:	93 94       	inc	r9
    1a06:	14 c0       	rjmp	.+40     	; 0x1a30 <ESP_SEND_READ_HTTP_DATA+0x280>
		do
		{
			RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
			if (V==0)
			{
				return 1;//WIFI MODULE NOT CONNECTED
    1a08:	99 24       	eor	r9, r9
    1a0a:	93 94       	inc	r9
    1a0c:	11 c0       	rjmp	.+34     	; 0x1a30 <ESP_SEND_READ_HTTP_DATA+0x280>
		do
		{
			RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
			if (V==0)
			{
				return 1;//WIFI MODULE NOT CONNECTED
    1a0e:	99 24       	eor	r9, r9
    1a10:	93 94       	inc	r9
    1a12:	0e c0       	rjmp	.+28     	; 0x1a30 <ESP_SEND_READ_HTTP_DATA+0x280>
		{
			
			RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
			if (V==0)
			{
				return 1;//WIFI MODULE NOT CONNECTED
    1a14:	99 24       	eor	r9, r9
    1a16:	93 94       	inc	r9
    1a18:	0b c0       	rjmp	.+22     	; 0x1a30 <ESP_SEND_READ_HTTP_DATA+0x280>
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
		if (V==0)
		{
			return 1;//WIFI MODULE NOT CONNECTED
    1a1a:	99 24       	eor	r9, r9
    1a1c:	93 94       	inc	r9
    1a1e:	08 c0       	rjmp	.+16     	; 0x1a30 <ESP_SEND_READ_HTTP_DATA+0x280>
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
		if (V==0)
		{
			return 1;//WIFI MODULE NOT CONNECTED
    1a20:	99 24       	eor	r9, r9
    1a22:	93 94       	inc	r9
    1a24:	05 c0       	rjmp	.+10     	; 0x1a30 <ESP_SEND_READ_HTTP_DATA+0x280>
	{
		
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
		if (V==0)
		{
			return 1;//WIFI MODULE NOT CONNECTED
    1a26:	99 24       	eor	r9, r9
    1a28:	93 94       	inc	r9
    1a2a:	02 c0       	rjmp	.+4      	; 0x1a30 <ESP_SEND_READ_HTTP_DATA+0x280>
	do
	{
		RECIVE_TEMP_DATA[0]=ESP_UART_RECIVE_BYTE(&V, ESP_UART_COUNT_RECIVER1);
		if (V==0)
		{
			return 1;//WIFI MODULE NOT CONNECTED
    1a2c:	99 24       	eor	r9, r9
    1a2e:	93 94       	inc	r9
		}
	} while (RECIVE_TEMP_DATA[0]!='\n');
	
	return 0;//done
}
    1a30:	89 2d       	mov	r24, r9
    1a32:	2c 96       	adiw	r28, 0x0c	; 12
    1a34:	0f b6       	in	r0, 0x3f	; 63
    1a36:	f8 94       	cli
    1a38:	de bf       	out	0x3e, r29	; 62
    1a3a:	0f be       	out	0x3f, r0	; 63
    1a3c:	cd bf       	out	0x3d, r28	; 61
    1a3e:	df 91       	pop	r29
    1a40:	cf 91       	pop	r28
    1a42:	1f 91       	pop	r17
    1a44:	0f 91       	pop	r16
    1a46:	ff 90       	pop	r15
    1a48:	ef 90       	pop	r14
    1a4a:	df 90       	pop	r13
    1a4c:	cf 90       	pop	r12
    1a4e:	bf 90       	pop	r11
    1a50:	af 90       	pop	r10
    1a52:	9f 90       	pop	r9
    1a54:	8f 90       	pop	r8
    1a56:	7f 90       	pop	r7
    1a58:	6f 90       	pop	r6
    1a5a:	08 95       	ret

00001a5c <ESP_READ_HTTP>:


unsigned char ESP_READ_HTTP(unsigned char *CHANNEL_ID,unsigned char CHANNEL_ID_LENGTH,unsigned char FIELD_NUM,ESP_RECIVED_DATA_DT *DATA)
{
    1a5c:	cf 92       	push	r12
    1a5e:	df 92       	push	r13
    1a60:	ef 92       	push	r14
    1a62:	ff 92       	push	r15
    1a64:	0f 93       	push	r16
    1a66:	1f 93       	push	r17
    1a68:	cf 93       	push	r28
    1a6a:	df 93       	push	r29
    1a6c:	1f 92       	push	r1
    1a6e:	cd b7       	in	r28, 0x3d	; 61
    1a70:	de b7       	in	r29, 0x3e	; 62
    1a72:	7c 01       	movw	r14, r24
    1a74:	d6 2e       	mov	r13, r22
    1a76:	c4 2e       	mov	r12, r20
    1a78:	89 01       	movw	r16, r18
	unsigned char test,test2;
	test=ESP_AT_COMMAND();
    1a7a:	0d dc       	rcall	.-2022   	; 0x1296 <ESP_AT_COMMAND>
	if (test)
    1a7c:	81 11       	cpse	r24, r1
    1a7e:	16 c0       	rjmp	.+44     	; 0x1aac <ESP_READ_HTTP+0x50>
	{
		/*TEST_UART_SEND_str("AT READ\n");*/
		return test;
	}
	test=ESP_CIPSTATUS(&test2);
    1a80:	ce 01       	movw	r24, r28
    1a82:	01 96       	adiw	r24, 0x01	; 1
    1a84:	ad dc       	rcall	.-1702   	; 0x13e0 <ESP_CIPSTATUS>
	if (test)
    1a86:	81 11       	cpse	r24, r1
    1a88:	11 c0       	rjmp	.+34     	; 0x1aac <ESP_READ_HTTP+0x50>
	{
		/*TEST_UART_SEND_str("AT STATUS\n");*/
		return test;
	}
	
	if (test2==5)
    1a8a:	89 81       	ldd	r24, Y+1	; 0x01
    1a8c:	85 30       	cpi	r24, 0x05	; 5
    1a8e:	59 f0       	breq	.+22     	; 0x1aa6 <ESP_READ_HTTP+0x4a>
	{
		/*TEST_UART_SEND_str("NOT CONNECTED STATUS\n");*/
		return 4;// not connected
	}
	if (test2==3)
    1a90:	83 30       	cpi	r24, 0x03	; 3
    1a92:	59 f0       	breq	.+22     	; 0x1aaa <ESP_READ_HTTP+0x4e>
	{
		/*TEST_UART_SEND_str("CONNECTED STATUS\n");*/
		return 5;// tcp connected
	}
	/*TEST_UART_SEND_str("PASSED\n");*/
	test=ESP_OPEN_SOCKET();
    1a94:	82 dd       	rcall	.-1276   	; 0x159a <ESP_OPEN_SOCKET>
	if (test)
    1a96:	81 11       	cpse	r24, r1
    1a98:	09 c0       	rjmp	.+18     	; 0x1aac <ESP_READ_HTTP+0x50>
	{
		/*TEST_UART_SEND_str("OPEN SOCKET\n");*/
		return test;
	}
	/*TEST_UART_SEND_str("PASSED\n");*/
	test=ESP_SEND_READ_HTTP_DATA(CHANNEL_ID, CHANNEL_ID_LENGTH,FIELD_NUM,DATA);
    1a9a:	98 01       	movw	r18, r16
    1a9c:	4c 2d       	mov	r20, r12
    1a9e:	6d 2d       	mov	r22, r13
    1aa0:	c7 01       	movw	r24, r14
    1aa2:	86 de       	rcall	.-756    	; 0x17b0 <ESP_SEND_READ_HTTP_DATA>
    1aa4:	03 c0       	rjmp	.+6      	; 0x1aac <ESP_READ_HTTP+0x50>
	}
	
	if (test2==5)
	{
		/*TEST_UART_SEND_str("NOT CONNECTED STATUS\n");*/
		return 4;// not connected
    1aa6:	84 e0       	ldi	r24, 0x04	; 4
    1aa8:	01 c0       	rjmp	.+2      	; 0x1aac <ESP_READ_HTTP+0x50>
	}
	if (test2==3)
	{
		/*TEST_UART_SEND_str("CONNECTED STATUS\n");*/
		return 5;// tcp connected
    1aaa:	85 e0       	ldi	r24, 0x05	; 5
	{
		/*TEST_UART_SEND_str("failed here\n");*/
		return test;
	}
	return 0;//done
}
    1aac:	0f 90       	pop	r0
    1aae:	df 91       	pop	r29
    1ab0:	cf 91       	pop	r28
    1ab2:	1f 91       	pop	r17
    1ab4:	0f 91       	pop	r16
    1ab6:	ff 90       	pop	r15
    1ab8:	ef 90       	pop	r14
    1aba:	df 90       	pop	r13
    1abc:	cf 90       	pop	r12
    1abe:	08 95       	ret

00001ac0 <inttostring>:
 * Created: 9/1/2020 12:42:54 PM
 *  Author: ideapad510
 */ 
#include "minohelper.h"
unsigned char inttostring(unsigned char * the_return,long long thenumber)
{
    1ac0:	2f 92       	push	r2
    1ac2:	3f 92       	push	r3
    1ac4:	4f 92       	push	r4
    1ac6:	5f 92       	push	r5
    1ac8:	6f 92       	push	r6
    1aca:	7f 92       	push	r7
    1acc:	8f 92       	push	r8
    1ace:	9f 92       	push	r9
    1ad0:	af 92       	push	r10
    1ad2:	bf 92       	push	r11
    1ad4:	cf 92       	push	r12
    1ad6:	df 92       	push	r13
    1ad8:	ef 92       	push	r14
    1ada:	ff 92       	push	r15
    1adc:	0f 93       	push	r16
    1ade:	1f 93       	push	r17
    1ae0:	cf 93       	push	r28
    1ae2:	df 93       	push	r29
    1ae4:	cd b7       	in	r28, 0x3d	; 61
    1ae6:	de b7       	in	r29, 0x3e	; 62
    1ae8:	65 97       	sbiw	r28, 0x15	; 21
    1aea:	0f b6       	in	r0, 0x3f	; 63
    1aec:	f8 94       	cli
    1aee:	de bf       	out	0x3e, r29	; 62
    1af0:	0f be       	out	0x3f, r0	; 63
    1af2:	cd bf       	out	0x3d, r28	; 61
    1af4:	9b 8b       	std	Y+19, r25	; 0x13
    1af6:	8a 8b       	std	Y+18, r24	; 0x12
    1af8:	09 83       	std	Y+1, r16	; 0x01
    1afa:	1a 83       	std	Y+2, r17	; 0x02
    1afc:	2b 83       	std	Y+3, r18	; 0x03
    1afe:	3c 83       	std	Y+4, r19	; 0x04
    1b00:	4d 83       	std	Y+5, r20	; 0x05
    1b02:	5e 83       	std	Y+6, r21	; 0x06
    1b04:	86 2e       	mov	r8, r22
    1b06:	97 2e       	mov	r9, r23
	unsigned char counter=0;
	unsigned long long the_scaler=10000000000000;/*13 digit*/
	if (thenumber<0)
    1b08:	20 2f       	mov	r18, r16
    1b0a:	31 2f       	mov	r19, r17
    1b0c:	4b 81       	ldd	r20, Y+3	; 0x03
    1b0e:	5c 81       	ldd	r21, Y+4	; 0x04
    1b10:	6d 81       	ldd	r22, Y+5	; 0x05
    1b12:	7e 81       	ldd	r23, Y+6	; 0x06
    1b14:	88 2d       	mov	r24, r8
    1b16:	99 2d       	mov	r25, r9
    1b18:	a0 e0       	ldi	r26, 0x00	; 0
    1b1a:	0e 94 05 43 	call	0x860a	; 0x860a <__cmpdi2_s8>
    1b1e:	94 f4       	brge	.+36     	; 0x1b44 <inttostring+0x84>
	{
		the_return[0]='-';
    1b20:	8d e2       	ldi	r24, 0x2D	; 45
    1b22:	ea 89       	ldd	r30, Y+18	; 0x12
    1b24:	fb 89       	ldd	r31, Y+19	; 0x13
    1b26:	80 83       	st	Z, r24
		thenumber=thenumber*(-1);
    1b28:	88 2d       	mov	r24, r8
    1b2a:	0e 94 a9 42 	call	0x8552	; 0x8552 <__negdi2>
    1b2e:	29 83       	std	Y+1, r18	; 0x01
    1b30:	3a 83       	std	Y+2, r19	; 0x02
    1b32:	4b 83       	std	Y+3, r20	; 0x03
    1b34:	5c 83       	std	Y+4, r21	; 0x04
    1b36:	6d 83       	std	Y+5, r22	; 0x05
    1b38:	7e 83       	std	Y+6, r23	; 0x06
    1b3a:	88 2e       	mov	r8, r24
    1b3c:	99 2e       	mov	r9, r25
		counter=1;
    1b3e:	f1 e0       	ldi	r31, 0x01	; 1
    1b40:	ff 83       	std	Y+7, r31	; 0x07
    1b42:	01 c0       	rjmp	.+2      	; 0x1b46 <inttostring+0x86>
 *  Author: ideapad510
 */ 
#include "minohelper.h"
unsigned char inttostring(unsigned char * the_return,long long thenumber)
{
	unsigned char counter=0;
    1b44:	1f 82       	std	Y+7, r1	; 0x07
	{
		the_return[0]='-';
		thenumber=thenumber*(-1);
		counter=1;
	}
	if (thenumber==0)
    1b46:	29 81       	ldd	r18, Y+1	; 0x01
    1b48:	3a 81       	ldd	r19, Y+2	; 0x02
    1b4a:	4b 81       	ldd	r20, Y+3	; 0x03
    1b4c:	5c 81       	ldd	r21, Y+4	; 0x04
    1b4e:	6d 81       	ldd	r22, Y+5	; 0x05
    1b50:	7e 81       	ldd	r23, Y+6	; 0x06
    1b52:	88 2d       	mov	r24, r8
    1b54:	99 2d       	mov	r25, r9
    1b56:	a0 e0       	ldi	r26, 0x00	; 0
    1b58:	0e 94 05 43 	call	0x860a	; 0x860a <__cmpdi2_s8>
    1b5c:	99 f0       	breq	.+38     	; 0x1b84 <inttostring+0xc4>
	{
		the_return[0]='0';
		return 1;
	}
	while (thenumber/the_scaler==0)
    1b5e:	2c 8b       	std	Y+20, r18	; 0x14
    1b60:	38 8b       	std	Y+16, r19	; 0x10
    1b62:	24 2e       	mov	r2, r20
    1b64:	35 2e       	mov	r3, r21
    1b66:	46 2e       	mov	r4, r22
    1b68:	57 2e       	mov	r5, r23
    1b6a:	68 2c       	mov	r6, r8
    1b6c:	79 2c       	mov	r7, r9
    1b6e:	2f 3f       	cpi	r18, 0xFF	; 255
    1b70:	3f 49       	sbci	r19, 0x9F	; 159
    1b72:	42 47       	sbci	r20, 0x72	; 114
    1b74:	5e 44       	sbci	r21, 0x4E	; 78
    1b76:	68 41       	sbci	r22, 0x18	; 24
    1b78:	79 40       	sbci	r23, 0x09	; 9
    1b7a:	81 05       	cpc	r24, r1
    1b7c:	91 05       	cpc	r25, r1
    1b7e:	41 f0       	breq	.+16     	; 0x1b90 <inttostring+0xd0>
    1b80:	38 f0       	brcs	.+14     	; 0x1b90 <inttostring+0xd0>
    1b82:	0a c1       	rjmp	.+532    	; 0x1d98 <inttostring+0x2d8>
		thenumber=thenumber*(-1);
		counter=1;
	}
	if (thenumber==0)
	{
		the_return[0]='0';
    1b84:	80 e3       	ldi	r24, 0x30	; 48
    1b86:	ea 89       	ldd	r30, Y+18	; 0x12
    1b88:	fb 89       	ldd	r31, Y+19	; 0x13
    1b8a:	80 83       	st	Z, r24
		return 1;
    1b8c:	81 e0       	ldi	r24, 0x01	; 1
    1b8e:	50 c1       	rjmp	.+672    	; 0x1e30 <inttostring+0x370>
	}
	while (thenumber/the_scaler==0)
    1b90:	18 86       	std	Y+8, r1	; 0x08
    1b92:	f0 ea       	ldi	r31, 0xA0	; 160
    1b94:	f9 87       	std	Y+9, r31	; 0x09
    1b96:	22 e7       	ldi	r18, 0x72	; 114
    1b98:	2a 87       	std	Y+10, r18	; 0x0a
    1b9a:	8e e4       	ldi	r24, 0x4E	; 78
    1b9c:	8b 87       	std	Y+11, r24	; 0x0b
    1b9e:	98 e1       	ldi	r25, 0x18	; 24
    1ba0:	9c 87       	std	Y+12, r25	; 0x0c
    1ba2:	e9 e0       	ldi	r30, 0x09	; 9
    1ba4:	ed 87       	std	Y+13, r30	; 0x0d
    1ba6:	1e 86       	std	Y+14, r1	; 0x0e
    1ba8:	1f 86       	std	Y+15, r1	; 0x0f
    1baa:	0f 2e       	mov	r0, r31
    1bac:	f2 e7       	ldi	r31, 0x72	; 114
    1bae:	9f 2e       	mov	r9, r31
    1bb0:	f0 2d       	mov	r31, r0
    1bb2:	0f 2e       	mov	r0, r31
    1bb4:	fe e4       	ldi	r31, 0x4E	; 78
    1bb6:	8f 2e       	mov	r8, r31
    1bb8:	f0 2d       	mov	r31, r0
    1bba:	fc 89       	ldd	r31, Y+20	; 0x14
    1bbc:	f9 83       	std	Y+1, r31	; 0x01
    1bbe:	88 89       	ldd	r24, Y+16	; 0x10
    1bc0:	8a 83       	std	Y+2, r24	; 0x02
    1bc2:	2b 82       	std	Y+3, r2	; 0x03
    1bc4:	21 2c       	mov	r2, r1
    1bc6:	3c 82       	std	Y+4, r3	; 0x04
    1bc8:	31 2c       	mov	r3, r1
    1bca:	4d 82       	std	Y+5, r4	; 0x05
    1bcc:	0f 2e       	mov	r0, r31
    1bce:	f9 e0       	ldi	r31, 0x09	; 9
    1bd0:	4f 2e       	mov	r4, r31
    1bd2:	f0 2d       	mov	r31, r0
    1bd4:	5e 82       	std	Y+6, r5	; 0x06
    1bd6:	0f 2e       	mov	r0, r31
    1bd8:	f8 e1       	ldi	r31, 0x18	; 24
    1bda:	5f 2e       	mov	r5, r31
    1bdc:	f0 2d       	mov	r31, r0
	{
		the_scaler=the_scaler/10;
    1bde:	0f 2e       	mov	r0, r31
    1be0:	fa e0       	ldi	r31, 0x0A	; 10
    1be2:	af 2e       	mov	r10, r31
    1be4:	f0 2d       	mov	r31, r0
    1be6:	b1 2c       	mov	r11, r1
    1be8:	c1 2c       	mov	r12, r1
    1bea:	d1 2c       	mov	r13, r1
    1bec:	e1 2c       	mov	r14, r1
    1bee:	f1 2c       	mov	r15, r1
    1bf0:	00 e0       	ldi	r16, 0x00	; 0
    1bf2:	10 e0       	ldi	r17, 0x00	; 0
    1bf4:	28 85       	ldd	r18, Y+8	; 0x08
    1bf6:	39 85       	ldd	r19, Y+9	; 0x09
    1bf8:	49 2d       	mov	r20, r9
    1bfa:	58 2d       	mov	r21, r8
    1bfc:	65 2d       	mov	r22, r5
    1bfe:	74 2d       	mov	r23, r4
    1c00:	83 2d       	mov	r24, r3
    1c02:	92 2d       	mov	r25, r2
    1c04:	0e 94 4d 42 	call	0x849a	; 0x849a <__udivdi3>
    1c08:	28 87       	std	Y+8, r18	; 0x08
    1c0a:	39 87       	std	Y+9, r19	; 0x09
    1c0c:	94 2e       	mov	r9, r20
    1c0e:	85 2e       	mov	r8, r21
    1c10:	56 2e       	mov	r5, r22
    1c12:	47 2e       	mov	r4, r23
    1c14:	38 2e       	mov	r3, r24
    1c16:	29 2e       	mov	r2, r25
	if (thenumber==0)
	{
		the_return[0]='0';
		return 1;
	}
	while (thenumber/the_scaler==0)
    1c18:	a2 2e       	mov	r10, r18
    1c1a:	b3 2e       	mov	r11, r19
    1c1c:	c4 2e       	mov	r12, r20
    1c1e:	d5 2e       	mov	r13, r21
    1c20:	e6 2e       	mov	r14, r22
    1c22:	f7 2e       	mov	r15, r23
    1c24:	08 2f       	mov	r16, r24
    1c26:	19 2f       	mov	r17, r25
    1c28:	29 81       	ldd	r18, Y+1	; 0x01
    1c2a:	3a 81       	ldd	r19, Y+2	; 0x02
    1c2c:	4b 81       	ldd	r20, Y+3	; 0x03
    1c2e:	5c 81       	ldd	r21, Y+4	; 0x04
    1c30:	6d 81       	ldd	r22, Y+5	; 0x05
    1c32:	7e 81       	ldd	r23, Y+6	; 0x06
    1c34:	86 2d       	mov	r24, r6
    1c36:	97 2d       	mov	r25, r7
    1c38:	0e 94 4d 42 	call	0x849a	; 0x849a <__udivdi3>
    1c3c:	a0 e0       	ldi	r26, 0x00	; 0
    1c3e:	0e 94 05 43 	call	0x860a	; 0x860a <__cmpdi2_s8>
    1c42:	69 f2       	breq	.-102    	; 0x1bde <inttostring+0x11e>
    1c44:	9a 86       	std	Y+10, r9	; 0x0a
    1c46:	8b 86       	std	Y+11, r8	; 0x0b
    1c48:	5c 86       	std	Y+12, r5	; 0x0c
    1c4a:	4d 86       	std	Y+13, r4	; 0x0d
    1c4c:	3e 86       	std	Y+14, r3	; 0x0e
    1c4e:	2f 86       	std	Y+15, r2	; 0x0f
    1c50:	29 81       	ldd	r18, Y+1	; 0x01
    1c52:	2c 8b       	std	Y+20, r18	; 0x14
    1c54:	8a 81       	ldd	r24, Y+2	; 0x02
    1c56:	88 8b       	std	Y+16, r24	; 0x10
    1c58:	2b 80       	ldd	r2, Y+3	; 0x03
    1c5a:	3c 80       	ldd	r3, Y+4	; 0x04
    1c5c:	4d 80       	ldd	r4, Y+5	; 0x05
    1c5e:	5e 80       	ldd	r5, Y+6	; 0x06
		the_scaler=the_scaler/10;
	}
	
	do 
	{
			the_return[counter]=(thenumber/the_scaler)+48;
    1c60:	8a 88       	ldd	r8, Y+18	; 0x12
    1c62:	9b 88       	ldd	r9, Y+19	; 0x13
    1c64:	9f 81       	ldd	r25, Y+7	; 0x07
    1c66:	89 0e       	add	r8, r25
    1c68:	91 1c       	adc	r9, r1
    1c6a:	38 2f       	mov	r19, r24
    1c6c:	42 2d       	mov	r20, r2
    1c6e:	53 2d       	mov	r21, r3
    1c70:	64 2d       	mov	r22, r4
    1c72:	75 2d       	mov	r23, r5
    1c74:	86 2d       	mov	r24, r6
    1c76:	97 2d       	mov	r25, r7
    1c78:	0e 94 4d 42 	call	0x849a	; 0x849a <__udivdi3>
    1c7c:	20 5d       	subi	r18, 0xD0	; 208
    1c7e:	f4 01       	movw	r30, r8
    1c80:	20 83       	st	Z, r18
			counter++;
    1c82:	ff 81       	ldd	r31, Y+7	; 0x07
    1c84:	ff 5f       	subi	r31, 0xFF	; 255
    1c86:	ff 83       	std	Y+7, r31	; 0x07
			thenumber=thenumber%the_scaler;
    1c88:	2c 89       	ldd	r18, Y+20	; 0x14
    1c8a:	38 89       	ldd	r19, Y+16	; 0x10
    1c8c:	42 2d       	mov	r20, r2
    1c8e:	53 2d       	mov	r21, r3
    1c90:	64 2d       	mov	r22, r4
    1c92:	75 2d       	mov	r23, r5
    1c94:	86 2d       	mov	r24, r6
    1c96:	97 2d       	mov	r25, r7
    1c98:	0e 94 4b 42 	call	0x8496	; 0x8496 <__umoddi3>
    1c9c:	29 83       	std	Y+1, r18	; 0x01
    1c9e:	3a 83       	std	Y+2, r19	; 0x02
    1ca0:	4b 83       	std	Y+3, r20	; 0x03
    1ca2:	5c 83       	std	Y+4, r21	; 0x04
    1ca4:	6d 83       	std	Y+5, r22	; 0x05
    1ca6:	7e 83       	std	Y+6, r23	; 0x06
    1ca8:	38 2e       	mov	r3, r24
    1caa:	29 2e       	mov	r2, r25
			if (the_scaler==1)
    1cac:	2a 2d       	mov	r18, r10
    1cae:	3b 2d       	mov	r19, r11
    1cb0:	4c 2d       	mov	r20, r12
    1cb2:	5d 2d       	mov	r21, r13
    1cb4:	6e 2d       	mov	r22, r14
    1cb6:	7f 2d       	mov	r23, r15
    1cb8:	80 2f       	mov	r24, r16
    1cba:	91 2f       	mov	r25, r17
    1cbc:	a1 e0       	ldi	r26, 0x01	; 1
    1cbe:	0e 94 05 43 	call	0x860a	; 0x860a <__cmpdi2_s8>
    1cc2:	09 f4       	brne	.+2      	; 0x1cc6 <inttostring+0x206>
    1cc4:	65 c0       	rjmp	.+202    	; 0x1d90 <inttostring+0x2d0>
			{
				break;
			}
			the_scaler=the_scaler/10;
    1cc6:	0f 2e       	mov	r0, r31
    1cc8:	fa e0       	ldi	r31, 0x0A	; 10
    1cca:	af 2e       	mov	r10, r31
    1ccc:	f0 2d       	mov	r31, r0
    1cce:	b1 2c       	mov	r11, r1
    1cd0:	c1 2c       	mov	r12, r1
    1cd2:	d1 2c       	mov	r13, r1
    1cd4:	e1 2c       	mov	r14, r1
    1cd6:	f1 2c       	mov	r15, r1
    1cd8:	00 e0       	ldi	r16, 0x00	; 0
    1cda:	10 e0       	ldi	r17, 0x00	; 0
    1cdc:	28 85       	ldd	r18, Y+8	; 0x08
    1cde:	39 85       	ldd	r19, Y+9	; 0x09
    1ce0:	4a 85       	ldd	r20, Y+10	; 0x0a
    1ce2:	5b 85       	ldd	r21, Y+11	; 0x0b
    1ce4:	6c 85       	ldd	r22, Y+12	; 0x0c
    1ce6:	7d 85       	ldd	r23, Y+13	; 0x0d
    1ce8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1cea:	9f 85       	ldd	r25, Y+15	; 0x0f
    1cec:	0e 94 4d 42 	call	0x849a	; 0x849a <__udivdi3>
    1cf0:	42 2e       	mov	r4, r18
    1cf2:	53 2e       	mov	r5, r19
    1cf4:	64 2e       	mov	r6, r20
    1cf6:	75 2e       	mov	r7, r21
    1cf8:	86 2e       	mov	r8, r22
    1cfa:	97 2e       	mov	r9, r23
    1cfc:	8d 8b       	std	Y+21, r24	; 0x15
    1cfe:	9c 8b       	std	Y+20, r25	; 0x14
    1d00:	28 87       	std	Y+8, r18	; 0x08
    1d02:	39 87       	std	Y+9, r19	; 0x09
    1d04:	4a 87       	std	Y+10, r20	; 0x0a
    1d06:	5b 87       	std	Y+11, r21	; 0x0b
    1d08:	6c 87       	std	Y+12, r22	; 0x0c
    1d0a:	7d 87       	std	Y+13, r23	; 0x0d
    1d0c:	8e 87       	std	Y+14, r24	; 0x0e
    1d0e:	9f 87       	std	Y+15, r25	; 0x0f
		the_scaler=the_scaler/10;
	}
	
	do 
	{
			the_return[counter]=(thenumber/the_scaler)+48;
    1d10:	8a 89       	ldd	r24, Y+18	; 0x12
    1d12:	9b 89       	ldd	r25, Y+19	; 0x13
    1d14:	ef 81       	ldd	r30, Y+7	; 0x07
    1d16:	8e 0f       	add	r24, r30
    1d18:	91 1d       	adc	r25, r1
    1d1a:	99 8b       	std	Y+17, r25	; 0x11
    1d1c:	88 8b       	std	Y+16, r24	; 0x10
    1d1e:	a4 2c       	mov	r10, r4
    1d20:	b5 2c       	mov	r11, r5
    1d22:	c6 2c       	mov	r12, r6
    1d24:	d7 2c       	mov	r13, r7
    1d26:	e8 2c       	mov	r14, r8
    1d28:	f9 2c       	mov	r15, r9
    1d2a:	0d 89       	ldd	r16, Y+21	; 0x15
    1d2c:	1c 89       	ldd	r17, Y+20	; 0x14
    1d2e:	29 81       	ldd	r18, Y+1	; 0x01
    1d30:	3a 81       	ldd	r19, Y+2	; 0x02
    1d32:	4b 81       	ldd	r20, Y+3	; 0x03
    1d34:	5c 81       	ldd	r21, Y+4	; 0x04
    1d36:	6d 81       	ldd	r22, Y+5	; 0x05
    1d38:	7e 81       	ldd	r23, Y+6	; 0x06
    1d3a:	83 2d       	mov	r24, r3
    1d3c:	92 2d       	mov	r25, r2
    1d3e:	0e 94 4d 42 	call	0x849a	; 0x849a <__udivdi3>
    1d42:	20 5d       	subi	r18, 0xD0	; 208
    1d44:	e8 89       	ldd	r30, Y+16	; 0x10
    1d46:	f9 89       	ldd	r31, Y+17	; 0x11
    1d48:	20 83       	st	Z, r18
			counter++;
    1d4a:	ff 81       	ldd	r31, Y+7	; 0x07
    1d4c:	ff 5f       	subi	r31, 0xFF	; 255
    1d4e:	ff 83       	std	Y+7, r31	; 0x07
			thenumber=thenumber%the_scaler;
    1d50:	29 81       	ldd	r18, Y+1	; 0x01
    1d52:	3a 81       	ldd	r19, Y+2	; 0x02
    1d54:	4b 81       	ldd	r20, Y+3	; 0x03
    1d56:	5c 81       	ldd	r21, Y+4	; 0x04
    1d58:	6d 81       	ldd	r22, Y+5	; 0x05
    1d5a:	7e 81       	ldd	r23, Y+6	; 0x06
    1d5c:	83 2d       	mov	r24, r3
    1d5e:	92 2d       	mov	r25, r2
    1d60:	0e 94 4b 42 	call	0x8496	; 0x8496 <__umoddi3>
    1d64:	29 83       	std	Y+1, r18	; 0x01
    1d66:	3a 83       	std	Y+2, r19	; 0x02
    1d68:	4b 83       	std	Y+3, r20	; 0x03
    1d6a:	5c 83       	std	Y+4, r21	; 0x04
    1d6c:	6d 83       	std	Y+5, r22	; 0x05
    1d6e:	7e 83       	std	Y+6, r23	; 0x06
    1d70:	38 2e       	mov	r3, r24
    1d72:	29 2e       	mov	r2, r25
			if (the_scaler==1)
    1d74:	24 2d       	mov	r18, r4
    1d76:	35 2d       	mov	r19, r5
    1d78:	46 2d       	mov	r20, r6
    1d7a:	57 2d       	mov	r21, r7
    1d7c:	68 2d       	mov	r22, r8
    1d7e:	79 2d       	mov	r23, r9
    1d80:	80 2f       	mov	r24, r16
    1d82:	91 2f       	mov	r25, r17
    1d84:	a1 e0       	ldi	r26, 0x01	; 1
    1d86:	0e 94 05 43 	call	0x860a	; 0x860a <__cmpdi2_s8>
    1d8a:	09 f0       	breq	.+2      	; 0x1d8e <inttostring+0x2ce>
    1d8c:	9c cf       	rjmp	.-200    	; 0x1cc6 <inttostring+0x206>
    1d8e:	02 c0       	rjmp	.+4      	; 0x1d94 <inttostring+0x2d4>
	}
	
	do 
	{
			the_return[counter]=(thenumber/the_scaler)+48;
			counter++;
    1d90:	8f 81       	ldd	r24, Y+7	; 0x07
    1d92:	4e c0       	rjmp	.+156    	; 0x1e30 <inttostring+0x370>
    1d94:	8f 81       	ldd	r24, Y+7	; 0x07
    1d96:	4c c0       	rjmp	.+152    	; 0x1e30 <inttostring+0x370>
		the_scaler=the_scaler/10;
	}
	
	do 
	{
			the_return[counter]=(thenumber/the_scaler)+48;
    1d98:	6a 88       	ldd	r6, Y+18	; 0x12
    1d9a:	7b 88       	ldd	r7, Y+19	; 0x13
    1d9c:	2f 81       	ldd	r18, Y+7	; 0x07
    1d9e:	62 0e       	add	r6, r18
    1da0:	71 1c       	adc	r7, r1
    1da2:	a1 2c       	mov	r10, r1
    1da4:	0f 2e       	mov	r0, r31
    1da6:	f0 ea       	ldi	r31, 0xA0	; 160
    1da8:	bf 2e       	mov	r11, r31
    1daa:	f0 2d       	mov	r31, r0
    1dac:	0f 2e       	mov	r0, r31
    1dae:	f2 e7       	ldi	r31, 0x72	; 114
    1db0:	cf 2e       	mov	r12, r31
    1db2:	f0 2d       	mov	r31, r0
    1db4:	0f 2e       	mov	r0, r31
    1db6:	fe e4       	ldi	r31, 0x4E	; 78
    1db8:	df 2e       	mov	r13, r31
    1dba:	f0 2d       	mov	r31, r0
    1dbc:	0f 2e       	mov	r0, r31
    1dbe:	f8 e1       	ldi	r31, 0x18	; 24
    1dc0:	ef 2e       	mov	r14, r31
    1dc2:	f0 2d       	mov	r31, r0
    1dc4:	0f 2e       	mov	r0, r31
    1dc6:	f9 e0       	ldi	r31, 0x09	; 9
    1dc8:	ff 2e       	mov	r15, r31
    1dca:	f0 2d       	mov	r31, r0
    1dcc:	00 e0       	ldi	r16, 0x00	; 0
    1dce:	10 e0       	ldi	r17, 0x00	; 0
    1dd0:	29 81       	ldd	r18, Y+1	; 0x01
    1dd2:	3a 81       	ldd	r19, Y+2	; 0x02
    1dd4:	4b 81       	ldd	r20, Y+3	; 0x03
    1dd6:	5c 81       	ldd	r21, Y+4	; 0x04
    1dd8:	6d 81       	ldd	r22, Y+5	; 0x05
    1dda:	7e 81       	ldd	r23, Y+6	; 0x06
    1ddc:	88 2d       	mov	r24, r8
    1dde:	99 2d       	mov	r25, r9
    1de0:	0e 94 4d 42 	call	0x849a	; 0x849a <__udivdi3>
    1de4:	20 5d       	subi	r18, 0xD0	; 208
    1de6:	f3 01       	movw	r30, r6
    1de8:	20 83       	st	Z, r18
			counter++;
    1dea:	ff 81       	ldd	r31, Y+7	; 0x07
    1dec:	ff 5f       	subi	r31, 0xFF	; 255
    1dee:	ff 83       	std	Y+7, r31	; 0x07
			thenumber=thenumber%the_scaler;
    1df0:	29 81       	ldd	r18, Y+1	; 0x01
    1df2:	3a 81       	ldd	r19, Y+2	; 0x02
    1df4:	4b 81       	ldd	r20, Y+3	; 0x03
    1df6:	5c 81       	ldd	r21, Y+4	; 0x04
    1df8:	6d 81       	ldd	r22, Y+5	; 0x05
    1dfa:	7e 81       	ldd	r23, Y+6	; 0x06
    1dfc:	88 2d       	mov	r24, r8
    1dfe:	99 2d       	mov	r25, r9
    1e00:	0e 94 4b 42 	call	0x8496	; 0x8496 <__umoddi3>
    1e04:	29 83       	std	Y+1, r18	; 0x01
    1e06:	3a 83       	std	Y+2, r19	; 0x02
    1e08:	4b 83       	std	Y+3, r20	; 0x03
    1e0a:	5c 83       	std	Y+4, r21	; 0x04
    1e0c:	6d 83       	std	Y+5, r22	; 0x05
    1e0e:	7e 83       	std	Y+6, r23	; 0x06
    1e10:	38 2e       	mov	r3, r24
    1e12:	29 2e       	mov	r2, r25
    1e14:	18 86       	std	Y+8, r1	; 0x08
    1e16:	20 ea       	ldi	r18, 0xA0	; 160
    1e18:	29 87       	std	Y+9, r18	; 0x09
    1e1a:	82 e7       	ldi	r24, 0x72	; 114
    1e1c:	8a 87       	std	Y+10, r24	; 0x0a
    1e1e:	9e e4       	ldi	r25, 0x4E	; 78
    1e20:	9b 87       	std	Y+11, r25	; 0x0b
    1e22:	e8 e1       	ldi	r30, 0x18	; 24
    1e24:	ec 87       	std	Y+12, r30	; 0x0c
    1e26:	f9 e0       	ldi	r31, 0x09	; 9
    1e28:	fd 87       	std	Y+13, r31	; 0x0d
    1e2a:	1e 86       	std	Y+14, r1	; 0x0e
    1e2c:	1f 86       	std	Y+15, r1	; 0x0f
    1e2e:	4b cf       	rjmp	.-362    	; 0x1cc6 <inttostring+0x206>
			the_scaler=the_scaler/10;
	} while (1);

	
	return counter;
}
    1e30:	65 96       	adiw	r28, 0x15	; 21
    1e32:	0f b6       	in	r0, 0x3f	; 63
    1e34:	f8 94       	cli
    1e36:	de bf       	out	0x3e, r29	; 62
    1e38:	0f be       	out	0x3f, r0	; 63
    1e3a:	cd bf       	out	0x3d, r28	; 61
    1e3c:	df 91       	pop	r29
    1e3e:	cf 91       	pop	r28
    1e40:	1f 91       	pop	r17
    1e42:	0f 91       	pop	r16
    1e44:	ff 90       	pop	r15
    1e46:	ef 90       	pop	r14
    1e48:	df 90       	pop	r13
    1e4a:	cf 90       	pop	r12
    1e4c:	bf 90       	pop	r11
    1e4e:	af 90       	pop	r10
    1e50:	9f 90       	pop	r9
    1e52:	8f 90       	pop	r8
    1e54:	7f 90       	pop	r7
    1e56:	6f 90       	pop	r6
    1e58:	5f 90       	pop	r5
    1e5a:	4f 90       	pop	r4
    1e5c:	3f 90       	pop	r3
    1e5e:	2f 90       	pop	r2
    1e60:	08 95       	ret

00001e62 <STRINGTOINT>:

unsigned long long STRINGTOINT(unsigned char * the_return,unsigned char size)
{
    1e62:	4f 92       	push	r4
    1e64:	5f 92       	push	r5
    1e66:	6f 92       	push	r6
    1e68:	7f 92       	push	r7
    1e6a:	8f 92       	push	r8
    1e6c:	9f 92       	push	r9
    1e6e:	af 92       	push	r10
    1e70:	bf 92       	push	r11
    1e72:	cf 92       	push	r12
    1e74:	df 92       	push	r13
    1e76:	ef 92       	push	r14
    1e78:	ff 92       	push	r15
    1e7a:	0f 93       	push	r16
    1e7c:	1f 93       	push	r17
    1e7e:	cf 93       	push	r28
    1e80:	df 93       	push	r29
    1e82:	86 2e       	mov	r8, r22
	unsigned char i=0;
	unsigned long long result=0;
	for (i=0;i<size;i++)
    1e84:	66 23       	and	r22, r22
    1e86:	09 f4       	brne	.+2      	; 0x1e8a <STRINGTOINT+0x28>
    1e88:	47 c0       	rjmp	.+142    	; 0x1f18 <STRINGTOINT+0xb6>
    1e8a:	78 2e       	mov	r7, r24
    1e8c:	a8 2f       	mov	r26, r24
    1e8e:	b9 2f       	mov	r27, r25
}

unsigned long long STRINGTOINT(unsigned char * the_return,unsigned char size)
{
	unsigned char i=0;
	unsigned long long result=0;
    1e90:	20 e0       	ldi	r18, 0x00	; 0
    1e92:	30 e0       	ldi	r19, 0x00	; 0
    1e94:	40 e0       	ldi	r20, 0x00	; 0
    1e96:	50 e0       	ldi	r21, 0x00	; 0
    1e98:	60 e0       	ldi	r22, 0x00	; 0
    1e9a:	70 e0       	ldi	r23, 0x00	; 0
    1e9c:	80 e0       	ldi	r24, 0x00	; 0
    1e9e:	90 e0       	ldi	r25, 0x00	; 0
	for (i=0;i<size;i++)
	{
		result*=10;
    1ea0:	01 e0       	ldi	r16, 0x01	; 1
    1ea2:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    1ea6:	42 2e       	mov	r4, r18
    1ea8:	53 2e       	mov	r5, r19
    1eaa:	64 2e       	mov	r6, r20
    1eac:	95 2e       	mov	r9, r21
    1eae:	d6 2f       	mov	r29, r22
    1eb0:	c7 2f       	mov	r28, r23
    1eb2:	f8 2f       	mov	r31, r24
    1eb4:	e9 2f       	mov	r30, r25
    1eb6:	02 e0       	ldi	r16, 0x02	; 2
    1eb8:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    1ebc:	a2 2e       	mov	r10, r18
    1ebe:	b3 2e       	mov	r11, r19
    1ec0:	c4 2e       	mov	r12, r20
    1ec2:	d5 2e       	mov	r13, r21
    1ec4:	e6 2e       	mov	r14, r22
    1ec6:	f7 2e       	mov	r15, r23
    1ec8:	08 2f       	mov	r16, r24
    1eca:	19 2f       	mov	r17, r25
    1ecc:	24 2d       	mov	r18, r4
    1ece:	35 2d       	mov	r19, r5
    1ed0:	46 2d       	mov	r20, r6
    1ed2:	59 2d       	mov	r21, r9
    1ed4:	6d 2f       	mov	r22, r29
    1ed6:	7c 2f       	mov	r23, r28
    1ed8:	8f 2f       	mov	r24, r31
    1eda:	9e 2f       	mov	r25, r30
    1edc:	0e 94 f0 42 	call	0x85e0	; 0x85e0 <__adddi3>
    1ee0:	a2 2e       	mov	r10, r18
    1ee2:	b3 2e       	mov	r11, r19
    1ee4:	c4 2e       	mov	r12, r20
    1ee6:	d5 2e       	mov	r13, r21
    1ee8:	e6 2e       	mov	r14, r22
    1eea:	f7 2e       	mov	r15, r23
    1eec:	08 2f       	mov	r16, r24
    1eee:	19 2f       	mov	r17, r25
		result+=(the_return[i]-48);
    1ef0:	ed 91       	ld	r30, X+
    1ef2:	f0 e0       	ldi	r31, 0x00	; 0
    1ef4:	f0 97       	sbiw	r30, 0x30	; 48
    1ef6:	9f 2f       	mov	r25, r31
    1ef8:	99 0f       	add	r25, r25
    1efa:	99 0b       	sbc	r25, r25
    1efc:	2e 2f       	mov	r18, r30
    1efe:	3f 2f       	mov	r19, r31
    1f00:	49 2f       	mov	r20, r25
    1f02:	59 2f       	mov	r21, r25
    1f04:	69 2f       	mov	r22, r25
    1f06:	79 2f       	mov	r23, r25
    1f08:	89 2f       	mov	r24, r25
    1f0a:	0e 94 f0 42 	call	0x85e0	; 0x85e0 <__adddi3>
    1f0e:	ea 2f       	mov	r30, r26
    1f10:	e7 19       	sub	r30, r7

unsigned long long STRINGTOINT(unsigned char * the_return,unsigned char size)
{
	unsigned char i=0;
	unsigned long long result=0;
	for (i=0;i<size;i++)
    1f12:	e8 15       	cp	r30, r8
    1f14:	28 f2       	brcs	.-118    	; 0x1ea0 <STRINGTOINT+0x3e>
    1f16:	08 c0       	rjmp	.+16     	; 0x1f28 <STRINGTOINT+0xc6>
}

unsigned long long STRINGTOINT(unsigned char * the_return,unsigned char size)
{
	unsigned char i=0;
	unsigned long long result=0;
    1f18:	20 e0       	ldi	r18, 0x00	; 0
    1f1a:	30 e0       	ldi	r19, 0x00	; 0
    1f1c:	40 e0       	ldi	r20, 0x00	; 0
    1f1e:	50 e0       	ldi	r21, 0x00	; 0
    1f20:	60 e0       	ldi	r22, 0x00	; 0
    1f22:	70 e0       	ldi	r23, 0x00	; 0
    1f24:	80 e0       	ldi	r24, 0x00	; 0
    1f26:	90 e0       	ldi	r25, 0x00	; 0
	{
		result*=10;
		result+=(the_return[i]-48);
	}
	return result;
    1f28:	df 91       	pop	r29
    1f2a:	cf 91       	pop	r28
    1f2c:	1f 91       	pop	r17
    1f2e:	0f 91       	pop	r16
    1f30:	ff 90       	pop	r15
    1f32:	ef 90       	pop	r14
    1f34:	df 90       	pop	r13
    1f36:	cf 90       	pop	r12
    1f38:	bf 90       	pop	r11
    1f3a:	af 90       	pop	r10
    1f3c:	9f 90       	pop	r9
    1f3e:	8f 90       	pop	r8
    1f40:	7f 90       	pop	r7
    1f42:	6f 90       	pop	r6
    1f44:	5f 90       	pop	r5
    1f46:	4f 90       	pop	r4
    1f48:	08 95       	ret

00001f4a <NRF_SPI_EXCHANGE>:

void NRF_UPDATE_RET_PL(NRF_RETRANSMIT_COUNT_DT RET)
{
	NRF1.NRF_SETUP_RETR&=0B11110000;
	NRF1.NRF_SETUP_RETR|=RET;	
	NRF_WRITE_REGISTER(NRF_SETUP_RETR_ADDRESS,NRF1.NRF_SETUP_RETR);
    1f4a:	8f b9       	out	0x0f, r24	; 15
    1f4c:	77 9b       	sbis	0x0e, 7	; 14
    1f4e:	fe cf       	rjmp	.-4      	; 0x1f4c <NRF_SPI_EXCHANGE+0x2>
    1f50:	8f b1       	in	r24, 0x0f	; 15
    1f52:	08 95       	ret

00001f54 <NRF_WRITE_REGISTER>:
    1f54:	cf 93       	push	r28
    1f56:	c6 2f       	mov	r28, r22
    1f58:	1f 98       	cbi	0x03, 7	; 3
    1f5a:	80 62       	ori	r24, 0x20	; 32
    1f5c:	f6 df       	rcall	.-20     	; 0x1f4a <NRF_SPI_EXCHANGE>
    1f5e:	80 93 dd 0c 	sts	0x0CDD, r24
    1f62:	8c 2f       	mov	r24, r28
    1f64:	f2 df       	rcall	.-28     	; 0x1f4a <NRF_SPI_EXCHANGE>
    1f66:	1f 9a       	sbi	0x03, 7	; 3
    1f68:	60 e0       	ldi	r22, 0x00	; 0
    1f6a:	70 e0       	ldi	r23, 0x00	; 0
    1f6c:	cb 01       	movw	r24, r22
    1f6e:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
    1f72:	cf 91       	pop	r28
    1f74:	08 95       	ret

00001f76 <NRF_READ_REGISTER>:
    1f76:	cf 93       	push	r28
    1f78:	1f 98       	cbi	0x03, 7	; 3
    1f7a:	e7 df       	rcall	.-50     	; 0x1f4a <NRF_SPI_EXCHANGE>
    1f7c:	80 93 dd 0c 	sts	0x0CDD, r24
    1f80:	8f ef       	ldi	r24, 0xFF	; 255
    1f82:	e3 df       	rcall	.-58     	; 0x1f4a <NRF_SPI_EXCHANGE>
    1f84:	c8 2f       	mov	r28, r24
    1f86:	1f 9a       	sbi	0x03, 7	; 3
    1f88:	60 e0       	ldi	r22, 0x00	; 0
    1f8a:	70 e0       	ldi	r23, 0x00	; 0
    1f8c:	cb 01       	movw	r24, r22
    1f8e:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
    1f92:	8c 2f       	mov	r24, r28
    1f94:	cf 91       	pop	r28
    1f96:	08 95       	ret

00001f98 <NRF_R_RX_PAYLOAD_DYNAMIC>:
    1f98:	ff 92       	push	r15
    1f9a:	0f 93       	push	r16
    1f9c:	1f 93       	push	r17
    1f9e:	cf 93       	push	r28
    1fa0:	df 93       	push	r29
    1fa2:	f8 2e       	mov	r15, r24
    1fa4:	19 2f       	mov	r17, r25
    1fa6:	06 2f       	mov	r16, r22
    1fa8:	1f 98       	cbi	0x03, 7	; 3
    1faa:	81 e6       	ldi	r24, 0x61	; 97
    1fac:	ce df       	rcall	.-100    	; 0x1f4a <NRF_SPI_EXCHANGE>
    1fae:	80 93 dd 0c 	sts	0x0CDD, r24
    1fb2:	00 23       	and	r16, r16
    1fb4:	49 f0       	breq	.+18     	; 0x1fc8 <NRF_R_RX_PAYLOAD_DYNAMIC+0x30>
    1fb6:	cf 2d       	mov	r28, r15
    1fb8:	d1 2f       	mov	r29, r17
    1fba:	10 e0       	ldi	r17, 0x00	; 0
    1fbc:	8f ef       	ldi	r24, 0xFF	; 255
    1fbe:	c5 df       	rcall	.-118    	; 0x1f4a <NRF_SPI_EXCHANGE>
    1fc0:	89 93       	st	Y+, r24
    1fc2:	1f 5f       	subi	r17, 0xFF	; 255
    1fc4:	10 13       	cpse	r17, r16
    1fc6:	fa cf       	rjmp	.-12     	; 0x1fbc <NRF_R_RX_PAYLOAD_DYNAMIC+0x24>
    1fc8:	1f 9a       	sbi	0x03, 7	; 3
    1fca:	df 91       	pop	r29
    1fcc:	cf 91       	pop	r28
    1fce:	1f 91       	pop	r17
    1fd0:	0f 91       	pop	r16
    1fd2:	ff 90       	pop	r15
    1fd4:	08 95       	ret

00001fd6 <NRF_W_TX_PAYLOAD_ACK>:
    1fd6:	ff 92       	push	r15
    1fd8:	0f 93       	push	r16
    1fda:	1f 93       	push	r17
    1fdc:	cf 93       	push	r28
    1fde:	df 93       	push	r29
    1fe0:	f8 2e       	mov	r15, r24
    1fe2:	19 2f       	mov	r17, r25
    1fe4:	06 2f       	mov	r16, r22
    1fe6:	1f 98       	cbi	0x03, 7	; 3
    1fe8:	80 ea       	ldi	r24, 0xA0	; 160
    1fea:	af df       	rcall	.-162    	; 0x1f4a <NRF_SPI_EXCHANGE>
    1fec:	80 93 dd 0c 	sts	0x0CDD, r24
    1ff0:	00 23       	and	r16, r16
    1ff2:	41 f0       	breq	.+16     	; 0x2004 <NRF_W_TX_PAYLOAD_ACK+0x2e>
    1ff4:	cf 2d       	mov	r28, r15
    1ff6:	d1 2f       	mov	r29, r17
    1ff8:	10 e0       	ldi	r17, 0x00	; 0
    1ffa:	89 91       	ld	r24, Y+
    1ffc:	a6 df       	rcall	.-180    	; 0x1f4a <NRF_SPI_EXCHANGE>
    1ffe:	1f 5f       	subi	r17, 0xFF	; 255
    2000:	10 13       	cpse	r17, r16
    2002:	fb cf       	rjmp	.-10     	; 0x1ffa <NRF_W_TX_PAYLOAD_ACK+0x24>
    2004:	1f 9a       	sbi	0x03, 7	; 3
    2006:	df 91       	pop	r29
    2008:	cf 91       	pop	r28
    200a:	1f 91       	pop	r17
    200c:	0f 91       	pop	r16
    200e:	ff 90       	pop	r15
    2010:	08 95       	ret

00002012 <NRF_FLUSH_TX_BUFFER>:
    2012:	1f 98       	cbi	0x03, 7	; 3
    2014:	81 ee       	ldi	r24, 0xE1	; 225
    2016:	99 df       	rcall	.-206    	; 0x1f4a <NRF_SPI_EXCHANGE>
    2018:	80 93 dd 0c 	sts	0x0CDD, r24
    201c:	1f 9a       	sbi	0x03, 7	; 3
    201e:	08 95       	ret

00002020 <NRF_FLUSH_RX_BUFFER>:
    2020:	1f 98       	cbi	0x03, 7	; 3
    2022:	82 ee       	ldi	r24, 0xE2	; 226
    2024:	92 df       	rcall	.-220    	; 0x1f4a <NRF_SPI_EXCHANGE>
    2026:	80 93 dd 0c 	sts	0x0CDD, r24
    202a:	1f 9a       	sbi	0x03, 7	; 3
    202c:	08 95       	ret

0000202e <NRF_READ_LENGTH_RX_PL>:
    202e:	1f 98       	cbi	0x03, 7	; 3
    2030:	80 e6       	ldi	r24, 0x60	; 96
    2032:	8b df       	rcall	.-234    	; 0x1f4a <NRF_SPI_EXCHANGE>
    2034:	80 93 dd 0c 	sts	0x0CDD, r24
    2038:	8f ef       	ldi	r24, 0xFF	; 255
    203a:	87 df       	rcall	.-242    	; 0x1f4a <NRF_SPI_EXCHANGE>
    203c:	1f 9a       	sbi	0x03, 7	; 3
    203e:	08 95       	ret

00002040 <NRF_READ_RX_DR_AND_CLEAR>:
    2040:	cf 93       	push	r28
    2042:	df 93       	push	r29
    2044:	1f 92       	push	r1
    2046:	cd b7       	in	r28, 0x3d	; 61
    2048:	de b7       	in	r29, 0x3e	; 62
    204a:	87 e0       	ldi	r24, 0x07	; 7
    204c:	94 df       	rcall	.-216    	; 0x1f76 <NRF_READ_REGISTER>
    204e:	89 83       	std	Y+1, r24	; 0x01
    2050:	99 81       	ldd	r25, Y+1	; 0x01
    2052:	89 2f       	mov	r24, r25
    2054:	80 74       	andi	r24, 0x40	; 64
    2056:	96 ff       	sbrs	r25, 6
    2058:	04 c0       	rjmp	.+8      	; 0x2062 <NRF_READ_RX_DR_AND_CLEAR+0x22>
    205a:	69 81       	ldd	r22, Y+1	; 0x01
    205c:	87 e0       	ldi	r24, 0x07	; 7
    205e:	7a df       	rcall	.-268    	; 0x1f54 <NRF_WRITE_REGISTER>
    2060:	81 e0       	ldi	r24, 0x01	; 1
    2062:	0f 90       	pop	r0
    2064:	df 91       	pop	r29
    2066:	cf 91       	pop	r28
    2068:	08 95       	ret

0000206a <NRF_READ_TX_DS_AND_CLEAR>:
    206a:	cf 93       	push	r28
    206c:	df 93       	push	r29
    206e:	1f 92       	push	r1
    2070:	cd b7       	in	r28, 0x3d	; 61
    2072:	de b7       	in	r29, 0x3e	; 62
    2074:	87 e0       	ldi	r24, 0x07	; 7
    2076:	7f df       	rcall	.-258    	; 0x1f76 <NRF_READ_REGISTER>
    2078:	89 83       	std	Y+1, r24	; 0x01
    207a:	99 81       	ldd	r25, Y+1	; 0x01
    207c:	89 2f       	mov	r24, r25
    207e:	80 72       	andi	r24, 0x20	; 32
    2080:	95 ff       	sbrs	r25, 5
    2082:	04 c0       	rjmp	.+8      	; 0x208c <NRF_READ_TX_DS_AND_CLEAR+0x22>
    2084:	69 81       	ldd	r22, Y+1	; 0x01
    2086:	87 e0       	ldi	r24, 0x07	; 7
    2088:	65 df       	rcall	.-310    	; 0x1f54 <NRF_WRITE_REGISTER>
    208a:	81 e0       	ldi	r24, 0x01	; 1
    208c:	0f 90       	pop	r0
    208e:	df 91       	pop	r29
    2090:	cf 91       	pop	r28
    2092:	08 95       	ret

00002094 <NRF_READ_MAX_RT_AND_CLEAR>:
    2094:	cf 93       	push	r28
    2096:	df 93       	push	r29
    2098:	1f 92       	push	r1
    209a:	cd b7       	in	r28, 0x3d	; 61
    209c:	de b7       	in	r29, 0x3e	; 62
    209e:	87 e0       	ldi	r24, 0x07	; 7
    20a0:	6a df       	rcall	.-300    	; 0x1f76 <NRF_READ_REGISTER>
    20a2:	89 83       	std	Y+1, r24	; 0x01
    20a4:	99 81       	ldd	r25, Y+1	; 0x01
    20a6:	89 2f       	mov	r24, r25
    20a8:	80 71       	andi	r24, 0x10	; 16
    20aa:	94 ff       	sbrs	r25, 4
    20ac:	04 c0       	rjmp	.+8      	; 0x20b6 <NRF_READ_MAX_RT_AND_CLEAR+0x22>
    20ae:	69 81       	ldd	r22, Y+1	; 0x01
    20b0:	87 e0       	ldi	r24, 0x07	; 7
    20b2:	50 df       	rcall	.-352    	; 0x1f54 <NRF_WRITE_REGISTER>
    20b4:	81 e0       	ldi	r24, 0x01	; 1
    20b6:	0f 90       	pop	r0
    20b8:	df 91       	pop	r29
    20ba:	cf 91       	pop	r28
    20bc:	08 95       	ret

000020be <NRF_SET_TX_MODE>:
    20be:	cf 93       	push	r28
    20c0:	df 93       	push	r29
    20c2:	1f 92       	push	r1
    20c4:	cd b7       	in	r28, 0x3d	; 61
    20c6:	de b7       	in	r29, 0x3e	; 62
    20c8:	80 e0       	ldi	r24, 0x00	; 0
    20ca:	55 df       	rcall	.-342    	; 0x1f76 <NRF_READ_REGISTER>
    20cc:	89 83       	std	Y+1, r24	; 0x01
    20ce:	89 81       	ldd	r24, Y+1	; 0x01
    20d0:	8e 7f       	andi	r24, 0xFE	; 254
    20d2:	89 83       	std	Y+1, r24	; 0x01
    20d4:	69 81       	ldd	r22, Y+1	; 0x01
    20d6:	80 e0       	ldi	r24, 0x00	; 0
    20d8:	3d df       	rcall	.-390    	; 0x1f54 <NRF_WRITE_REGISTER>
    20da:	0f 90       	pop	r0
    20dc:	df 91       	pop	r29
    20de:	cf 91       	pop	r28
    20e0:	08 95       	ret

000020e2 <NRF_SET_RX_MODE>:
    20e2:	cf 93       	push	r28
    20e4:	df 93       	push	r29
    20e6:	1f 92       	push	r1
    20e8:	cd b7       	in	r28, 0x3d	; 61
    20ea:	de b7       	in	r29, 0x3e	; 62
    20ec:	80 e0       	ldi	r24, 0x00	; 0
    20ee:	43 df       	rcall	.-378    	; 0x1f76 <NRF_READ_REGISTER>
    20f0:	89 83       	std	Y+1, r24	; 0x01
    20f2:	89 81       	ldd	r24, Y+1	; 0x01
    20f4:	81 60       	ori	r24, 0x01	; 1
    20f6:	89 83       	std	Y+1, r24	; 0x01
    20f8:	69 81       	ldd	r22, Y+1	; 0x01
    20fa:	80 e0       	ldi	r24, 0x00	; 0
    20fc:	2b df       	rcall	.-426    	; 0x1f54 <NRF_WRITE_REGISTER>
    20fe:	0f 90       	pop	r0
    2100:	df 91       	pop	r29
    2102:	cf 91       	pop	r28
    2104:	08 95       	ret

00002106 <NRF_UPDATE_PIPE_RX_ADDRESS>:
    2106:	ff 92       	push	r15
    2108:	0f 93       	push	r16
    210a:	1f 93       	push	r17
    210c:	cf 93       	push	r28
    210e:	df 93       	push	r29
    2110:	f6 2e       	mov	r15, r22
    2112:	17 2f       	mov	r17, r23
    2114:	04 2f       	mov	r16, r20
    2116:	1f 98       	cbi	0x03, 7	; 3
    2118:	86 5f       	subi	r24, 0xF6	; 246
    211a:	80 62       	ori	r24, 0x20	; 32
    211c:	16 df       	rcall	.-468    	; 0x1f4a <NRF_SPI_EXCHANGE>
    211e:	80 93 dd 0c 	sts	0x0CDD, r24
    2122:	00 23       	and	r16, r16
    2124:	41 f0       	breq	.+16     	; 0x2136 <NRF_UPDATE_PIPE_RX_ADDRESS+0x30>
    2126:	cf 2d       	mov	r28, r15
    2128:	d1 2f       	mov	r29, r17
    212a:	10 e0       	ldi	r17, 0x00	; 0
    212c:	89 91       	ld	r24, Y+
    212e:	0d df       	rcall	.-486    	; 0x1f4a <NRF_SPI_EXCHANGE>
    2130:	1f 5f       	subi	r17, 0xFF	; 255
    2132:	10 13       	cpse	r17, r16
    2134:	fb cf       	rjmp	.-10     	; 0x212c <NRF_UPDATE_PIPE_RX_ADDRESS+0x26>
    2136:	1f 9a       	sbi	0x03, 7	; 3
    2138:	df 91       	pop	r29
    213a:	cf 91       	pop	r28
    213c:	1f 91       	pop	r17
    213e:	0f 91       	pop	r16
    2140:	ff 90       	pop	r15
    2142:	08 95       	ret

00002144 <NRF_UPDATE_TX_ADDRESS>:
    2144:	ff 92       	push	r15
    2146:	0f 93       	push	r16
    2148:	1f 93       	push	r17
    214a:	cf 93       	push	r28
    214c:	df 93       	push	r29
    214e:	f8 2e       	mov	r15, r24
    2150:	19 2f       	mov	r17, r25
    2152:	06 2f       	mov	r16, r22
    2154:	1f 98       	cbi	0x03, 7	; 3
    2156:	80 e3       	ldi	r24, 0x30	; 48
    2158:	f8 de       	rcall	.-528    	; 0x1f4a <NRF_SPI_EXCHANGE>
    215a:	80 93 dd 0c 	sts	0x0CDD, r24
    215e:	00 23       	and	r16, r16
    2160:	41 f0       	breq	.+16     	; 0x2172 <NRF_UPDATE_TX_ADDRESS+0x2e>
    2162:	cf 2d       	mov	r28, r15
    2164:	d1 2f       	mov	r29, r17
    2166:	10 e0       	ldi	r17, 0x00	; 0
    2168:	89 91       	ld	r24, Y+
    216a:	ef de       	rcall	.-546    	; 0x1f4a <NRF_SPI_EXCHANGE>
    216c:	1f 5f       	subi	r17, 0xFF	; 255
    216e:	10 13       	cpse	r17, r16
    2170:	fb cf       	rjmp	.-10     	; 0x2168 <NRF_UPDATE_TX_ADDRESS+0x24>
    2172:	1f 9a       	sbi	0x03, 7	; 3
    2174:	df 91       	pop	r29
    2176:	cf 91       	pop	r28
    2178:	1f 91       	pop	r17
    217a:	0f 91       	pop	r16
    217c:	ff 90       	pop	r15
    217e:	08 95       	ret

00002180 <NRF_UPDATE_USED_CHANNEL>:
    2180:	80 93 bc 0c 	sts	0x0CBC, r24
    2184:	68 2f       	mov	r22, r24
    2186:	85 e0       	ldi	r24, 0x05	; 5
    2188:	e5 ce       	rjmp	.-566    	; 0x1f54 <NRF_WRITE_REGISTER>
    218a:	08 95       	ret

0000218c <NRF_IO_SETUP>:
}
void NRF_IO_SETUP()
{
	gpio_outputconfg(PORT_DDR_CE,PORT_OUTMOD_CE,OUTPASS,CE_PIN);
    218c:	24 e0       	ldi	r18, 0x04	; 4
    218e:	40 e0       	ldi	r20, 0x00	; 0
    2190:	66 e3       	ldi	r22, 0x36	; 54
    2192:	70 e0       	ldi	r23, 0x00	; 0
    2194:	87 e3       	ldi	r24, 0x37	; 55
    2196:	90 e0       	ldi	r25, 0x00	; 0
    2198:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
	gpio_outputconfg(PORT_DDR_CSN,PORT_OUTMOD_CSN,OUTPASS,CSN_PIN);
    219c:	27 e0       	ldi	r18, 0x07	; 7
    219e:	40 e0       	ldi	r20, 0x00	; 0
    21a0:	61 e2       	ldi	r22, 0x21	; 33
    21a2:	70 e0       	ldi	r23, 0x00	; 0
    21a4:	82 e2       	ldi	r24, 0x22	; 34
    21a6:	90 e0       	ldi	r25, 0x00	; 0
    21a8:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
	gpio_inputconfg(PORT_DDR_IRQ,PORT_INMOD_IRQ,PULLUP_mod,IRQ_PIN);
    21ac:	20 e0       	ldi	r18, 0x00	; 0
    21ae:	41 e0       	ldi	r20, 0x01	; 1
    21b0:	62 e3       	ldi	r22, 0x32	; 50
    21b2:	70 e0       	ldi	r23, 0x00	; 0
    21b4:	81 e3       	ldi	r24, 0x31	; 49
    21b6:	90 e0       	ldi	r25, 0x00	; 0
    21b8:	0c 94 55 08 	jmp	0x10aa	; 0x10aa <gpio_inputconfg>
    21bc:	08 95       	ret

000021be <NRF_SETUP_USED_CONFIG>:
}
void NRF_SETUP_USED_CONFIG()
{
    21be:	0f 93       	push	r16
    21c0:	1f 93       	push	r17
    21c2:	cf 93       	push	r28
    21c4:	df 93       	push	r29
	NRF_SPI_SET_PIN();
    21c6:	1f 9a       	sbi	0x03, 7	; 3
	vTaskDelay(pdMS_TO_TICKS(100));
    21c8:	6a e0       	ldi	r22, 0x0A	; 10
    21ca:	70 e0       	ldi	r23, 0x00	; 0
    21cc:	80 e0       	ldi	r24, 0x00	; 0
    21ce:	90 e0       	ldi	r25, 0x00	; 0
    21d0:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
	NRF1.NRF_CONFIG=(NRF_USED_MASK_RX_DR<<NRF_MASK_RX_DR_BIT)|(NRF_USED_MASK_TX_DR<<NRF_MASK_TX_DS_BIT)|(NRF_USED_MASK_MAX_RT_DR<<NRF_MASK_MAX_RT_BIT)|(NRF_USED_CRC_STATE<<NRF_EN_CRC_BIT)|(NRF_USED_CRC<<NRF_CRCO_BIT)|(1<<NRF_PWR_UP_BIT);
    21d4:	e7 eb       	ldi	r30, 0xB7	; 183
    21d6:	fc e0       	ldi	r31, 0x0C	; 12
    21d8:	8a e0       	ldi	r24, 0x0A	; 10
    21da:	80 83       	st	Z, r24
	NRF_WRITE_REGISTER(NRF_CONFIG_ADDRESS,NRF1.NRF_CONFIG);
    21dc:	60 81       	ld	r22, Z
    21de:	80 e0       	ldi	r24, 0x00	; 0
    21e0:	b9 de       	rcall	.-654    	; 0x1f54 <NRF_WRITE_REGISTER>
	vTaskDelay(pdMS_TO_TICKS(2));
    21e2:	60 e0       	ldi	r22, 0x00	; 0
    21e4:	70 e0       	ldi	r23, 0x00	; 0
    21e6:	cb 01       	movw	r24, r22
    21e8:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
	NRF1.NRF_ENABLE_AA=(NRF_USED_ENNAA_P0<<0)|(NRF_USED_ENNAA_P1<<1)|(NRF_USED_ENNAA_P2<<2)|(NRF_USED_ENNAA_P3<<3)|(NRF_USED_ENNAA_P4<<4)|(NRF_USED_ENNAA_P5<<5);
    21ec:	e8 eb       	ldi	r30, 0xB8	; 184
    21ee:	fc e0       	ldi	r31, 0x0C	; 12
    21f0:	03 e0       	ldi	r16, 0x03	; 3
    21f2:	00 83       	st	Z, r16
	NRF_WRITE_REGISTER(NRF_ENABLE_AA_ADDRESS,NRF1.NRF_ENABLE_AA);
    21f4:	60 81       	ld	r22, Z
    21f6:	81 e0       	ldi	r24, 0x01	; 1
    21f8:	ad de       	rcall	.-678    	; 0x1f54 <NRF_WRITE_REGISTER>
	NRF1.NRF_ENABLE_RX_ADDRESS=(NRF_USED_ERX_P0<<0)|(NRF_USED_ERX_P1<<1)|(NRF_USED_ERX_P2<<2)|(NRF_USED_ERX_P3<<3)|(NRF_USED_ERX_P4<<4)|(NRF_USED_ERX_P5<<5);
    21fa:	e9 eb       	ldi	r30, 0xB9	; 185
    21fc:	fc e0       	ldi	r31, 0x0C	; 12
    21fe:	c2 e0       	ldi	r28, 0x02	; 2
    2200:	c0 83       	st	Z, r28
	NRF_WRITE_REGISTER(NRF_ENABLE_RX_ADDRESS_ADDRESS,NRF1.NRF_ENABLE_RX_ADDRESS);
    2202:	60 81       	ld	r22, Z
    2204:	82 e0       	ldi	r24, 0x02	; 2
    2206:	a6 de       	rcall	.-692    	; 0x1f54 <NRF_WRITE_REGISTER>
	NRF1.NRF_SETUP_AW=2;
    2208:	c0 93 ba 0c 	sts	0x0CBA, r28
	NRF1.NRF_SETUP_RETR=NRF_USED_WAIT_TIME|NRF_USED_RET_COUNT;
    220c:	eb eb       	ldi	r30, 0xBB	; 187
    220e:	fc e0       	ldi	r31, 0x0C	; 12
    2210:	85 e3       	ldi	r24, 0x35	; 53
    2212:	80 83       	st	Z, r24
	NRF_WRITE_REGISTER(NRF_SETUP_RETR_ADDRESS,NRF1.NRF_SETUP_RETR);
    2214:	60 81       	ld	r22, Z
    2216:	84 e0       	ldi	r24, 0x04	; 4
    2218:	9d de       	rcall	.-710    	; 0x1f54 <NRF_WRITE_REGISTER>
	NRF1.NRF_RF_CH=NRF_USED_CH_1;
    221a:	ec eb       	ldi	r30, 0xBC	; 188
    221c:	fc e0       	ldi	r31, 0x0C	; 12
    221e:	c0 83       	st	Z, r28
	NRF_WRITE_REGISTER(NRF_RF_CH_ADDRESS,NRF1.NRF_RF_CH);
    2220:	60 81       	ld	r22, Z
    2222:	85 e0       	ldi	r24, 0x05	; 5
    2224:	97 de       	rcall	.-722    	; 0x1f54 <NRF_WRITE_REGISTER>
	NRF1.NRF_RF_SETUP=NRF_USED_RF_SPEED|NRF_USED_POWER;
    2226:	ed eb       	ldi	r30, 0xBD	; 189
    2228:	fc e0       	ldi	r31, 0x0C	; 12
    222a:	84 e2       	ldi	r24, 0x24	; 36
    222c:	80 83       	st	Z, r24
	NRF_WRITE_REGISTER(NRF_RF_SETUP_ADDRESS,NRF1.NRF_RF_SETUP);
    222e:	60 81       	ld	r22, Z
    2230:	86 e0       	ldi	r24, 0x06	; 6
    2232:	90 de       	rcall	.-736    	; 0x1f54 <NRF_WRITE_REGISTER>
	NRF1.NRF_RX_ADDR_P1[0]=NRF_USED_RX_ADDR_P1&0XFF;
    2234:	80 e1       	ldi	r24, 0x10	; 16
    2236:	80 93 c6 0c 	sts	0x0CC6, r24
	NRF1.NRF_RX_ADDR_P1[1]=(NRF_USED_RX_ADDR_P1>>8)&0XFF;
    223a:	10 e2       	ldi	r17, 0x20	; 32
    223c:	10 93 c7 0c 	sts	0x0CC7, r17
	NRF1.NRF_RX_ADDR_P1[2]=(NRF_USED_RX_ADDR_P1>>16)&0XFF;
    2240:	80 e3       	ldi	r24, 0x30	; 48
    2242:	80 93 c8 0c 	sts	0x0CC8, r24
	NRF1.NRF_RX_ADDR_P1[3]=(NRF_USED_RX_ADDR_P1>>24)&0XFF;
    2246:	80 e4       	ldi	r24, 0x40	; 64
    2248:	80 93 c9 0c 	sts	0x0CC9, r24
	NRF1.NRF_RX_ADDR_P1[4]=(NRF_USED_RX_ADDR_P1>>32)&0XFF;
    224c:	80 e5       	ldi	r24, 0x50	; 80
    224e:	80 93 ca 0c 	sts	0x0CCA, r24
	NRF_UPDATE_PIPE_RX_ADDRESS(1,NRF1.NRF_RX_ADDR_P1,5);
    2252:	45 e0       	ldi	r20, 0x05	; 5
    2254:	66 ec       	ldi	r22, 0xC6	; 198
    2256:	7c e0       	ldi	r23, 0x0C	; 12
    2258:	81 e0       	ldi	r24, 0x01	; 1
    225a:	55 df       	rcall	.-342    	; 0x2106 <NRF_UPDATE_PIPE_RX_ADDRESS>
	NRF1.NRF_RX_PW_P1=32;
    225c:	e5 ed       	ldi	r30, 0xD5	; 213
    225e:	fc e0       	ldi	r31, 0x0C	; 12
    2260:	10 83       	st	Z, r17
	NRF1.NRF_RX_PW_P0=32;
    2262:	c4 ed       	ldi	r28, 0xD4	; 212
    2264:	dc e0       	ldi	r29, 0x0C	; 12
    2266:	18 83       	st	Y, r17
	NRF_WRITE_REGISTER(NRF_RX_PW_P1_ADDRESS,NRF1.NRF_RX_PW_P1);
    2268:	60 81       	ld	r22, Z
    226a:	82 e1       	ldi	r24, 0x12	; 18
    226c:	73 de       	rcall	.-794    	; 0x1f54 <NRF_WRITE_REGISTER>
	NRF_WRITE_REGISTER(NRF_RX_PW_P0_ADDRESS,NRF1.NRF_RX_PW_P0);
    226e:	68 81       	ld	r22, Y
    2270:	81 e1       	ldi	r24, 0x11	; 17
    2272:	70 de       	rcall	.-800    	; 0x1f54 <NRF_WRITE_REGISTER>
	NRF1.NRF_DYNPD=0b00000011;
    2274:	eb ed       	ldi	r30, 0xDB	; 219
    2276:	fc e0       	ldi	r31, 0x0C	; 12
    2278:	00 83       	st	Z, r16
	NRF_WRITE_REGISTER(NRF_DYNPD_ADDRESS,NRF1.NRF_DYNPD);
    227a:	60 81       	ld	r22, Z
    227c:	8c e1       	ldi	r24, 0x1C	; 28
    227e:	6a de       	rcall	.-812    	; 0x1f54 <NRF_WRITE_REGISTER>
	NRF1.NRF_FEATURE=(NRF_USED_PL_WITH_ACK_STATE_AT_FIRST<<1)|(NRF_USED_EN_DPL<<2);
    2280:	ec ed       	ldi	r30, 0xDC	; 220
    2282:	fc e0       	ldi	r31, 0x0C	; 12
    2284:	84 e0       	ldi	r24, 0x04	; 4
    2286:	80 83       	st	Z, r24
	NRF_WRITE_REGISTER(NRF_FEATURE_ADDRESS,NRF1.NRF_FEATURE);
    2288:	60 81       	ld	r22, Z
    228a:	8d e1       	ldi	r24, 0x1D	; 29
    228c:	63 de       	rcall	.-826    	; 0x1f54 <NRF_WRITE_REGISTER>
	
	
	TEST_UART_SEND_str("state:");
    228e:	8f e5       	ldi	r24, 0x5F	; 95
    2290:	92 e0       	ldi	r25, 0x02	; 2
    2292:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	TEST_UART_SEND_VALUE(NRF_STATUS);
    2296:	20 91 dd 0c 	lds	r18, 0x0CDD
    229a:	30 e0       	ldi	r19, 0x00	; 0
    229c:	40 e0       	ldi	r20, 0x00	; 0
    229e:	50 e0       	ldi	r21, 0x00	; 0
    22a0:	60 e0       	ldi	r22, 0x00	; 0
    22a2:	70 e0       	ldi	r23, 0x00	; 0
    22a4:	80 e0       	ldi	r24, 0x00	; 0
    22a6:	90 e0       	ldi	r25, 0x00	; 0
    22a8:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
}
    22ac:	df 91       	pop	r29
    22ae:	cf 91       	pop	r28
    22b0:	1f 91       	pop	r17
    22b2:	0f 91       	pop	r16
    22b4:	08 95       	ret

000022b6 <NRF_SEND_DATA_WITH_ACK>:

unsigned char NRF_SEND_DATA_WITH_ACK(unsigned char *ADDRESS,unsigned char ADDRESS_LENGTH,unsigned char *DATA,unsigned char DATA_LENGTH)
{
    22b6:	ef 92       	push	r14
    22b8:	ff 92       	push	r15
    22ba:	0f 93       	push	r16
    22bc:	1f 93       	push	r17
    22be:	cf 93       	push	r28
    22c0:	df 93       	push	r29
    22c2:	ec 01       	movw	r28, r24
    22c4:	f6 2e       	mov	r15, r22
    22c6:	8a 01       	movw	r16, r20
    22c8:	e2 2e       	mov	r14, r18
	NRF_CLEAR_CE();
    22ca:	c4 98       	cbi	0x18, 4	; 24
	vTaskDelay(pdMS_TO_TICKS(2));
    22cc:	60 e0       	ldi	r22, 0x00	; 0
    22ce:	70 e0       	ldi	r23, 0x00	; 0
    22d0:	cb 01       	movw	r24, r22
    22d2:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
	NRF_WRITE_REGISTER(NRF_ENABLE_RX_ADDRESS_ADDRESS,0b00000011);
    22d6:	63 e0       	ldi	r22, 0x03	; 3
    22d8:	82 e0       	ldi	r24, 0x02	; 2
    22da:	3c de       	rcall	.-904    	; 0x1f54 <NRF_WRITE_REGISTER>
	NRF_WRITE_REGISTER(NRF_STATUS_ADDRESS,0b01110000);
    22dc:	60 e7       	ldi	r22, 0x70	; 112
    22de:	87 e0       	ldi	r24, 0x07	; 7
    22e0:	39 de       	rcall	.-910    	; 0x1f54 <NRF_WRITE_REGISTER>
	NRF_UPDATE_TX_ADDRESS(ADDRESS, ADDRESS_LENGTH);
    22e2:	6f 2d       	mov	r22, r15
    22e4:	ce 01       	movw	r24, r28
    22e6:	2e df       	rcall	.-420    	; 0x2144 <NRF_UPDATE_TX_ADDRESS>
	NRF_UPDATE_PIPE_RX_ADDRESS(0,ADDRESS,ADDRESS_LENGTH);
    22e8:	4f 2d       	mov	r20, r15
    22ea:	be 01       	movw	r22, r28
    22ec:	80 e0       	ldi	r24, 0x00	; 0
    22ee:	0b df       	rcall	.-490    	; 0x2106 <NRF_UPDATE_PIPE_RX_ADDRESS>
	NRF_FLUSH_TX_BUFFER();
    22f0:	90 de       	rcall	.-736    	; 0x2012 <NRF_FLUSH_TX_BUFFER>
	NRF_SET_TX_MODE();
    22f2:	e5 de       	rcall	.-566    	; 0x20be <NRF_SET_TX_MODE>
	NRF_W_TX_PAYLOAD_ACK(DATA,DATA_LENGTH);
    22f4:	6e 2d       	mov	r22, r14
    22f6:	c8 01       	movw	r24, r16
    22f8:	6e de       	rcall	.-804    	; 0x1fd6 <NRF_W_TX_PAYLOAD_ACK>
	NRF_SET_CE();
    22fa:	c4 9a       	sbi	0x18, 4	; 24
	vTaskDelay(pdMS_TO_TICKS(2));
    22fc:	60 e0       	ldi	r22, 0x00	; 0
    22fe:	70 e0       	ldi	r23, 0x00	; 0
    2300:	cb 01       	movw	r24, r22
    2302:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
	
	/*while (NRF_IS_IRQ_SET())vTaskDelay(pdMS_TO_TICKS(1));*/
	
	
	if(pdPASS!=xSemaphoreTake(NRF_IRQ_SEMAPHORE,pdMS_TO_TICKS(1000)))
    2306:	44 e6       	ldi	r20, 0x64	; 100
    2308:	50 e0       	ldi	r21, 0x00	; 0
    230a:	60 e0       	ldi	r22, 0x00	; 0
    230c:	70 e0       	ldi	r23, 0x00	; 0
    230e:	80 91 de 0c 	lds	r24, 0x0CDE
    2312:	90 91 df 0c 	lds	r25, 0x0CDF
    2316:	b9 d5       	rcall	.+2930   	; 0x2e8a <xQueueSemaphoreTake>
    2318:	81 30       	cpi	r24, 0x01	; 1
    231a:	31 f0       	breq	.+12     	; 0x2328 <NRF_SEND_DATA_WITH_ACK+0x72>
	{
		TEST_UART_SEND_str("DELAY 1 SEC\n");
    231c:	86 e6       	ldi	r24, 0x66	; 102
    231e:	92 e0       	ldi	r25, 0x02	; 2
    2320:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
		return 0;
    2324:	80 e0       	ldi	r24, 0x00	; 0
    2326:	12 c0       	rjmp	.+36     	; 0x234c <NRF_SEND_DATA_WITH_ACK+0x96>
	}
	
	NRF_CLEAR_CE();
    2328:	c4 98       	cbi	0x18, 4	; 24
	NRF_WRITE_REGISTER(NRF_ENABLE_RX_ADDRESS_ADDRESS,0b00000010);
    232a:	62 e0       	ldi	r22, 0x02	; 2
    232c:	82 e0       	ldi	r24, 0x02	; 2
    232e:	12 de       	rcall	.-988    	; 0x1f54 <NRF_WRITE_REGISTER>
	if (NRF_READ_TX_DS_AND_CLEAR())
    2330:	9c de       	rcall	.-712    	; 0x206a <NRF_READ_TX_DS_AND_CLEAR>
    2332:	c8 2f       	mov	r28, r24
    2334:	81 11       	cpse	r24, r1
    2336:	09 c0       	rjmp	.+18     	; 0x234a <NRF_SEND_DATA_WITH_ACK+0x94>
	{
		return 1;
	}
	if (NRF_READ_MAX_RT_AND_CLEAR())
    2338:	ad de       	rcall	.-678    	; 0x2094 <NRF_READ_MAX_RT_AND_CLEAR>
    233a:	88 23       	and	r24, r24
    233c:	39 f0       	breq	.+14     	; 0x234c <NRF_SEND_DATA_WITH_ACK+0x96>
	{
		TEST_UART_SEND_str("heree\n");
    233e:	83 e7       	ldi	r24, 0x73	; 115
    2340:	92 e0       	ldi	r25, 0x02	; 2
    2342:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
		return 0;
    2346:	8c 2f       	mov	r24, r28
    2348:	01 c0       	rjmp	.+2      	; 0x234c <NRF_SEND_DATA_WITH_ACK+0x96>
	
	NRF_CLEAR_CE();
	NRF_WRITE_REGISTER(NRF_ENABLE_RX_ADDRESS_ADDRESS,0b00000010);
	if (NRF_READ_TX_DS_AND_CLEAR())
	{
		return 1;
    234a:	81 e0       	ldi	r24, 0x01	; 1
	{
		TEST_UART_SEND_str("heree\n");
		return 0;
	}
	return 0;
}
    234c:	df 91       	pop	r29
    234e:	cf 91       	pop	r28
    2350:	1f 91       	pop	r17
    2352:	0f 91       	pop	r16
    2354:	ff 90       	pop	r15
    2356:	ef 90       	pop	r14
    2358:	08 95       	ret

0000235a <NRF_START_RX_MODE>:

void NRF_START_RX_MODE()
{
	NRF_CLEAR_CE();
    235a:	c4 98       	cbi	0x18, 4	; 24
	vTaskDelay(pdMS_TO_TICKS(2));
    235c:	60 e0       	ldi	r22, 0x00	; 0
    235e:	70 e0       	ldi	r23, 0x00	; 0
    2360:	cb 01       	movw	r24, r22
    2362:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
	NRF_WRITE_REGISTER(NRF_STATUS_ADDRESS,0b01110000);
    2366:	60 e7       	ldi	r22, 0x70	; 112
    2368:	87 e0       	ldi	r24, 0x07	; 7
    236a:	f4 dd       	rcall	.-1048   	; 0x1f54 <NRF_WRITE_REGISTER>
	NRF_FLUSH_RX_BUFFER();
    236c:	59 de       	rcall	.-846    	; 0x2020 <NRF_FLUSH_RX_BUFFER>
	NRF_SET_RX_MODE();
    236e:	b9 de       	rcall	.-654    	; 0x20e2 <NRF_SET_RX_MODE>
	NRF_SET_CE();
    2370:	c4 9a       	sbi	0x18, 4	; 24
    2372:	08 95       	ret

00002374 <NRF_STOP_RX_MODE>:
}

void NRF_STOP_RX_MODE()
{
		NRF_CLEAR_CE();
    2374:	c4 98       	cbi	0x18, 4	; 24
		vTaskDelay(pdMS_TO_TICKS(2));
    2376:	60 e0       	ldi	r22, 0x00	; 0
    2378:	70 e0       	ldi	r23, 0x00	; 0
    237a:	cb 01       	movw	r24, r22
    237c:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
		NRF_WRITE_REGISTER(NRF_STATUS_ADDRESS,0b01110000);
    2380:	60 e7       	ldi	r22, 0x70	; 112
    2382:	87 e0       	ldi	r24, 0x07	; 7
    2384:	e7 dd       	rcall	.-1074   	; 0x1f54 <NRF_WRITE_REGISTER>
		NRF_FLUSH_RX_BUFFER();
    2386:	4c ce       	rjmp	.-872    	; 0x2020 <NRF_FLUSH_RX_BUFFER>
    2388:	08 95       	ret

0000238a <NRF_CHECK_RX_PL>:
}

unsigned char NRF_CHECK_RX_PL(unsigned char *DATA,unsigned char* LENGTH)
{
    238a:	0f 93       	push	r16
    238c:	1f 93       	push	r17
    238e:	cf 93       	push	r28
    2390:	df 93       	push	r29
    2392:	ec 01       	movw	r28, r24
    2394:	8b 01       	movw	r16, r22
	if (NRF_IS_IRQ_CLEAR())
    2396:	80 99       	sbic	0x10, 0	; 16
    2398:	0c c0       	rjmp	.+24     	; 0x23b2 <NRF_CHECK_RX_PL+0x28>
	{
		if (NRF_READ_RX_DR_AND_CLEAR())
    239a:	52 de       	rcall	.-860    	; 0x2040 <NRF_READ_RX_DR_AND_CLEAR>
    239c:	88 23       	and	r24, r24
    239e:	51 f0       	breq	.+20     	; 0x23b4 <NRF_CHECK_RX_PL+0x2a>
		{
			NRF_CLEAR_CE();
    23a0:	c4 98       	cbi	0x18, 4	; 24
			*LENGTH=NRF_READ_LENGTH_RX_PL();
    23a2:	45 de       	rcall	.-886    	; 0x202e <NRF_READ_LENGTH_RX_PL>
    23a4:	f8 01       	movw	r30, r16
    23a6:	80 83       	st	Z, r24
			NRF_R_RX_PAYLOAD_DYNAMIC(DATA,*LENGTH);	
    23a8:	68 2f       	mov	r22, r24
    23aa:	ce 01       	movw	r24, r28
    23ac:	f5 dd       	rcall	.-1046   	; 0x1f98 <NRF_R_RX_PAYLOAD_DYNAMIC>
			return 1;
    23ae:	81 e0       	ldi	r24, 0x01	; 1
    23b0:	01 c0       	rjmp	.+2      	; 0x23b4 <NRF_CHECK_RX_PL+0x2a>
		}
		return 0;
	}
	else
	{
		return 0;
    23b2:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    23b4:	df 91       	pop	r29
    23b6:	cf 91       	pop	r28
    23b8:	1f 91       	pop	r17
    23ba:	0f 91       	pop	r16
    23bc:	08 95       	ret

000023be <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    23be:	0f 93       	push	r16
    23c0:	1f 93       	push	r17
    23c2:	cf 93       	push	r28
    23c4:	df 93       	push	r29
    23c6:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    23c8:	dc d7       	rcall	.+4024   	; 0x3382 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    23ca:	80 91 9b 04 	lds	r24, 0x049B
    23ce:	81 11       	cpse	r24, r1
    23d0:	1e c0       	rjmp	.+60     	; 0x240e <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    23d2:	e5 ea       	ldi	r30, 0xA5	; 165
    23d4:	f4 e0       	ldi	r31, 0x04	; 4
    23d6:	f0 93 a1 04 	sts	0x04A1, r31
    23da:	e0 93 a0 04 	sts	0x04A0, r30
	xStart.xBlockSize = ( size_t ) 0;
    23de:	10 92 a3 04 	sts	0x04A3, r1
    23e2:	10 92 a2 04 	sts	0x04A2, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    23e6:	8f e2       	ldi	r24, 0x2F	; 47
    23e8:	97 e0       	ldi	r25, 0x07	; 7
    23ea:	90 93 9f 04 	sts	0x049F, r25
    23ee:	80 93 9e 04 	sts	0x049E, r24
	xEnd.pxNextFreeBlock = NULL;
    23f2:	ac e9       	ldi	r26, 0x9C	; 156
    23f4:	b4 e0       	ldi	r27, 0x04	; 4
    23f6:	11 96       	adiw	r26, 0x01	; 1
    23f8:	1c 92       	st	X, r1
    23fa:	1e 92       	st	-X, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    23fc:	90 93 a8 04 	sts	0x04A8, r25
    2400:	80 93 a7 04 	sts	0x04A7, r24
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    2404:	b1 83       	std	Z+1, r27	; 0x01
    2406:	a0 83       	st	Z, r26
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
    2408:	81 e0       	ldi	r24, 0x01	; 1
    240a:	80 93 9b 04 	sts	0x049B, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    240e:	20 97       	sbiw	r28, 0x00	; 0
    2410:	09 f4       	brne	.+2      	; 0x2414 <pvPortMalloc+0x56>
    2412:	5f c0       	rjmp	.+190    	; 0x24d2 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
    2414:	9e 01       	movw	r18, r28
    2416:	2c 5f       	subi	r18, 0xFC	; 252
    2418:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    241a:	23 96       	adiw	r28, 0x03	; 3
    241c:	ce 32       	cpi	r28, 0x2E	; 46
    241e:	d7 40       	sbci	r29, 0x07	; 7
    2420:	08 f0       	brcs	.+2      	; 0x2424 <pvPortMalloc+0x66>
    2422:	5a c0       	rjmp	.+180    	; 0x24d8 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    2424:	e0 91 a0 04 	lds	r30, 0x04A0
    2428:	f0 91 a1 04 	lds	r31, 0x04A1

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    242c:	a0 ea       	ldi	r26, 0xA0	; 160
    242e:	b4 e0       	ldi	r27, 0x04	; 4
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    2430:	82 81       	ldd	r24, Z+2	; 0x02
    2432:	93 81       	ldd	r25, Z+3	; 0x03
    2434:	82 17       	cp	r24, r18
    2436:	93 07       	cpc	r25, r19
    2438:	38 f4       	brcc	.+14     	; 0x2448 <pvPortMalloc+0x8a>
    243a:	80 81       	ld	r24, Z
    243c:	91 81       	ldd	r25, Z+1	; 0x01
    243e:	00 97       	sbiw	r24, 0x00	; 0
    2440:	19 f0       	breq	.+6      	; 0x2448 <pvPortMalloc+0x8a>
    2442:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    2444:	fc 01       	movw	r30, r24
    2446:	f4 cf       	rjmp	.-24     	; 0x2430 <pvPortMalloc+0x72>
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    2448:	c4 e0       	ldi	r28, 0x04	; 4
    244a:	ec 39       	cpi	r30, 0x9C	; 156
    244c:	fc 07       	cpc	r31, r28
    244e:	09 f4       	brne	.+2      	; 0x2452 <pvPortMalloc+0x94>
    2450:	46 c0       	rjmp	.+140    	; 0x24de <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    2452:	cd 91       	ld	r28, X+
    2454:	dc 91       	ld	r29, X
    2456:	11 97       	sbiw	r26, 0x01	; 1
    2458:	8e 01       	movw	r16, r28
    245a:	0c 5f       	subi	r16, 0xFC	; 252
    245c:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    245e:	80 81       	ld	r24, Z
    2460:	91 81       	ldd	r25, Z+1	; 0x01
    2462:	8d 93       	st	X+, r24
    2464:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    2466:	82 81       	ldd	r24, Z+2	; 0x02
    2468:	93 81       	ldd	r25, Z+3	; 0x03
    246a:	82 1b       	sub	r24, r18
    246c:	93 0b       	sbc	r25, r19
    246e:	89 30       	cpi	r24, 0x09	; 9
    2470:	91 05       	cpc	r25, r1
    2472:	10 f1       	brcs	.+68     	; 0x24b8 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    2474:	bf 01       	movw	r22, r30
    2476:	62 0f       	add	r22, r18
    2478:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    247a:	db 01       	movw	r26, r22
    247c:	13 96       	adiw	r26, 0x03	; 3
    247e:	9c 93       	st	X, r25
    2480:	8e 93       	st	-X, r24
    2482:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
    2484:	33 83       	std	Z+3, r19	; 0x03
    2486:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    2488:	12 96       	adiw	r26, 0x02	; 2
    248a:	4d 91       	ld	r20, X+
    248c:	5c 91       	ld	r21, X
    248e:	13 97       	sbiw	r26, 0x03	; 3
    2490:	80 ea       	ldi	r24, 0xA0	; 160
    2492:	94 e0       	ldi	r25, 0x04	; 4
    2494:	ec 01       	movw	r28, r24
    2496:	a8 81       	ld	r26, Y
    2498:	b9 81       	ldd	r27, Y+1	; 0x01
    249a:	12 96       	adiw	r26, 0x02	; 2
    249c:	2d 91       	ld	r18, X+
    249e:	3c 91       	ld	r19, X
    24a0:	13 97       	sbiw	r26, 0x03	; 3
    24a2:	24 17       	cp	r18, r20
    24a4:	35 07       	cpc	r19, r21
    24a6:	10 f4       	brcc	.+4      	; 0x24ac <pvPortMalloc+0xee>
    24a8:	cd 01       	movw	r24, r26
    24aa:	f4 cf       	rjmp	.-24     	; 0x2494 <pvPortMalloc+0xd6>
    24ac:	eb 01       	movw	r28, r22
    24ae:	b9 83       	std	Y+1, r27	; 0x01
    24b0:	a8 83       	st	Y, r26
    24b2:	dc 01       	movw	r26, r24
    24b4:	6d 93       	st	X+, r22
    24b6:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    24b8:	80 91 08 01 	lds	r24, 0x0108
    24bc:	90 91 09 01 	lds	r25, 0x0109
    24c0:	22 81       	ldd	r18, Z+2	; 0x02
    24c2:	33 81       	ldd	r19, Z+3	; 0x03
    24c4:	82 1b       	sub	r24, r18
    24c6:	93 0b       	sbc	r25, r19
    24c8:	90 93 09 01 	sts	0x0109, r25
    24cc:	80 93 08 01 	sts	0x0108, r24
    24d0:	08 c0       	rjmp	.+16     	; 0x24e2 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    24d2:	00 e0       	ldi	r16, 0x00	; 0
    24d4:	10 e0       	ldi	r17, 0x00	; 0
    24d6:	05 c0       	rjmp	.+10     	; 0x24e2 <pvPortMalloc+0x124>
    24d8:	00 e0       	ldi	r16, 0x00	; 0
    24da:	10 e0       	ldi	r17, 0x00	; 0
    24dc:	02 c0       	rjmp	.+4      	; 0x24e2 <pvPortMalloc+0x124>
    24de:	00 e0       	ldi	r16, 0x00	; 0
    24e0:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    24e2:	0e 94 9b 1a 	call	0x3536	; 0x3536 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    24e6:	c8 01       	movw	r24, r16
    24e8:	df 91       	pop	r29
    24ea:	cf 91       	pop	r28
    24ec:	1f 91       	pop	r17
    24ee:	0f 91       	pop	r16
    24f0:	08 95       	ret

000024f2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    24f2:	0f 93       	push	r16
    24f4:	1f 93       	push	r17
    24f6:	cf 93       	push	r28
    24f8:	df 93       	push	r29
    24fa:	ec 01       	movw	r28, r24
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    24fc:	00 97       	sbiw	r24, 0x00	; 0
    24fe:	29 f1       	breq	.+74     	; 0x254a <vPortFree+0x58>
		before it. */
		puc -= heapSTRUCT_SIZE;

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
    2500:	8c 01       	movw	r16, r24
    2502:	04 50       	subi	r16, 0x04	; 4
    2504:	11 09       	sbc	r17, r1

		vTaskSuspendAll();
    2506:	3d d7       	rcall	.+3706   	; 0x3382 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    2508:	f8 01       	movw	r30, r16
    250a:	42 81       	ldd	r20, Z+2	; 0x02
    250c:	53 81       	ldd	r21, Z+3	; 0x03
    250e:	a0 ea       	ldi	r26, 0xA0	; 160
    2510:	b4 e0       	ldi	r27, 0x04	; 4
    2512:	ed 91       	ld	r30, X+
    2514:	fc 91       	ld	r31, X
    2516:	11 97       	sbiw	r26, 0x01	; 1
    2518:	22 81       	ldd	r18, Z+2	; 0x02
    251a:	33 81       	ldd	r19, Z+3	; 0x03
    251c:	24 17       	cp	r18, r20
    251e:	35 07       	cpc	r19, r21
    2520:	10 f4       	brcc	.+4      	; 0x2526 <vPortFree+0x34>
    2522:	df 01       	movw	r26, r30
    2524:	f6 cf       	rjmp	.-20     	; 0x2512 <vPortFree+0x20>
    2526:	24 97       	sbiw	r28, 0x04	; 4
    2528:	f9 83       	std	Y+1, r31	; 0x01
    252a:	e8 83       	st	Y, r30
    252c:	0d 93       	st	X+, r16
    252e:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    2530:	20 91 08 01 	lds	r18, 0x0108
    2534:	30 91 09 01 	lds	r19, 0x0109
    2538:	8a 81       	ldd	r24, Y+2	; 0x02
    253a:	9b 81       	ldd	r25, Y+3	; 0x03
    253c:	82 0f       	add	r24, r18
    253e:	93 1f       	adc	r25, r19
    2540:	90 93 09 01 	sts	0x0109, r25
    2544:	80 93 08 01 	sts	0x0108, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    2548:	f6 d7       	rcall	.+4076   	; 0x3536 <xTaskResumeAll>
	}
}
    254a:	df 91       	pop	r29
    254c:	cf 91       	pop	r28
    254e:	1f 91       	pop	r17
    2550:	0f 91       	pop	r16
    2552:	08 95       	ret

00002554 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2554:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2556:	03 96       	adiw	r24, 0x03	; 3
    2558:	92 83       	std	Z+2, r25	; 0x02
    255a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    255c:	4f ef       	ldi	r20, 0xFF	; 255
    255e:	5f ef       	ldi	r21, 0xFF	; 255
    2560:	ba 01       	movw	r22, r20
    2562:	43 83       	std	Z+3, r20	; 0x03
    2564:	54 83       	std	Z+4, r21	; 0x04
    2566:	65 83       	std	Z+5, r22	; 0x05
    2568:	76 83       	std	Z+6, r23	; 0x06

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    256a:	90 87       	std	Z+8, r25	; 0x08
    256c:	87 83       	std	Z+7, r24	; 0x07
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    256e:	92 87       	std	Z+10, r25	; 0x0a
    2570:	81 87       	std	Z+9, r24	; 0x09

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2572:	10 82       	st	Z, r1
    2574:	08 95       	ret

00002576 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    2576:	fc 01       	movw	r30, r24
    2578:	13 86       	std	Z+11, r1	; 0x0b
    257a:	12 86       	std	Z+10, r1	; 0x0a
    257c:	08 95       	ret

0000257e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    257e:	cf 93       	push	r28
    2580:	df 93       	push	r29
    2582:	9c 01       	movw	r18, r24
    2584:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2586:	dc 01       	movw	r26, r24
    2588:	11 96       	adiw	r26, 0x01	; 1
    258a:	cd 91       	ld	r28, X+
    258c:	dc 91       	ld	r29, X
    258e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2590:	d5 83       	std	Z+5, r29	; 0x05
    2592:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2594:	8e 81       	ldd	r24, Y+6	; 0x06
    2596:	9f 81       	ldd	r25, Y+7	; 0x07
    2598:	97 83       	std	Z+7, r25	; 0x07
    259a:	86 83       	std	Z+6, r24	; 0x06

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    259c:	8e 81       	ldd	r24, Y+6	; 0x06
    259e:	9f 81       	ldd	r25, Y+7	; 0x07
    25a0:	dc 01       	movw	r26, r24
    25a2:	15 96       	adiw	r26, 0x05	; 5
    25a4:	7c 93       	st	X, r23
    25a6:	6e 93       	st	-X, r22
    25a8:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxPrevious = pxNewListItem;
    25aa:	7f 83       	std	Y+7, r23	; 0x07
    25ac:	6e 83       	std	Y+6, r22	; 0x06

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    25ae:	33 87       	std	Z+11, r19	; 0x0b
    25b0:	22 87       	std	Z+10, r18	; 0x0a

	( pxList->uxNumberOfItems )++;
    25b2:	f9 01       	movw	r30, r18
    25b4:	80 81       	ld	r24, Z
    25b6:	8f 5f       	subi	r24, 0xFF	; 255
    25b8:	80 83       	st	Z, r24
}
    25ba:	df 91       	pop	r29
    25bc:	cf 91       	pop	r28
    25be:	08 95       	ret

000025c0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    25c0:	0f 93       	push	r16
    25c2:	1f 93       	push	r17
    25c4:	cf 93       	push	r28
    25c6:	df 93       	push	r29
    25c8:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    25ca:	08 81       	ld	r16, Y
    25cc:	19 81       	ldd	r17, Y+1	; 0x01
    25ce:	2a 81       	ldd	r18, Y+2	; 0x02
    25d0:	3b 81       	ldd	r19, Y+3	; 0x03
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    25d2:	0f 3f       	cpi	r16, 0xFF	; 255
    25d4:	4f ef       	ldi	r20, 0xFF	; 255
    25d6:	14 07       	cpc	r17, r20
    25d8:	24 07       	cpc	r18, r20
    25da:	34 07       	cpc	r19, r20
    25dc:	21 f4       	brne	.+8      	; 0x25e6 <vListInsert+0x26>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    25de:	fc 01       	movw	r30, r24
    25e0:	a1 85       	ldd	r26, Z+9	; 0x09
    25e2:	b2 85       	ldd	r27, Z+10	; 0x0a
    25e4:	11 c0       	rjmp	.+34     	; 0x2608 <vListInsert+0x48>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    25e6:	dc 01       	movw	r26, r24
    25e8:	13 96       	adiw	r26, 0x03	; 3
    25ea:	14 96       	adiw	r26, 0x04	; 4
    25ec:	ed 91       	ld	r30, X+
    25ee:	fc 91       	ld	r31, X
    25f0:	15 97       	sbiw	r26, 0x05	; 5
    25f2:	40 81       	ld	r20, Z
    25f4:	51 81       	ldd	r21, Z+1	; 0x01
    25f6:	62 81       	ldd	r22, Z+2	; 0x02
    25f8:	73 81       	ldd	r23, Z+3	; 0x03
    25fa:	04 17       	cp	r16, r20
    25fc:	15 07       	cpc	r17, r21
    25fe:	26 07       	cpc	r18, r22
    2600:	37 07       	cpc	r19, r23
    2602:	10 f0       	brcs	.+4      	; 0x2608 <vListInsert+0x48>
    2604:	df 01       	movw	r26, r30
    2606:	f1 cf       	rjmp	.-30     	; 0x25ea <vListInsert+0x2a>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2608:	14 96       	adiw	r26, 0x04	; 4
    260a:	ed 91       	ld	r30, X+
    260c:	fc 91       	ld	r31, X
    260e:	15 97       	sbiw	r26, 0x05	; 5
    2610:	fd 83       	std	Y+5, r31	; 0x05
    2612:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2614:	d7 83       	std	Z+7, r29	; 0x07
    2616:	c6 83       	std	Z+6, r28	; 0x06
	pxNewListItem->pxPrevious = pxIterator;
    2618:	bf 83       	std	Y+7, r27	; 0x07
    261a:	ae 83       	std	Y+6, r26	; 0x06
	pxIterator->pxNext = pxNewListItem;
    261c:	15 96       	adiw	r26, 0x05	; 5
    261e:	dc 93       	st	X, r29
    2620:	ce 93       	st	-X, r28
    2622:	14 97       	sbiw	r26, 0x04	; 4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    2624:	9b 87       	std	Y+11, r25	; 0x0b
    2626:	8a 87       	std	Y+10, r24	; 0x0a

	( pxList->uxNumberOfItems )++;
    2628:	fc 01       	movw	r30, r24
    262a:	20 81       	ld	r18, Z
    262c:	2f 5f       	subi	r18, 0xFF	; 255
    262e:	20 83       	st	Z, r18
}
    2630:	df 91       	pop	r29
    2632:	cf 91       	pop	r28
    2634:	1f 91       	pop	r17
    2636:	0f 91       	pop	r16
    2638:	08 95       	ret

0000263a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    263a:	cf 93       	push	r28
    263c:	df 93       	push	r29
    263e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    2640:	a2 85       	ldd	r26, Z+10	; 0x0a
    2642:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2644:	c4 81       	ldd	r28, Z+4	; 0x04
    2646:	d5 81       	ldd	r29, Z+5	; 0x05
    2648:	86 81       	ldd	r24, Z+6	; 0x06
    264a:	97 81       	ldd	r25, Z+7	; 0x07
    264c:	9f 83       	std	Y+7, r25	; 0x07
    264e:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2650:	c6 81       	ldd	r28, Z+6	; 0x06
    2652:	d7 81       	ldd	r29, Z+7	; 0x07
    2654:	84 81       	ldd	r24, Z+4	; 0x04
    2656:	95 81       	ldd	r25, Z+5	; 0x05
    2658:	9d 83       	std	Y+5, r25	; 0x05
    265a:	8c 83       	std	Y+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    265c:	11 96       	adiw	r26, 0x01	; 1
    265e:	cd 91       	ld	r28, X+
    2660:	dc 91       	ld	r29, X
    2662:	12 97       	sbiw	r26, 0x02	; 2
    2664:	ce 17       	cp	r28, r30
    2666:	df 07       	cpc	r29, r31
    2668:	31 f4       	brne	.+12     	; 0x2676 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    266a:	8e 81       	ldd	r24, Y+6	; 0x06
    266c:	9f 81       	ldd	r25, Y+7	; 0x07
    266e:	12 96       	adiw	r26, 0x02	; 2
    2670:	9c 93       	st	X, r25
    2672:	8e 93       	st	-X, r24
    2674:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    2676:	13 86       	std	Z+11, r1	; 0x0b
    2678:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
    267a:	8c 91       	ld	r24, X
    267c:	81 50       	subi	r24, 0x01	; 1
    267e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    2680:	8c 91       	ld	r24, X
}
    2682:	df 91       	pop	r29
    2684:	cf 91       	pop	r28
    2686:	08 95       	ret

00002688 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2688:	31 e1       	ldi	r19, 0x11	; 17
    268a:	fc 01       	movw	r30, r24
    268c:	30 83       	st	Z, r19
    268e:	31 97       	sbiw	r30, 0x01	; 1
    2690:	22 e2       	ldi	r18, 0x22	; 34
    2692:	20 83       	st	Z, r18
    2694:	31 97       	sbiw	r30, 0x01	; 1
    2696:	a3 e3       	ldi	r26, 0x33	; 51
    2698:	a0 83       	st	Z, r26
    269a:	31 97       	sbiw	r30, 0x01	; 1
    269c:	60 83       	st	Z, r22
    269e:	31 97       	sbiw	r30, 0x01	; 1
    26a0:	70 83       	st	Z, r23
    26a2:	31 97       	sbiw	r30, 0x01	; 1
    26a4:	10 82       	st	Z, r1
    26a6:	31 97       	sbiw	r30, 0x01	; 1
    26a8:	60 e8       	ldi	r22, 0x80	; 128
    26aa:	60 83       	st	Z, r22
    26ac:	31 97       	sbiw	r30, 0x01	; 1
    26ae:	10 82       	st	Z, r1
    26b0:	31 97       	sbiw	r30, 0x01	; 1
    26b2:	62 e0       	ldi	r22, 0x02	; 2
    26b4:	60 83       	st	Z, r22
    26b6:	31 97       	sbiw	r30, 0x01	; 1
    26b8:	63 e0       	ldi	r22, 0x03	; 3
    26ba:	60 83       	st	Z, r22
    26bc:	31 97       	sbiw	r30, 0x01	; 1
    26be:	64 e0       	ldi	r22, 0x04	; 4
    26c0:	60 83       	st	Z, r22
    26c2:	31 97       	sbiw	r30, 0x01	; 1
    26c4:	65 e0       	ldi	r22, 0x05	; 5
    26c6:	60 83       	st	Z, r22
    26c8:	31 97       	sbiw	r30, 0x01	; 1
    26ca:	66 e0       	ldi	r22, 0x06	; 6
    26cc:	60 83       	st	Z, r22
    26ce:	31 97       	sbiw	r30, 0x01	; 1
    26d0:	67 e0       	ldi	r22, 0x07	; 7
    26d2:	60 83       	st	Z, r22
    26d4:	31 97       	sbiw	r30, 0x01	; 1
    26d6:	68 e0       	ldi	r22, 0x08	; 8
    26d8:	60 83       	st	Z, r22
    26da:	31 97       	sbiw	r30, 0x01	; 1
    26dc:	69 e0       	ldi	r22, 0x09	; 9
    26de:	60 83       	st	Z, r22
    26e0:	31 97       	sbiw	r30, 0x01	; 1
    26e2:	60 e1       	ldi	r22, 0x10	; 16
    26e4:	60 83       	st	Z, r22
    26e6:	31 97       	sbiw	r30, 0x01	; 1
    26e8:	30 83       	st	Z, r19
    26ea:	31 97       	sbiw	r30, 0x01	; 1
    26ec:	32 e1       	ldi	r19, 0x12	; 18
    26ee:	30 83       	st	Z, r19
    26f0:	31 97       	sbiw	r30, 0x01	; 1
    26f2:	33 e1       	ldi	r19, 0x13	; 19
    26f4:	30 83       	st	Z, r19
    26f6:	31 97       	sbiw	r30, 0x01	; 1
    26f8:	34 e1       	ldi	r19, 0x14	; 20
    26fa:	30 83       	st	Z, r19
    26fc:	31 97       	sbiw	r30, 0x01	; 1
    26fe:	35 e1       	ldi	r19, 0x15	; 21
    2700:	30 83       	st	Z, r19
    2702:	31 97       	sbiw	r30, 0x01	; 1
    2704:	36 e1       	ldi	r19, 0x16	; 22
    2706:	30 83       	st	Z, r19
    2708:	31 97       	sbiw	r30, 0x01	; 1
    270a:	37 e1       	ldi	r19, 0x17	; 23
    270c:	30 83       	st	Z, r19
    270e:	31 97       	sbiw	r30, 0x01	; 1
    2710:	38 e1       	ldi	r19, 0x18	; 24
    2712:	30 83       	st	Z, r19
    2714:	31 97       	sbiw	r30, 0x01	; 1
    2716:	39 e1       	ldi	r19, 0x19	; 25
    2718:	30 83       	st	Z, r19
    271a:	31 97       	sbiw	r30, 0x01	; 1
    271c:	30 e2       	ldi	r19, 0x20	; 32
    271e:	30 83       	st	Z, r19
    2720:	31 97       	sbiw	r30, 0x01	; 1
    2722:	31 e2       	ldi	r19, 0x21	; 33
    2724:	30 83       	st	Z, r19
    2726:	31 97       	sbiw	r30, 0x01	; 1
    2728:	20 83       	st	Z, r18
    272a:	31 97       	sbiw	r30, 0x01	; 1
    272c:	23 e2       	ldi	r18, 0x23	; 35
    272e:	20 83       	st	Z, r18
    2730:	31 97       	sbiw	r30, 0x01	; 1
    2732:	40 83       	st	Z, r20
    2734:	31 97       	sbiw	r30, 0x01	; 1
    2736:	50 83       	st	Z, r21
    2738:	31 97       	sbiw	r30, 0x01	; 1
    273a:	26 e2       	ldi	r18, 0x26	; 38
    273c:	20 83       	st	Z, r18
    273e:	31 97       	sbiw	r30, 0x01	; 1
    2740:	27 e2       	ldi	r18, 0x27	; 39
    2742:	20 83       	st	Z, r18
    2744:	31 97       	sbiw	r30, 0x01	; 1
    2746:	28 e2       	ldi	r18, 0x28	; 40
    2748:	20 83       	st	Z, r18
    274a:	31 97       	sbiw	r30, 0x01	; 1
    274c:	29 e2       	ldi	r18, 0x29	; 41
    274e:	20 83       	st	Z, r18
    2750:	31 97       	sbiw	r30, 0x01	; 1
    2752:	20 e3       	ldi	r18, 0x30	; 48
    2754:	20 83       	st	Z, r18
    2756:	31 97       	sbiw	r30, 0x01	; 1
    2758:	21 e3       	ldi	r18, 0x31	; 49
    275a:	20 83       	st	Z, r18
    275c:	86 97       	sbiw	r24, 0x26	; 38
    275e:	08 95       	ret

00002760 <xPortStartScheduler>:
    2760:	89 e0       	ldi	r24, 0x09	; 9
    2762:	8b bd       	out	0x2b, r24	; 43
    2764:	83 ec       	ldi	r24, 0xC3	; 195
    2766:	8a bd       	out	0x2a, r24	; 42
    2768:	8b e0       	ldi	r24, 0x0B	; 11
    276a:	8e bd       	out	0x2e, r24	; 46
    276c:	87 b7       	in	r24, 0x37	; 55
    276e:	80 61       	ori	r24, 0x10	; 16
    2770:	87 bf       	out	0x37, r24	; 55
    2772:	a0 91 4e 0c 	lds	r26, 0x0C4E
    2776:	b0 91 4f 0c 	lds	r27, 0x0C4F
    277a:	cd 91       	ld	r28, X+
    277c:	cd bf       	out	0x3d, r28	; 61
    277e:	dd 91       	ld	r29, X+
    2780:	de bf       	out	0x3e, r29	; 62
    2782:	ff 91       	pop	r31
    2784:	ef 91       	pop	r30
    2786:	df 91       	pop	r29
    2788:	cf 91       	pop	r28
    278a:	bf 91       	pop	r27
    278c:	af 91       	pop	r26
    278e:	9f 91       	pop	r25
    2790:	8f 91       	pop	r24
    2792:	7f 91       	pop	r23
    2794:	6f 91       	pop	r22
    2796:	5f 91       	pop	r21
    2798:	4f 91       	pop	r20
    279a:	3f 91       	pop	r19
    279c:	2f 91       	pop	r18
    279e:	1f 91       	pop	r17
    27a0:	0f 91       	pop	r16
    27a2:	ff 90       	pop	r15
    27a4:	ef 90       	pop	r14
    27a6:	df 90       	pop	r13
    27a8:	cf 90       	pop	r12
    27aa:	bf 90       	pop	r11
    27ac:	af 90       	pop	r10
    27ae:	9f 90       	pop	r9
    27b0:	8f 90       	pop	r8
    27b2:	7f 90       	pop	r7
    27b4:	6f 90       	pop	r6
    27b6:	5f 90       	pop	r5
    27b8:	4f 90       	pop	r4
    27ba:	3f 90       	pop	r3
    27bc:	2f 90       	pop	r2
    27be:	1f 90       	pop	r1
    27c0:	0f 90       	pop	r0
    27c2:	0f be       	out	0x3f, r0	; 63
    27c4:	0f 90       	pop	r0
    27c6:	08 95       	ret
    27c8:	81 e0       	ldi	r24, 0x01	; 1
    27ca:	08 95       	ret

000027cc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    27cc:	0f 92       	push	r0
    27ce:	0f b6       	in	r0, 0x3f	; 63
    27d0:	f8 94       	cli
    27d2:	0f 92       	push	r0
    27d4:	1f 92       	push	r1
    27d6:	11 24       	eor	r1, r1
    27d8:	2f 92       	push	r2
    27da:	3f 92       	push	r3
    27dc:	4f 92       	push	r4
    27de:	5f 92       	push	r5
    27e0:	6f 92       	push	r6
    27e2:	7f 92       	push	r7
    27e4:	8f 92       	push	r8
    27e6:	9f 92       	push	r9
    27e8:	af 92       	push	r10
    27ea:	bf 92       	push	r11
    27ec:	cf 92       	push	r12
    27ee:	df 92       	push	r13
    27f0:	ef 92       	push	r14
    27f2:	ff 92       	push	r15
    27f4:	0f 93       	push	r16
    27f6:	1f 93       	push	r17
    27f8:	2f 93       	push	r18
    27fa:	3f 93       	push	r19
    27fc:	4f 93       	push	r20
    27fe:	5f 93       	push	r21
    2800:	6f 93       	push	r22
    2802:	7f 93       	push	r23
    2804:	8f 93       	push	r24
    2806:	9f 93       	push	r25
    2808:	af 93       	push	r26
    280a:	bf 93       	push	r27
    280c:	cf 93       	push	r28
    280e:	df 93       	push	r29
    2810:	ef 93       	push	r30
    2812:	ff 93       	push	r31
    2814:	a0 91 4e 0c 	lds	r26, 0x0C4E
    2818:	b0 91 4f 0c 	lds	r27, 0x0C4F
    281c:	0d b6       	in	r0, 0x3d	; 61
    281e:	0d 92       	st	X+, r0
    2820:	0e b6       	in	r0, 0x3e	; 62
    2822:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2824:	1b d7       	rcall	.+3638   	; 0x365c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2826:	a0 91 4e 0c 	lds	r26, 0x0C4E
    282a:	b0 91 4f 0c 	lds	r27, 0x0C4F
    282e:	cd 91       	ld	r28, X+
    2830:	cd bf       	out	0x3d, r28	; 61
    2832:	dd 91       	ld	r29, X+
    2834:	de bf       	out	0x3e, r29	; 62
    2836:	ff 91       	pop	r31
    2838:	ef 91       	pop	r30
    283a:	df 91       	pop	r29
    283c:	cf 91       	pop	r28
    283e:	bf 91       	pop	r27
    2840:	af 91       	pop	r26
    2842:	9f 91       	pop	r25
    2844:	8f 91       	pop	r24
    2846:	7f 91       	pop	r23
    2848:	6f 91       	pop	r22
    284a:	5f 91       	pop	r21
    284c:	4f 91       	pop	r20
    284e:	3f 91       	pop	r19
    2850:	2f 91       	pop	r18
    2852:	1f 91       	pop	r17
    2854:	0f 91       	pop	r16
    2856:	ff 90       	pop	r15
    2858:	ef 90       	pop	r14
    285a:	df 90       	pop	r13
    285c:	cf 90       	pop	r12
    285e:	bf 90       	pop	r11
    2860:	af 90       	pop	r10
    2862:	9f 90       	pop	r9
    2864:	8f 90       	pop	r8
    2866:	7f 90       	pop	r7
    2868:	6f 90       	pop	r6
    286a:	5f 90       	pop	r5
    286c:	4f 90       	pop	r4
    286e:	3f 90       	pop	r3
    2870:	2f 90       	pop	r2
    2872:	1f 90       	pop	r1
    2874:	0f 90       	pop	r0
    2876:	0f be       	out	0x3f, r0	; 63
    2878:	0f 90       	pop	r0

	asm volatile ( "ret" );
    287a:	08 95       	ret

0000287c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    287c:	0f 92       	push	r0
    287e:	0f b6       	in	r0, 0x3f	; 63
    2880:	f8 94       	cli
    2882:	0f 92       	push	r0
    2884:	1f 92       	push	r1
    2886:	11 24       	eor	r1, r1
    2888:	2f 92       	push	r2
    288a:	3f 92       	push	r3
    288c:	4f 92       	push	r4
    288e:	5f 92       	push	r5
    2890:	6f 92       	push	r6
    2892:	7f 92       	push	r7
    2894:	8f 92       	push	r8
    2896:	9f 92       	push	r9
    2898:	af 92       	push	r10
    289a:	bf 92       	push	r11
    289c:	cf 92       	push	r12
    289e:	df 92       	push	r13
    28a0:	ef 92       	push	r14
    28a2:	ff 92       	push	r15
    28a4:	0f 93       	push	r16
    28a6:	1f 93       	push	r17
    28a8:	2f 93       	push	r18
    28aa:	3f 93       	push	r19
    28ac:	4f 93       	push	r20
    28ae:	5f 93       	push	r21
    28b0:	6f 93       	push	r22
    28b2:	7f 93       	push	r23
    28b4:	8f 93       	push	r24
    28b6:	9f 93       	push	r25
    28b8:	af 93       	push	r26
    28ba:	bf 93       	push	r27
    28bc:	cf 93       	push	r28
    28be:	df 93       	push	r29
    28c0:	ef 93       	push	r30
    28c2:	ff 93       	push	r31
    28c4:	a0 91 4e 0c 	lds	r26, 0x0C4E
    28c8:	b0 91 4f 0c 	lds	r27, 0x0C4F
    28cc:	0d b6       	in	r0, 0x3d	; 61
    28ce:	0d 92       	st	X+, r0
    28d0:	0e b6       	in	r0, 0x3e	; 62
    28d2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    28d4:	5c d5       	rcall	.+2744   	; 0x338e <xTaskIncrementTick>
    28d6:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    28d8:	c1 d6       	rcall	.+3458   	; 0x365c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    28da:	a0 91 4e 0c 	lds	r26, 0x0C4E
    28de:	b0 91 4f 0c 	lds	r27, 0x0C4F
    28e2:	cd 91       	ld	r28, X+
    28e4:	cd bf       	out	0x3d, r28	; 61
    28e6:	dd 91       	ld	r29, X+
    28e8:	de bf       	out	0x3e, r29	; 62
    28ea:	ff 91       	pop	r31
    28ec:	ef 91       	pop	r30
    28ee:	df 91       	pop	r29
    28f0:	cf 91       	pop	r28
    28f2:	bf 91       	pop	r27
    28f4:	af 91       	pop	r26
    28f6:	9f 91       	pop	r25
    28f8:	8f 91       	pop	r24
    28fa:	7f 91       	pop	r23
    28fc:	6f 91       	pop	r22
    28fe:	5f 91       	pop	r21
    2900:	4f 91       	pop	r20
    2902:	3f 91       	pop	r19
    2904:	2f 91       	pop	r18
    2906:	1f 91       	pop	r17
    2908:	0f 91       	pop	r16
    290a:	ff 90       	pop	r15
    290c:	ef 90       	pop	r14
    290e:	df 90       	pop	r13
    2910:	cf 90       	pop	r12
    2912:	bf 90       	pop	r11
    2914:	af 90       	pop	r10
    2916:	9f 90       	pop	r9
    2918:	8f 90       	pop	r8
    291a:	7f 90       	pop	r7
    291c:	6f 90       	pop	r6
    291e:	5f 90       	pop	r5
    2920:	4f 90       	pop	r4
    2922:	3f 90       	pop	r3
    2924:	2f 90       	pop	r2
    2926:	1f 90       	pop	r1
    2928:	0f 90       	pop	r0
    292a:	0f be       	out	0x3f, r0	; 63
    292c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    292e:	08 95       	ret

00002930 <__vector_12>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2930:	a5 df       	rcall	.-182    	; 0x287c <vPortYieldFromTick>
		asm volatile ( "reti" );
    2932:	18 95       	reti

00002934 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2934:	0f b6       	in	r0, 0x3f	; 63
    2936:	f8 94       	cli
    2938:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    293a:	fc 01       	movw	r30, r24
    293c:	96 8d       	ldd	r25, Z+30	; 0x1e
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    293e:	0f 90       	pop	r0
    2940:	0f be       	out	0x3f, r0	; 63
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2942:	81 e0       	ldi	r24, 0x01	; 1
    2944:	91 11       	cpse	r25, r1
    2946:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
    2948:	08 95       	ret

0000294a <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    294a:	0f 93       	push	r16
    294c:	1f 93       	push	r17
    294e:	cf 93       	push	r28
    2950:	df 93       	push	r29
    2952:	ec 01       	movw	r28, r24
    2954:	04 2f       	mov	r16, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2956:	1e 8d       	ldd	r17, Y+30	; 0x1e

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2958:	88 a1       	ldd	r24, Y+32	; 0x20
    295a:	88 23       	and	r24, r24
    295c:	c9 f1       	breq	.+114    	; 0x29d0 <prvCopyDataToQueue+0x86>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    295e:	41 11       	cpse	r20, r1
    2960:	17 c0       	rjmp	.+46     	; 0x2990 <prvCopyDataToQueue+0x46>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2962:	48 2f       	mov	r20, r24
    2964:	50 e0       	ldi	r21, 0x00	; 0
    2966:	8a 81       	ldd	r24, Y+2	; 0x02
    2968:	9b 81       	ldd	r25, Y+3	; 0x03
    296a:	0e 94 11 43 	call	0x8622	; 0x8622 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    296e:	28 a1       	ldd	r18, Y+32	; 0x20
    2970:	8a 81       	ldd	r24, Y+2	; 0x02
    2972:	9b 81       	ldd	r25, Y+3	; 0x03
    2974:	82 0f       	add	r24, r18
    2976:	91 1d       	adc	r25, r1
    2978:	9b 83       	std	Y+3, r25	; 0x03
    297a:	8a 83       	std	Y+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    297c:	2c 81       	ldd	r18, Y+4	; 0x04
    297e:	3d 81       	ldd	r19, Y+5	; 0x05
    2980:	82 17       	cp	r24, r18
    2982:	93 07       	cpc	r25, r19
    2984:	28 f1       	brcs	.+74     	; 0x29d0 <prvCopyDataToQueue+0x86>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2986:	88 81       	ld	r24, Y
    2988:	99 81       	ldd	r25, Y+1	; 0x01
    298a:	9b 83       	std	Y+3, r25	; 0x03
    298c:	8a 83       	std	Y+2, r24	; 0x02
    298e:	20 c0       	rjmp	.+64     	; 0x29d0 <prvCopyDataToQueue+0x86>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2990:	48 2f       	mov	r20, r24
    2992:	50 e0       	ldi	r21, 0x00	; 0
    2994:	8e 81       	ldd	r24, Y+6	; 0x06
    2996:	9f 81       	ldd	r25, Y+7	; 0x07
    2998:	0e 94 11 43 	call	0x8622	; 0x8622 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    299c:	28 a1       	ldd	r18, Y+32	; 0x20
    299e:	30 e0       	ldi	r19, 0x00	; 0
    29a0:	31 95       	neg	r19
    29a2:	21 95       	neg	r18
    29a4:	31 09       	sbc	r19, r1
    29a6:	8e 81       	ldd	r24, Y+6	; 0x06
    29a8:	9f 81       	ldd	r25, Y+7	; 0x07
    29aa:	82 0f       	add	r24, r18
    29ac:	93 1f       	adc	r25, r19
    29ae:	9f 83       	std	Y+7, r25	; 0x07
    29b0:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    29b2:	68 81       	ld	r22, Y
    29b4:	79 81       	ldd	r23, Y+1	; 0x01
    29b6:	86 17       	cp	r24, r22
    29b8:	97 07       	cpc	r25, r23
    29ba:	30 f4       	brcc	.+12     	; 0x29c8 <prvCopyDataToQueue+0x7e>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    29bc:	8c 81       	ldd	r24, Y+4	; 0x04
    29be:	9d 81       	ldd	r25, Y+5	; 0x05
    29c0:	28 0f       	add	r18, r24
    29c2:	39 1f       	adc	r19, r25
    29c4:	3f 83       	std	Y+7, r19	; 0x07
    29c6:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    29c8:	02 30       	cpi	r16, 0x02	; 2
    29ca:	11 f4       	brne	.+4      	; 0x29d0 <prvCopyDataToQueue+0x86>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    29cc:	11 11       	cpse	r17, r1
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    29ce:	11 50       	subi	r17, 0x01	; 1
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    29d0:	1f 5f       	subi	r17, 0xFF	; 255
    29d2:	1e 8f       	std	Y+30, r17	; 0x1e

	return xReturn;
}
    29d4:	80 e0       	ldi	r24, 0x00	; 0
    29d6:	df 91       	pop	r29
    29d8:	cf 91       	pop	r28
    29da:	1f 91       	pop	r17
    29dc:	0f 91       	pop	r16
    29de:	08 95       	ret

000029e0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    29e0:	fc 01       	movw	r30, r24
    29e2:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    29e4:	40 a1       	ldd	r20, Z+32	; 0x20
    29e6:	44 23       	and	r20, r20
    29e8:	a1 f0       	breq	.+40     	; 0x2a12 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    29ea:	50 e0       	ldi	r21, 0x00	; 0
    29ec:	26 81       	ldd	r18, Z+6	; 0x06
    29ee:	37 81       	ldd	r19, Z+7	; 0x07
    29f0:	24 0f       	add	r18, r20
    29f2:	35 1f       	adc	r19, r21
    29f4:	37 83       	std	Z+7, r19	; 0x07
    29f6:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    29f8:	64 81       	ldd	r22, Z+4	; 0x04
    29fa:	75 81       	ldd	r23, Z+5	; 0x05
    29fc:	26 17       	cp	r18, r22
    29fe:	37 07       	cpc	r19, r23
    2a00:	20 f0       	brcs	.+8      	; 0x2a0a <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2a02:	20 81       	ld	r18, Z
    2a04:	31 81       	ldd	r19, Z+1	; 0x01
    2a06:	37 83       	std	Z+7, r19	; 0x07
    2a08:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2a0a:	66 81       	ldd	r22, Z+6	; 0x06
    2a0c:	77 81       	ldd	r23, Z+7	; 0x07
    2a0e:	0c 94 11 43 	jmp	0x8622	; 0x8622 <memcpy>
    2a12:	08 95       	ret

00002a14 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2a14:	ff 92       	push	r15
    2a16:	0f 93       	push	r16
    2a18:	1f 93       	push	r17
    2a1a:	cf 93       	push	r28
    2a1c:	df 93       	push	r29
    2a1e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2a20:	0f b6       	in	r0, 0x3f	; 63
    2a22:	f8 94       	cli
    2a24:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    2a26:	fa a0       	ldd	r15, Y+34	; 0x22

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2a28:	1f 14       	cp	r1, r15
    2a2a:	84 f4       	brge	.+32     	; 0x2a4c <prvUnlockQueue+0x38>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2a2c:	8b 89       	ldd	r24, Y+19	; 0x13
    2a2e:	88 23       	and	r24, r24
    2a30:	69 f0       	breq	.+26     	; 0x2a4c <prvUnlockQueue+0x38>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2a32:	8e 01       	movw	r16, r28
    2a34:	0d 5e       	subi	r16, 0xED	; 237
    2a36:	1f 4f       	sbci	r17, 0xFF	; 255
    2a38:	03 c0       	rjmp	.+6      	; 0x2a40 <prvUnlockQueue+0x2c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2a3a:	8b 89       	ldd	r24, Y+19	; 0x13
    2a3c:	88 23       	and	r24, r24
    2a3e:	31 f0       	breq	.+12     	; 0x2a4c <prvUnlockQueue+0x38>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2a40:	c8 01       	movw	r24, r16
    2a42:	6f d6       	rcall	.+3294   	; 0x3722 <xTaskRemoveFromEventList>
    2a44:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2a46:	18 d7       	rcall	.+3632   	; 0x3878 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2a48:	fa 94       	dec	r15
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    2a4a:	b9 f7       	brne	.-18     	; 0x2a3a <prvUnlockQueue+0x26>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2a4c:	8f ef       	ldi	r24, 0xFF	; 255
    2a4e:	8a a3       	std	Y+34, r24	; 0x22
	}
	taskEXIT_CRITICAL();
    2a50:	0f 90       	pop	r0
    2a52:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2a54:	0f b6       	in	r0, 0x3f	; 63
    2a56:	f8 94       	cli
    2a58:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2a5a:	f9 a0       	ldd	r15, Y+33	; 0x21

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2a5c:	1f 14       	cp	r1, r15
    2a5e:	84 f4       	brge	.+32     	; 0x2a80 <prvUnlockQueue+0x6c>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a60:	88 85       	ldd	r24, Y+8	; 0x08
    2a62:	88 23       	and	r24, r24
    2a64:	69 f0       	breq	.+26     	; 0x2a80 <prvUnlockQueue+0x6c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a66:	8e 01       	movw	r16, r28
    2a68:	08 5f       	subi	r16, 0xF8	; 248
    2a6a:	1f 4f       	sbci	r17, 0xFF	; 255
    2a6c:	03 c0       	rjmp	.+6      	; 0x2a74 <prvUnlockQueue+0x60>
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a6e:	88 85       	ldd	r24, Y+8	; 0x08
    2a70:	88 23       	and	r24, r24
    2a72:	31 f0       	breq	.+12     	; 0x2a80 <prvUnlockQueue+0x6c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a74:	c8 01       	movw	r24, r16
    2a76:	55 d6       	rcall	.+3242   	; 0x3722 <xTaskRemoveFromEventList>
    2a78:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    2a7a:	fe d6       	rcall	.+3580   	; 0x3878 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2a7c:	fa 94       	dec	r15
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2a7e:	b9 f7       	brne	.-18     	; 0x2a6e <prvUnlockQueue+0x5a>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2a80:	8f ef       	ldi	r24, 0xFF	; 255
    2a82:	89 a3       	std	Y+33, r24	; 0x21
	}
	taskEXIT_CRITICAL();
    2a84:	0f 90       	pop	r0
    2a86:	0f be       	out	0x3f, r0	; 63
}
    2a88:	df 91       	pop	r29
    2a8a:	cf 91       	pop	r28
    2a8c:	1f 91       	pop	r17
    2a8e:	0f 91       	pop	r16
    2a90:	ff 90       	pop	r15
    2a92:	08 95       	ret

00002a94 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    2a94:	cf 93       	push	r28
    2a96:	df 93       	push	r29
    2a98:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2a9a:	0f b6       	in	r0, 0x3f	; 63
    2a9c:	f8 94       	cli
    2a9e:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2aa0:	88 81       	ld	r24, Y
    2aa2:	99 81       	ldd	r25, Y+1	; 0x01
    2aa4:	4f 8d       	ldd	r20, Y+31	; 0x1f
    2aa6:	28 a1       	ldd	r18, Y+32	; 0x20
    2aa8:	50 e0       	ldi	r21, 0x00	; 0
    2aaa:	30 e0       	ldi	r19, 0x00	; 0
    2aac:	42 9f       	mul	r20, r18
    2aae:	f0 01       	movw	r30, r0
    2ab0:	43 9f       	mul	r20, r19
    2ab2:	f0 0d       	add	r31, r0
    2ab4:	52 9f       	mul	r21, r18
    2ab6:	f0 0d       	add	r31, r0
    2ab8:	11 24       	eor	r1, r1
    2aba:	e8 0f       	add	r30, r24
    2abc:	f9 1f       	adc	r31, r25
    2abe:	fd 83       	std	Y+5, r31	; 0x05
    2ac0:	ec 83       	std	Y+4, r30	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2ac2:	1e 8e       	std	Y+30, r1	; 0x1e
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2ac4:	9b 83       	std	Y+3, r25	; 0x03
    2ac6:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2ac8:	41 50       	subi	r20, 0x01	; 1
    2aca:	51 09       	sbc	r21, r1
    2acc:	42 9f       	mul	r20, r18
    2ace:	f0 01       	movw	r30, r0
    2ad0:	43 9f       	mul	r20, r19
    2ad2:	f0 0d       	add	r31, r0
    2ad4:	52 9f       	mul	r21, r18
    2ad6:	f0 0d       	add	r31, r0
    2ad8:	11 24       	eor	r1, r1
    2ada:	8e 0f       	add	r24, r30
    2adc:	9f 1f       	adc	r25, r31
    2ade:	9f 83       	std	Y+7, r25	; 0x07
    2ae0:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    2ae2:	8f ef       	ldi	r24, 0xFF	; 255
    2ae4:	89 a3       	std	Y+33, r24	; 0x21
		pxQueue->cTxLock = queueUNLOCKED;
    2ae6:	8a a3       	std	Y+34, r24	; 0x22

		if( xNewQueue == pdFALSE )
    2ae8:	61 11       	cpse	r22, r1
    2aea:	0a c0       	rjmp	.+20     	; 0x2b00 <xQueueGenericReset+0x6c>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2aec:	88 85       	ldd	r24, Y+8	; 0x08
    2aee:	88 23       	and	r24, r24
    2af0:	69 f0       	breq	.+26     	; 0x2b0c <xQueueGenericReset+0x78>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2af2:	ce 01       	movw	r24, r28
    2af4:	08 96       	adiw	r24, 0x08	; 8
    2af6:	15 d6       	rcall	.+3114   	; 0x3722 <xTaskRemoveFromEventList>
    2af8:	88 23       	and	r24, r24
    2afa:	41 f0       	breq	.+16     	; 0x2b0c <xQueueGenericReset+0x78>
				{
					queueYIELD_IF_USING_PREEMPTION();
    2afc:	67 de       	rcall	.-818    	; 0x27cc <vPortYield>
    2afe:	06 c0       	rjmp	.+12     	; 0x2b0c <xQueueGenericReset+0x78>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    2b00:	ce 01       	movw	r24, r28
    2b02:	08 96       	adiw	r24, 0x08	; 8
    2b04:	27 dd       	rcall	.-1458   	; 0x2554 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    2b06:	ce 01       	movw	r24, r28
    2b08:	43 96       	adiw	r24, 0x13	; 19
    2b0a:	24 dd       	rcall	.-1464   	; 0x2554 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    2b0c:	0f 90       	pop	r0
    2b0e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    2b10:	81 e0       	ldi	r24, 0x01	; 1
    2b12:	df 91       	pop	r29
    2b14:	cf 91       	pop	r28
    2b16:	08 95       	ret

00002b18 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    2b18:	0f 93       	push	r16
    2b1a:	1f 93       	push	r17
    2b1c:	cf 93       	push	r28
    2b1e:	df 93       	push	r29
    2b20:	08 2f       	mov	r16, r24
    2b22:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    2b24:	66 23       	and	r22, r22
    2b26:	b9 f0       	breq	.+46     	; 0x2b56 <xQueueGenericCreate+0x3e>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2b28:	86 9f       	mul	r24, r22
    2b2a:	c0 01       	movw	r24, r0
    2b2c:	11 24       	eor	r1, r1
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2b2e:	83 96       	adiw	r24, 0x23	; 35
    2b30:	46 dc       	rcall	.-1908   	; 0x23be <pvPortMalloc>
    2b32:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    2b34:	00 97       	sbiw	r24, 0x00	; 0
    2b36:	21 f4       	brne	.+8      	; 0x2b40 <xQueueGenericCreate+0x28>
    2b38:	14 c0       	rjmp	.+40     	; 0x2b62 <xQueueGenericCreate+0x4a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2b3a:	d9 83       	std	Y+1, r29	; 0x01
    2b3c:	c8 83       	st	Y, r28
    2b3e:	05 c0       	rjmp	.+10     	; 0x2b4a <xQueueGenericCreate+0x32>
		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2b40:	9c 01       	movw	r18, r24
    2b42:	2d 5d       	subi	r18, 0xDD	; 221
    2b44:	3f 4f       	sbci	r19, 0xFF	; 255
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2b46:	39 83       	std	Y+1, r19	; 0x01
    2b48:	28 83       	st	Y, r18
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    2b4a:	0f 8f       	std	Y+31, r16	; 0x1f
	pxNewQueue->uxItemSize = uxItemSize;
    2b4c:	18 a3       	std	Y+32, r17	; 0x20
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2b4e:	61 e0       	ldi	r22, 0x01	; 1
    2b50:	ce 01       	movw	r24, r28
    2b52:	a0 df       	rcall	.-192    	; 0x2a94 <xQueueGenericReset>
    2b54:	06 c0       	rjmp	.+12     	; 0x2b62 <xQueueGenericCreate+0x4a>
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    2b56:	83 e2       	ldi	r24, 0x23	; 35
    2b58:	90 e0       	ldi	r25, 0x00	; 0
    2b5a:	31 dc       	rcall	.-1950   	; 0x23be <pvPortMalloc>
    2b5c:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
    2b5e:	00 97       	sbiw	r24, 0x00	; 0
    2b60:	61 f7       	brne	.-40     	; 0x2b3a <xQueueGenericCreate+0x22>
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
	}
    2b62:	ce 01       	movw	r24, r28
    2b64:	df 91       	pop	r29
    2b66:	cf 91       	pop	r28
    2b68:	1f 91       	pop	r17
    2b6a:	0f 91       	pop	r16
    2b6c:	08 95       	ret

00002b6e <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    2b6e:	9f 92       	push	r9
    2b70:	af 92       	push	r10
    2b72:	bf 92       	push	r11
    2b74:	cf 92       	push	r12
    2b76:	df 92       	push	r13
    2b78:	ef 92       	push	r14
    2b7a:	ff 92       	push	r15
    2b7c:	0f 93       	push	r16
    2b7e:	1f 93       	push	r17
    2b80:	cf 93       	push	r28
    2b82:	df 93       	push	r29
    2b84:	cd b7       	in	r28, 0x3d	; 61
    2b86:	de b7       	in	r29, 0x3e	; 62
    2b88:	29 97       	sbiw	r28, 0x09	; 9
    2b8a:	0f b6       	in	r0, 0x3f	; 63
    2b8c:	f8 94       	cli
    2b8e:	de bf       	out	0x3e, r29	; 62
    2b90:	0f be       	out	0x3f, r0	; 63
    2b92:	cd bf       	out	0x3d, r28	; 61
    2b94:	7c 01       	movw	r14, r24
    2b96:	5b 01       	movw	r10, r22
    2b98:	2e 83       	std	Y+6, r18	; 0x06
    2b9a:	3f 83       	std	Y+7, r19	; 0x07
    2b9c:	48 87       	std	Y+8, r20	; 0x08
    2b9e:	59 87       	std	Y+9, r21	; 0x09
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2ba0:	10 e0       	ldi	r17, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2ba2:	99 24       	eor	r9, r9
    2ba4:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2ba6:	6c 01       	movw	r12, r24
    2ba8:	88 e0       	ldi	r24, 0x08	; 8
    2baa:	c8 0e       	add	r12, r24
    2bac:	d1 1c       	adc	r13, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2bae:	0f b6       	in	r0, 0x3f	; 63
    2bb0:	f8 94       	cli
    2bb2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2bb4:	f7 01       	movw	r30, r14
    2bb6:	96 8d       	ldd	r25, Z+30	; 0x1e
    2bb8:	87 8d       	ldd	r24, Z+31	; 0x1f
    2bba:	98 17       	cp	r25, r24
    2bbc:	10 f0       	brcs	.+4      	; 0x2bc2 <xQueueGenericSend+0x54>
    2bbe:	02 30       	cpi	r16, 0x02	; 2
    2bc0:	a9 f4       	brne	.+42     	; 0x2bec <xQueueGenericSend+0x7e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2bc2:	40 2f       	mov	r20, r16
    2bc4:	b5 01       	movw	r22, r10
    2bc6:	c7 01       	movw	r24, r14
    2bc8:	c0 de       	rcall	.-640    	; 0x294a <prvCopyDataToQueue>

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2bca:	f7 01       	movw	r30, r14
    2bcc:	93 89       	ldd	r25, Z+19	; 0x13
    2bce:	99 23       	and	r25, r25
    2bd0:	39 f0       	breq	.+14     	; 0x2be0 <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2bd2:	c7 01       	movw	r24, r14
    2bd4:	43 96       	adiw	r24, 0x13	; 19
    2bd6:	a5 d5       	rcall	.+2890   	; 0x3722 <xTaskRemoveFromEventList>
    2bd8:	88 23       	and	r24, r24
    2bda:	21 f0       	breq	.+8      	; 0x2be4 <xQueueGenericSend+0x76>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    2bdc:	f7 dd       	rcall	.-1042   	; 0x27cc <vPortYield>
    2bde:	02 c0       	rjmp	.+4      	; 0x2be4 <xQueueGenericSend+0x76>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    2be0:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    2be2:	f4 dd       	rcall	.-1048   	; 0x27cc <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    2be4:	0f 90       	pop	r0
    2be6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2be8:	81 e0       	ldi	r24, 0x01	; 1
    2bea:	4c c0       	rjmp	.+152    	; 0x2c84 <xQueueGenericSend+0x116>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2bec:	8e 81       	ldd	r24, Y+6	; 0x06
    2bee:	9f 81       	ldd	r25, Y+7	; 0x07
    2bf0:	a8 85       	ldd	r26, Y+8	; 0x08
    2bf2:	b9 85       	ldd	r27, Y+9	; 0x09
    2bf4:	89 2b       	or	r24, r25
    2bf6:	8a 2b       	or	r24, r26
    2bf8:	8b 2b       	or	r24, r27
    2bfa:	21 f4       	brne	.+8      	; 0x2c04 <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2bfc:	0f 90       	pop	r0
    2bfe:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2c00:	80 e0       	ldi	r24, 0x00	; 0
    2c02:	40 c0       	rjmp	.+128    	; 0x2c84 <xQueueGenericSend+0x116>
				}
				else if( xEntryTimeSet == pdFALSE )
    2c04:	11 11       	cpse	r17, r1
    2c06:	04 c0       	rjmp	.+8      	; 0x2c10 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2c08:	ce 01       	movw	r24, r28
    2c0a:	01 96       	adiw	r24, 0x01	; 1
    2c0c:	cc d5       	rcall	.+2968   	; 0x37a6 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2c0e:	19 2d       	mov	r17, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2c10:	0f 90       	pop	r0
    2c12:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2c14:	b6 d3       	rcall	.+1900   	; 0x3382 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2c16:	0f b6       	in	r0, 0x3f	; 63
    2c18:	f8 94       	cli
    2c1a:	0f 92       	push	r0
    2c1c:	f7 01       	movw	r30, r14
    2c1e:	81 a1       	ldd	r24, Z+33	; 0x21
    2c20:	8f 3f       	cpi	r24, 0xFF	; 255
    2c22:	09 f4       	brne	.+2      	; 0x2c26 <xQueueGenericSend+0xb8>
    2c24:	11 a2       	std	Z+33, r1	; 0x21
    2c26:	f7 01       	movw	r30, r14
    2c28:	82 a1       	ldd	r24, Z+34	; 0x22
    2c2a:	8f 3f       	cpi	r24, 0xFF	; 255
    2c2c:	09 f4       	brne	.+2      	; 0x2c30 <xQueueGenericSend+0xc2>
    2c2e:	12 a2       	std	Z+34, r1	; 0x22
    2c30:	0f 90       	pop	r0
    2c32:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2c34:	be 01       	movw	r22, r28
    2c36:	6a 5f       	subi	r22, 0xFA	; 250
    2c38:	7f 4f       	sbci	r23, 0xFF	; 255
    2c3a:	ce 01       	movw	r24, r28
    2c3c:	01 96       	adiw	r24, 0x01	; 1
    2c3e:	c4 d5       	rcall	.+2952   	; 0x37c8 <xTaskCheckForTimeOut>
    2c40:	81 11       	cpse	r24, r1
    2c42:	1c c0       	rjmp	.+56     	; 0x2c7c <xQueueGenericSend+0x10e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2c44:	0f b6       	in	r0, 0x3f	; 63
    2c46:	f8 94       	cli
    2c48:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2c4a:	f7 01       	movw	r30, r14
    2c4c:	96 8d       	ldd	r25, Z+30	; 0x1e
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2c4e:	0f 90       	pop	r0
    2c50:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2c52:	f7 01       	movw	r30, r14
    2c54:	87 8d       	ldd	r24, Z+31	; 0x1f
    2c56:	98 13       	cpse	r25, r24
    2c58:	0d c0       	rjmp	.+26     	; 0x2c74 <xQueueGenericSend+0x106>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2c5a:	4e 81       	ldd	r20, Y+6	; 0x06
    2c5c:	5f 81       	ldd	r21, Y+7	; 0x07
    2c5e:	68 85       	ldd	r22, Y+8	; 0x08
    2c60:	79 85       	ldd	r23, Y+9	; 0x09
    2c62:	c6 01       	movw	r24, r12
    2c64:	47 d5       	rcall	.+2702   	; 0x36f4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2c66:	c7 01       	movw	r24, r14
    2c68:	d5 de       	rcall	.-598    	; 0x2a14 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2c6a:	65 d4       	rcall	.+2250   	; 0x3536 <xTaskResumeAll>
    2c6c:	81 11       	cpse	r24, r1
    2c6e:	9f cf       	rjmp	.-194    	; 0x2bae <xQueueGenericSend+0x40>
				{
					portYIELD_WITHIN_API();
    2c70:	ad dd       	rcall	.-1190   	; 0x27cc <vPortYield>
    2c72:	9d cf       	rjmp	.-198    	; 0x2bae <xQueueGenericSend+0x40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2c74:	c7 01       	movw	r24, r14
    2c76:	ce de       	rcall	.-612    	; 0x2a14 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2c78:	5e d4       	rcall	.+2236   	; 0x3536 <xTaskResumeAll>
    2c7a:	99 cf       	rjmp	.-206    	; 0x2bae <xQueueGenericSend+0x40>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2c7c:	c7 01       	movw	r24, r14
    2c7e:	ca de       	rcall	.-620    	; 0x2a14 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2c80:	5a d4       	rcall	.+2228   	; 0x3536 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2c82:	80 e0       	ldi	r24, 0x00	; 0
		}
	} /*lint -restore */
}
    2c84:	29 96       	adiw	r28, 0x09	; 9
    2c86:	0f b6       	in	r0, 0x3f	; 63
    2c88:	f8 94       	cli
    2c8a:	de bf       	out	0x3e, r29	; 62
    2c8c:	0f be       	out	0x3f, r0	; 63
    2c8e:	cd bf       	out	0x3d, r28	; 61
    2c90:	df 91       	pop	r29
    2c92:	cf 91       	pop	r28
    2c94:	1f 91       	pop	r17
    2c96:	0f 91       	pop	r16
    2c98:	ff 90       	pop	r15
    2c9a:	ef 90       	pop	r14
    2c9c:	df 90       	pop	r13
    2c9e:	cf 90       	pop	r12
    2ca0:	bf 90       	pop	r11
    2ca2:	af 90       	pop	r10
    2ca4:	9f 90       	pop	r9
    2ca6:	08 95       	ret

00002ca8 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2ca8:	ff 92       	push	r15
    2caa:	0f 93       	push	r16
    2cac:	1f 93       	push	r17
    2cae:	cf 93       	push	r28
    2cb0:	df 93       	push	r29
    2cb2:	ec 01       	movw	r28, r24
    2cb4:	8a 01       	movw	r16, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2cb6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2cb8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2cba:	98 17       	cp	r25, r24
    2cbc:	10 f0       	brcs	.+4      	; 0x2cc2 <xQueueGenericSendFromISR+0x1a>
    2cbe:	22 30       	cpi	r18, 0x02	; 2
    2cc0:	d1 f4       	brne	.+52     	; 0x2cf6 <xQueueGenericSendFromISR+0x4e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2cc2:	fa a0       	ldd	r15, Y+34	; 0x22
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2cc4:	42 2f       	mov	r20, r18
    2cc6:	ce 01       	movw	r24, r28
    2cc8:	40 de       	rcall	.-896    	; 0x294a <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2cca:	8f ef       	ldi	r24, 0xFF	; 255
    2ccc:	f8 12       	cpse	r15, r24
    2cce:	0f c0       	rjmp	.+30     	; 0x2cee <xQueueGenericSendFromISR+0x46>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2cd0:	8b 89       	ldd	r24, Y+19	; 0x13
    2cd2:	88 23       	and	r24, r24
    2cd4:	91 f0       	breq	.+36     	; 0x2cfa <xQueueGenericSendFromISR+0x52>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2cd6:	ce 01       	movw	r24, r28
    2cd8:	43 96       	adiw	r24, 0x13	; 19
    2cda:	23 d5       	rcall	.+2630   	; 0x3722 <xTaskRemoveFromEventList>
    2cdc:	88 23       	and	r24, r24
    2cde:	79 f0       	breq	.+30     	; 0x2cfe <xQueueGenericSendFromISR+0x56>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2ce0:	01 15       	cp	r16, r1
    2ce2:	11 05       	cpc	r17, r1
    2ce4:	71 f0       	breq	.+28     	; 0x2d02 <xQueueGenericSendFromISR+0x5a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2ce6:	81 e0       	ldi	r24, 0x01	; 1
    2ce8:	f8 01       	movw	r30, r16
    2cea:	80 83       	st	Z, r24
    2cec:	0b c0       	rjmp	.+22     	; 0x2d04 <xQueueGenericSendFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2cee:	f3 94       	inc	r15
    2cf0:	fa a2       	std	Y+34, r15	; 0x22
			}

			xReturn = pdPASS;
    2cf2:	81 e0       	ldi	r24, 0x01	; 1
    2cf4:	07 c0       	rjmp	.+14     	; 0x2d04 <xQueueGenericSendFromISR+0x5c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2cf6:	80 e0       	ldi	r24, 0x00	; 0
    2cf8:	05 c0       	rjmp	.+10     	; 0x2d04 <xQueueGenericSendFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    2cfa:	81 e0       	ldi	r24, 0x01	; 1
    2cfc:	03 c0       	rjmp	.+6      	; 0x2d04 <xQueueGenericSendFromISR+0x5c>
    2cfe:	81 e0       	ldi	r24, 0x01	; 1
    2d00:	01 c0       	rjmp	.+2      	; 0x2d04 <xQueueGenericSendFromISR+0x5c>
    2d02:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2d04:	df 91       	pop	r29
    2d06:	cf 91       	pop	r28
    2d08:	1f 91       	pop	r17
    2d0a:	0f 91       	pop	r16
    2d0c:	ff 90       	pop	r15
    2d0e:	08 95       	ret

00002d10 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2d10:	cf 93       	push	r28
    2d12:	df 93       	push	r29
    2d14:	fc 01       	movw	r30, r24
    2d16:	eb 01       	movw	r28, r22
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2d18:	86 8d       	ldd	r24, Z+30	; 0x1e

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    2d1a:	97 8d       	ldd	r25, Z+31	; 0x1f
    2d1c:	89 17       	cp	r24, r25
    2d1e:	b0 f4       	brcc	.+44     	; 0x2d4c <xQueueGiveFromISR+0x3c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    2d20:	92 a1       	ldd	r25, Z+34	; 0x22
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2d22:	8f 5f       	subi	r24, 0xFF	; 255
    2d24:	86 8f       	std	Z+30, r24	; 0x1e

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    2d26:	9f 3f       	cpi	r25, 0xFF	; 255
    2d28:	69 f4       	brne	.+26     	; 0x2d44 <xQueueGiveFromISR+0x34>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2d2a:	83 89       	ldd	r24, Z+19	; 0x13
    2d2c:	88 23       	and	r24, r24
    2d2e:	81 f0       	breq	.+32     	; 0x2d50 <xQueueGiveFromISR+0x40>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2d30:	cf 01       	movw	r24, r30
    2d32:	43 96       	adiw	r24, 0x13	; 19
    2d34:	f6 d4       	rcall	.+2540   	; 0x3722 <xTaskRemoveFromEventList>
    2d36:	88 23       	and	r24, r24
    2d38:	69 f0       	breq	.+26     	; 0x2d54 <xQueueGiveFromISR+0x44>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2d3a:	20 97       	sbiw	r28, 0x00	; 0
    2d3c:	69 f0       	breq	.+26     	; 0x2d58 <xQueueGiveFromISR+0x48>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2d3e:	81 e0       	ldi	r24, 0x01	; 1
    2d40:	88 83       	st	Y, r24
    2d42:	0b c0       	rjmp	.+22     	; 0x2d5a <xQueueGiveFromISR+0x4a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2d44:	9f 5f       	subi	r25, 0xFF	; 255
    2d46:	92 a3       	std	Z+34, r25	; 0x22
			}

			xReturn = pdPASS;
    2d48:	81 e0       	ldi	r24, 0x01	; 1
    2d4a:	07 c0       	rjmp	.+14     	; 0x2d5a <xQueueGiveFromISR+0x4a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2d4c:	80 e0       	ldi	r24, 0x00	; 0
    2d4e:	05 c0       	rjmp	.+10     	; 0x2d5a <xQueueGiveFromISR+0x4a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
    2d50:	81 e0       	ldi	r24, 0x01	; 1
    2d52:	03 c0       	rjmp	.+6      	; 0x2d5a <xQueueGiveFromISR+0x4a>
    2d54:	81 e0       	ldi	r24, 0x01	; 1
    2d56:	01 c0       	rjmp	.+2      	; 0x2d5a <xQueueGiveFromISR+0x4a>
    2d58:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2d5a:	df 91       	pop	r29
    2d5c:	cf 91       	pop	r28
    2d5e:	08 95       	ret

00002d60 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    2d60:	9f 92       	push	r9
    2d62:	af 92       	push	r10
    2d64:	bf 92       	push	r11
    2d66:	cf 92       	push	r12
    2d68:	df 92       	push	r13
    2d6a:	ef 92       	push	r14
    2d6c:	ff 92       	push	r15
    2d6e:	0f 93       	push	r16
    2d70:	1f 93       	push	r17
    2d72:	cf 93       	push	r28
    2d74:	df 93       	push	r29
    2d76:	cd b7       	in	r28, 0x3d	; 61
    2d78:	de b7       	in	r29, 0x3e	; 62
    2d7a:	29 97       	sbiw	r28, 0x09	; 9
    2d7c:	0f b6       	in	r0, 0x3f	; 63
    2d7e:	f8 94       	cli
    2d80:	de bf       	out	0x3e, r29	; 62
    2d82:	0f be       	out	0x3f, r0	; 63
    2d84:	cd bf       	out	0x3d, r28	; 61
    2d86:	8c 01       	movw	r16, r24
    2d88:	6b 01       	movw	r12, r22
    2d8a:	2e 83       	std	Y+6, r18	; 0x06
    2d8c:	3f 83       	std	Y+7, r19	; 0x07
    2d8e:	48 87       	std	Y+8, r20	; 0x08
    2d90:	59 87       	std	Y+9, r21	; 0x09
BaseType_t xEntryTimeSet = pdFALSE;
    2d92:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2d94:	aa 24       	eor	r10, r10
    2d96:	a3 94       	inc	r10
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2d98:	7c 01       	movw	r14, r24
    2d9a:	83 e1       	ldi	r24, 0x13	; 19
    2d9c:	e8 0e       	add	r14, r24
    2d9e:	f1 1c       	adc	r15, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2da0:	0f b6       	in	r0, 0x3f	; 63
    2da2:	f8 94       	cli
    2da4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2da6:	f8 01       	movw	r30, r16
    2da8:	96 8c       	ldd	r9, Z+30	; 0x1e

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2daa:	99 20       	and	r9, r9
    2dac:	91 f0       	breq	.+36     	; 0x2dd2 <xQueueReceive+0x72>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2dae:	b6 01       	movw	r22, r12
    2db0:	c8 01       	movw	r24, r16
    2db2:	16 de       	rcall	.-980    	; 0x29e0 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2db4:	9a 94       	dec	r9
    2db6:	f8 01       	movw	r30, r16
    2db8:	96 8e       	std	Z+30, r9	; 0x1e

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2dba:	80 85       	ldd	r24, Z+8	; 0x08
    2dbc:	88 23       	and	r24, r24
    2dbe:	29 f0       	breq	.+10     	; 0x2dca <xQueueReceive+0x6a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2dc0:	c8 01       	movw	r24, r16
    2dc2:	08 96       	adiw	r24, 0x08	; 8
    2dc4:	ae d4       	rcall	.+2396   	; 0x3722 <xTaskRemoveFromEventList>
    2dc6:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    2dc8:	01 dd       	rcall	.-1534   	; 0x27cc <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2dca:	0f 90       	pop	r0
    2dcc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2dce:	81 e0       	ldi	r24, 0x01	; 1
    2dd0:	4a c0       	rjmp	.+148    	; 0x2e66 <xQueueReceive+0x106>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2dd2:	4e 81       	ldd	r20, Y+6	; 0x06
    2dd4:	5f 81       	ldd	r21, Y+7	; 0x07
    2dd6:	68 85       	ldd	r22, Y+8	; 0x08
    2dd8:	79 85       	ldd	r23, Y+9	; 0x09
    2dda:	45 2b       	or	r20, r21
    2ddc:	46 2b       	or	r20, r22
    2dde:	47 2b       	or	r20, r23
    2de0:	21 f4       	brne	.+8      	; 0x2dea <xQueueReceive+0x8a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2de2:	0f 90       	pop	r0
    2de4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2de6:	80 e0       	ldi	r24, 0x00	; 0
    2de8:	3e c0       	rjmp	.+124    	; 0x2e66 <xQueueReceive+0x106>
				}
				else if( xEntryTimeSet == pdFALSE )
    2dea:	b1 10       	cpse	r11, r1
    2dec:	04 c0       	rjmp	.+8      	; 0x2df6 <xQueueReceive+0x96>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2dee:	ce 01       	movw	r24, r28
    2df0:	01 96       	adiw	r24, 0x01	; 1
    2df2:	d9 d4       	rcall	.+2482   	; 0x37a6 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2df4:	ba 2c       	mov	r11, r10
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2df6:	0f 90       	pop	r0
    2df8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2dfa:	c3 d2       	rcall	.+1414   	; 0x3382 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2dfc:	0f b6       	in	r0, 0x3f	; 63
    2dfe:	f8 94       	cli
    2e00:	0f 92       	push	r0
    2e02:	f8 01       	movw	r30, r16
    2e04:	81 a1       	ldd	r24, Z+33	; 0x21
    2e06:	8f 3f       	cpi	r24, 0xFF	; 255
    2e08:	09 f4       	brne	.+2      	; 0x2e0c <xQueueReceive+0xac>
    2e0a:	11 a2       	std	Z+33, r1	; 0x21
    2e0c:	f8 01       	movw	r30, r16
    2e0e:	82 a1       	ldd	r24, Z+34	; 0x22
    2e10:	8f 3f       	cpi	r24, 0xFF	; 255
    2e12:	09 f4       	brne	.+2      	; 0x2e16 <xQueueReceive+0xb6>
    2e14:	12 a2       	std	Z+34, r1	; 0x22
    2e16:	0f 90       	pop	r0
    2e18:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2e1a:	be 01       	movw	r22, r28
    2e1c:	6a 5f       	subi	r22, 0xFA	; 250
    2e1e:	7f 4f       	sbci	r23, 0xFF	; 255
    2e20:	ce 01       	movw	r24, r28
    2e22:	01 96       	adiw	r24, 0x01	; 1
    2e24:	d1 d4       	rcall	.+2466   	; 0x37c8 <xTaskCheckForTimeOut>
    2e26:	81 11       	cpse	r24, r1
    2e28:	15 c0       	rjmp	.+42     	; 0x2e54 <xQueueReceive+0xf4>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2e2a:	c8 01       	movw	r24, r16
    2e2c:	83 dd       	rcall	.-1274   	; 0x2934 <prvIsQueueEmpty>
    2e2e:	88 23       	and	r24, r24
    2e30:	69 f0       	breq	.+26     	; 0x2e4c <xQueueReceive+0xec>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2e32:	4e 81       	ldd	r20, Y+6	; 0x06
    2e34:	5f 81       	ldd	r21, Y+7	; 0x07
    2e36:	68 85       	ldd	r22, Y+8	; 0x08
    2e38:	79 85       	ldd	r23, Y+9	; 0x09
    2e3a:	c7 01       	movw	r24, r14
    2e3c:	5b d4       	rcall	.+2230   	; 0x36f4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2e3e:	c8 01       	movw	r24, r16
    2e40:	e9 dd       	rcall	.-1070   	; 0x2a14 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2e42:	79 d3       	rcall	.+1778   	; 0x3536 <xTaskResumeAll>
    2e44:	81 11       	cpse	r24, r1
    2e46:	ac cf       	rjmp	.-168    	; 0x2da0 <xQueueReceive+0x40>
				{
					portYIELD_WITHIN_API();
    2e48:	c1 dc       	rcall	.-1662   	; 0x27cc <vPortYield>
    2e4a:	aa cf       	rjmp	.-172    	; 0x2da0 <xQueueReceive+0x40>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    2e4c:	c8 01       	movw	r24, r16
    2e4e:	e2 dd       	rcall	.-1084   	; 0x2a14 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2e50:	72 d3       	rcall	.+1764   	; 0x3536 <xTaskResumeAll>
    2e52:	a6 cf       	rjmp	.-180    	; 0x2da0 <xQueueReceive+0x40>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    2e54:	c8 01       	movw	r24, r16
    2e56:	de dd       	rcall	.-1092   	; 0x2a14 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2e58:	6e d3       	rcall	.+1756   	; 0x3536 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2e5a:	c8 01       	movw	r24, r16
    2e5c:	6b dd       	rcall	.-1322   	; 0x2934 <prvIsQueueEmpty>
    2e5e:	88 23       	and	r24, r24
    2e60:	09 f4       	brne	.+2      	; 0x2e64 <xQueueReceive+0x104>
    2e62:	9e cf       	rjmp	.-196    	; 0x2da0 <xQueueReceive+0x40>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2e64:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    2e66:	29 96       	adiw	r28, 0x09	; 9
    2e68:	0f b6       	in	r0, 0x3f	; 63
    2e6a:	f8 94       	cli
    2e6c:	de bf       	out	0x3e, r29	; 62
    2e6e:	0f be       	out	0x3f, r0	; 63
    2e70:	cd bf       	out	0x3d, r28	; 61
    2e72:	df 91       	pop	r29
    2e74:	cf 91       	pop	r28
    2e76:	1f 91       	pop	r17
    2e78:	0f 91       	pop	r16
    2e7a:	ff 90       	pop	r15
    2e7c:	ef 90       	pop	r14
    2e7e:	df 90       	pop	r13
    2e80:	cf 90       	pop	r12
    2e82:	bf 90       	pop	r11
    2e84:	af 90       	pop	r10
    2e86:	9f 90       	pop	r9
    2e88:	08 95       	ret

00002e8a <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2e8a:	cf 92       	push	r12
    2e8c:	df 92       	push	r13
    2e8e:	ef 92       	push	r14
    2e90:	ff 92       	push	r15
    2e92:	0f 93       	push	r16
    2e94:	1f 93       	push	r17
    2e96:	cf 93       	push	r28
    2e98:	df 93       	push	r29
    2e9a:	cd b7       	in	r28, 0x3d	; 61
    2e9c:	de b7       	in	r29, 0x3e	; 62
    2e9e:	29 97       	sbiw	r28, 0x09	; 9
    2ea0:	0f b6       	in	r0, 0x3f	; 63
    2ea2:	f8 94       	cli
    2ea4:	de bf       	out	0x3e, r29	; 62
    2ea6:	0f be       	out	0x3f, r0	; 63
    2ea8:	cd bf       	out	0x3d, r28	; 61
    2eaa:	8c 01       	movw	r16, r24
    2eac:	4e 83       	std	Y+6, r20	; 0x06
    2eae:	5f 83       	std	Y+7, r21	; 0x07
    2eb0:	68 87       	std	Y+8, r22	; 0x08
    2eb2:	79 87       	std	Y+9, r23	; 0x09
BaseType_t xEntryTimeSet = pdFALSE;
    2eb4:	d1 2c       	mov	r13, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2eb6:	cc 24       	eor	r12, r12
    2eb8:	c3 94       	inc	r12
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2eba:	7c 01       	movw	r14, r24
    2ebc:	83 e1       	ldi	r24, 0x13	; 19
    2ebe:	e8 0e       	add	r14, r24
    2ec0:	f1 1c       	adc	r15, r1
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2ec2:	0f b6       	in	r0, 0x3f	; 63
    2ec4:	f8 94       	cli
    2ec6:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2ec8:	f8 01       	movw	r30, r16
    2eca:	86 8d       	ldd	r24, Z+30	; 0x1e

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2ecc:	88 23       	and	r24, r24
    2ece:	71 f0       	breq	.+28     	; 0x2eec <xQueueSemaphoreTake+0x62>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2ed0:	81 50       	subi	r24, 0x01	; 1
    2ed2:	86 8f       	std	Z+30, r24	; 0x1e
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2ed4:	80 85       	ldd	r24, Z+8	; 0x08
    2ed6:	88 23       	and	r24, r24
    2ed8:	29 f0       	breq	.+10     	; 0x2ee4 <xQueueSemaphoreTake+0x5a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2eda:	c8 01       	movw	r24, r16
    2edc:	08 96       	adiw	r24, 0x08	; 8
    2ede:	21 d4       	rcall	.+2114   	; 0x3722 <xTaskRemoveFromEventList>
    2ee0:	81 11       	cpse	r24, r1
					{
						queueYIELD_IF_USING_PREEMPTION();
    2ee2:	74 dc       	rcall	.-1816   	; 0x27cc <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2ee4:	0f 90       	pop	r0
    2ee6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2ee8:	81 e0       	ldi	r24, 0x01	; 1
    2eea:	4a c0       	rjmp	.+148    	; 0x2f80 <xQueueSemaphoreTake+0xf6>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2eec:	4e 81       	ldd	r20, Y+6	; 0x06
    2eee:	5f 81       	ldd	r21, Y+7	; 0x07
    2ef0:	68 85       	ldd	r22, Y+8	; 0x08
    2ef2:	79 85       	ldd	r23, Y+9	; 0x09
    2ef4:	45 2b       	or	r20, r21
    2ef6:	46 2b       	or	r20, r22
    2ef8:	47 2b       	or	r20, r23
    2efa:	21 f4       	brne	.+8      	; 0x2f04 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    2efc:	0f 90       	pop	r0
    2efe:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2f00:	80 e0       	ldi	r24, 0x00	; 0
    2f02:	3e c0       	rjmp	.+124    	; 0x2f80 <xQueueSemaphoreTake+0xf6>
				}
				else if( xEntryTimeSet == pdFALSE )
    2f04:	d1 10       	cpse	r13, r1
    2f06:	04 c0       	rjmp	.+8      	; 0x2f10 <xQueueSemaphoreTake+0x86>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2f08:	ce 01       	movw	r24, r28
    2f0a:	01 96       	adiw	r24, 0x01	; 1
    2f0c:	4c d4       	rcall	.+2200   	; 0x37a6 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2f0e:	dc 2c       	mov	r13, r12
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2f10:	0f 90       	pop	r0
    2f12:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    2f14:	36 d2       	rcall	.+1132   	; 0x3382 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2f16:	0f b6       	in	r0, 0x3f	; 63
    2f18:	f8 94       	cli
    2f1a:	0f 92       	push	r0
    2f1c:	f8 01       	movw	r30, r16
    2f1e:	81 a1       	ldd	r24, Z+33	; 0x21
    2f20:	8f 3f       	cpi	r24, 0xFF	; 255
    2f22:	09 f4       	brne	.+2      	; 0x2f26 <xQueueSemaphoreTake+0x9c>
    2f24:	11 a2       	std	Z+33, r1	; 0x21
    2f26:	f8 01       	movw	r30, r16
    2f28:	82 a1       	ldd	r24, Z+34	; 0x22
    2f2a:	8f 3f       	cpi	r24, 0xFF	; 255
    2f2c:	09 f4       	brne	.+2      	; 0x2f30 <xQueueSemaphoreTake+0xa6>
    2f2e:	12 a2       	std	Z+34, r1	; 0x22
    2f30:	0f 90       	pop	r0
    2f32:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2f34:	be 01       	movw	r22, r28
    2f36:	6a 5f       	subi	r22, 0xFA	; 250
    2f38:	7f 4f       	sbci	r23, 0xFF	; 255
    2f3a:	ce 01       	movw	r24, r28
    2f3c:	01 96       	adiw	r24, 0x01	; 1
    2f3e:	44 d4       	rcall	.+2184   	; 0x37c8 <xTaskCheckForTimeOut>
    2f40:	81 11       	cpse	r24, r1
    2f42:	15 c0       	rjmp	.+42     	; 0x2f6e <xQueueSemaphoreTake+0xe4>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2f44:	c8 01       	movw	r24, r16
    2f46:	f6 dc       	rcall	.-1556   	; 0x2934 <prvIsQueueEmpty>
    2f48:	88 23       	and	r24, r24
    2f4a:	69 f0       	breq	.+26     	; 0x2f66 <xQueueSemaphoreTake+0xdc>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2f4c:	4e 81       	ldd	r20, Y+6	; 0x06
    2f4e:	5f 81       	ldd	r21, Y+7	; 0x07
    2f50:	68 85       	ldd	r22, Y+8	; 0x08
    2f52:	79 85       	ldd	r23, Y+9	; 0x09
    2f54:	c7 01       	movw	r24, r14
    2f56:	ce d3       	rcall	.+1948   	; 0x36f4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2f58:	c8 01       	movw	r24, r16
    2f5a:	5c dd       	rcall	.-1352   	; 0x2a14 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2f5c:	ec d2       	rcall	.+1496   	; 0x3536 <xTaskResumeAll>
    2f5e:	81 11       	cpse	r24, r1
    2f60:	b0 cf       	rjmp	.-160    	; 0x2ec2 <xQueueSemaphoreTake+0x38>
				{
					portYIELD_WITHIN_API();
    2f62:	34 dc       	rcall	.-1944   	; 0x27cc <vPortYield>
    2f64:	ae cf       	rjmp	.-164    	; 0x2ec2 <xQueueSemaphoreTake+0x38>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    2f66:	c8 01       	movw	r24, r16
    2f68:	55 dd       	rcall	.-1366   	; 0x2a14 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2f6a:	e5 d2       	rcall	.+1482   	; 0x3536 <xTaskResumeAll>
    2f6c:	aa cf       	rjmp	.-172    	; 0x2ec2 <xQueueSemaphoreTake+0x38>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2f6e:	c8 01       	movw	r24, r16
    2f70:	51 dd       	rcall	.-1374   	; 0x2a14 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2f72:	e1 d2       	rcall	.+1474   	; 0x3536 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2f74:	c8 01       	movw	r24, r16
    2f76:	de dc       	rcall	.-1604   	; 0x2934 <prvIsQueueEmpty>
    2f78:	88 23       	and	r24, r24
    2f7a:	09 f4       	brne	.+2      	; 0x2f7e <xQueueSemaphoreTake+0xf4>
    2f7c:	a2 cf       	rjmp	.-188    	; 0x2ec2 <xQueueSemaphoreTake+0x38>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2f7e:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
    2f80:	29 96       	adiw	r28, 0x09	; 9
    2f82:	0f b6       	in	r0, 0x3f	; 63
    2f84:	f8 94       	cli
    2f86:	de bf       	out	0x3e, r29	; 62
    2f88:	0f be       	out	0x3f, r0	; 63
    2f8a:	cd bf       	out	0x3d, r28	; 61
    2f8c:	df 91       	pop	r29
    2f8e:	cf 91       	pop	r28
    2f90:	1f 91       	pop	r17
    2f92:	0f 91       	pop	r16
    2f94:	ff 90       	pop	r15
    2f96:	ef 90       	pop	r14
    2f98:	df 90       	pop	r13
    2f9a:	cf 90       	pop	r12
    2f9c:	08 95       	ret

00002f9e <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    2f9e:	e0 91 0a 0c 	lds	r30, 0x0C0A
    2fa2:	f0 91 0b 0c 	lds	r31, 0x0C0B
    2fa6:	80 81       	ld	r24, Z
    2fa8:	81 11       	cpse	r24, r1
    2faa:	0c c0       	rjmp	.+24     	; 0x2fc4 <prvResetNextTaskUnblockTime+0x26>
    2fac:	8f ef       	ldi	r24, 0xFF	; 255
    2fae:	9f ef       	ldi	r25, 0xFF	; 255
    2fb0:	dc 01       	movw	r26, r24
    2fb2:	80 93 d7 0b 	sts	0x0BD7, r24
    2fb6:	90 93 d8 0b 	sts	0x0BD8, r25
    2fba:	a0 93 d9 0b 	sts	0x0BD9, r26
    2fbe:	b0 93 da 0b 	sts	0x0BDA, r27
    2fc2:	08 95       	ret
    2fc4:	e0 91 0a 0c 	lds	r30, 0x0C0A
    2fc8:	f0 91 0b 0c 	lds	r31, 0x0C0B
    2fcc:	07 80       	ldd	r0, Z+7	; 0x07
    2fce:	f0 85       	ldd	r31, Z+8	; 0x08
    2fd0:	e0 2d       	mov	r30, r0
    2fd2:	00 84       	ldd	r0, Z+8	; 0x08
    2fd4:	f1 85       	ldd	r31, Z+9	; 0x09
    2fd6:	e0 2d       	mov	r30, r0
    2fd8:	82 81       	ldd	r24, Z+2	; 0x02
    2fda:	93 81       	ldd	r25, Z+3	; 0x03
    2fdc:	a4 81       	ldd	r26, Z+4	; 0x04
    2fde:	b5 81       	ldd	r27, Z+5	; 0x05
    2fe0:	80 93 d7 0b 	sts	0x0BD7, r24
    2fe4:	90 93 d8 0b 	sts	0x0BD8, r25
    2fe8:	a0 93 d9 0b 	sts	0x0BD9, r26
    2fec:	b0 93 da 0b 	sts	0x0BDA, r27
    2ff0:	08 95       	ret

00002ff2 <prvIdleTask>:
    2ff2:	02 e2       	ldi	r16, 0x22	; 34
    2ff4:	1c e0       	ldi	r17, 0x0C	; 12
    2ff6:	1d c0       	rjmp	.+58     	; 0x3032 <prvIdleTask+0x40>
    2ff8:	0f b6       	in	r0, 0x3f	; 63
    2ffa:	f8 94       	cli
    2ffc:	0f 92       	push	r0
    2ffe:	e0 91 f9 0b 	lds	r30, 0x0BF9
    3002:	f0 91 fa 0b 	lds	r31, 0x0BFA
    3006:	c0 85       	ldd	r28, Z+8	; 0x08
    3008:	d1 85       	ldd	r29, Z+9	; 0x09
    300a:	ce 01       	movw	r24, r28
    300c:	02 96       	adiw	r24, 0x02	; 2
    300e:	15 db       	rcall	.-2518   	; 0x263a <uxListRemove>
    3010:	80 91 e5 0b 	lds	r24, 0x0BE5
    3014:	81 50       	subi	r24, 0x01	; 1
    3016:	80 93 e5 0b 	sts	0x0BE5, r24
    301a:	80 91 f1 0b 	lds	r24, 0x0BF1
    301e:	81 50       	subi	r24, 0x01	; 1
    3020:	80 93 f1 0b 	sts	0x0BF1, r24
    3024:	0f 90       	pop	r0
    3026:	0f be       	out	0x3f, r0	; 63
    3028:	8b 8d       	ldd	r24, Y+27	; 0x1b
    302a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    302c:	62 da       	rcall	.-2876   	; 0x24f2 <vPortFree>
    302e:	ce 01       	movw	r24, r28
    3030:	60 da       	rcall	.-2880   	; 0x24f2 <vPortFree>
    3032:	80 91 f1 0b 	lds	r24, 0x0BF1
    3036:	81 11       	cpse	r24, r1
    3038:	df cf       	rjmp	.-66     	; 0x2ff8 <prvIdleTask+0x6>
    303a:	f8 01       	movw	r30, r16
    303c:	80 81       	ld	r24, Z
    303e:	82 30       	cpi	r24, 0x02	; 2
    3040:	c0 f3       	brcs	.-16     	; 0x3032 <prvIdleTask+0x40>
    3042:	c4 db       	rcall	.-2168   	; 0x27cc <vPortYield>
    3044:	f6 cf       	rjmp	.-20     	; 0x3032 <prvIdleTask+0x40>

00003046 <prvAddCurrentTaskToDelayedList>:
    3046:	8f 92       	push	r8
    3048:	9f 92       	push	r9
    304a:	af 92       	push	r10
    304c:	bf 92       	push	r11
    304e:	cf 92       	push	r12
    3050:	df 92       	push	r13
    3052:	ef 92       	push	r14
    3054:	ff 92       	push	r15
    3056:	cf 93       	push	r28
    3058:	6b 01       	movw	r12, r22
    305a:	7c 01       	movw	r14, r24
    305c:	c4 2f       	mov	r28, r20
    305e:	80 90 e1 0b 	lds	r8, 0x0BE1
    3062:	90 90 e2 0b 	lds	r9, 0x0BE2
    3066:	a0 90 e3 0b 	lds	r10, 0x0BE3
    306a:	b0 90 e4 0b 	lds	r11, 0x0BE4
    306e:	80 91 4e 0c 	lds	r24, 0x0C4E
    3072:	90 91 4f 0c 	lds	r25, 0x0C4F
    3076:	02 96       	adiw	r24, 0x02	; 2
    3078:	e0 da       	rcall	.-2624   	; 0x263a <uxListRemove>
    307a:	8f ef       	ldi	r24, 0xFF	; 255
    307c:	c8 16       	cp	r12, r24
    307e:	d8 06       	cpc	r13, r24
    3080:	e8 06       	cpc	r14, r24
    3082:	f8 06       	cpc	r15, r24
    3084:	61 f4       	brne	.+24     	; 0x309e <prvAddCurrentTaskToDelayedList+0x58>
    3086:	cc 23       	and	r28, r28
    3088:	51 f0       	breq	.+20     	; 0x309e <prvAddCurrentTaskToDelayedList+0x58>
    308a:	60 91 4e 0c 	lds	r22, 0x0C4E
    308e:	70 91 4f 0c 	lds	r23, 0x0C4F
    3092:	6e 5f       	subi	r22, 0xFE	; 254
    3094:	7f 4f       	sbci	r23, 0xFF	; 255
    3096:	86 ee       	ldi	r24, 0xE6	; 230
    3098:	9b e0       	ldi	r25, 0x0B	; 11
    309a:	71 da       	rcall	.-2846   	; 0x257e <vListInsertEnd>
    309c:	3d c0       	rjmp	.+122    	; 0x3118 <prvAddCurrentTaskToDelayedList+0xd2>
    309e:	c8 0c       	add	r12, r8
    30a0:	d9 1c       	adc	r13, r9
    30a2:	ea 1c       	adc	r14, r10
    30a4:	fb 1c       	adc	r15, r11
    30a6:	e0 91 4e 0c 	lds	r30, 0x0C4E
    30aa:	f0 91 4f 0c 	lds	r31, 0x0C4F
    30ae:	c2 82       	std	Z+2, r12	; 0x02
    30b0:	d3 82       	std	Z+3, r13	; 0x03
    30b2:	e4 82       	std	Z+4, r14	; 0x04
    30b4:	f5 82       	std	Z+5, r15	; 0x05
    30b6:	c8 14       	cp	r12, r8
    30b8:	d9 04       	cpc	r13, r9
    30ba:	ea 04       	cpc	r14, r10
    30bc:	fb 04       	cpc	r15, r11
    30be:	60 f4       	brcc	.+24     	; 0x30d8 <prvAddCurrentTaskToDelayedList+0x92>
    30c0:	60 91 4e 0c 	lds	r22, 0x0C4E
    30c4:	70 91 4f 0c 	lds	r23, 0x0C4F
    30c8:	80 91 08 0c 	lds	r24, 0x0C08
    30cc:	90 91 09 0c 	lds	r25, 0x0C09
    30d0:	6e 5f       	subi	r22, 0xFE	; 254
    30d2:	7f 4f       	sbci	r23, 0xFF	; 255
    30d4:	75 da       	rcall	.-2838   	; 0x25c0 <vListInsert>
    30d6:	20 c0       	rjmp	.+64     	; 0x3118 <prvAddCurrentTaskToDelayedList+0xd2>
    30d8:	60 91 4e 0c 	lds	r22, 0x0C4E
    30dc:	70 91 4f 0c 	lds	r23, 0x0C4F
    30e0:	80 91 0a 0c 	lds	r24, 0x0C0A
    30e4:	90 91 0b 0c 	lds	r25, 0x0C0B
    30e8:	6e 5f       	subi	r22, 0xFE	; 254
    30ea:	7f 4f       	sbci	r23, 0xFF	; 255
    30ec:	69 da       	rcall	.-2862   	; 0x25c0 <vListInsert>
    30ee:	80 91 d7 0b 	lds	r24, 0x0BD7
    30f2:	90 91 d8 0b 	lds	r25, 0x0BD8
    30f6:	a0 91 d9 0b 	lds	r26, 0x0BD9
    30fa:	b0 91 da 0b 	lds	r27, 0x0BDA
    30fe:	c8 16       	cp	r12, r24
    3100:	d9 06       	cpc	r13, r25
    3102:	ea 06       	cpc	r14, r26
    3104:	fb 06       	cpc	r15, r27
    3106:	40 f4       	brcc	.+16     	; 0x3118 <prvAddCurrentTaskToDelayedList+0xd2>
    3108:	c0 92 d7 0b 	sts	0x0BD7, r12
    310c:	d0 92 d8 0b 	sts	0x0BD8, r13
    3110:	e0 92 d9 0b 	sts	0x0BD9, r14
    3114:	f0 92 da 0b 	sts	0x0BDA, r15
    3118:	cf 91       	pop	r28
    311a:	ff 90       	pop	r15
    311c:	ef 90       	pop	r14
    311e:	df 90       	pop	r13
    3120:	cf 90       	pop	r12
    3122:	bf 90       	pop	r11
    3124:	af 90       	pop	r10
    3126:	9f 90       	pop	r9
    3128:	8f 90       	pop	r8
    312a:	08 95       	ret

0000312c <xTaskCreate>:
    312c:	4f 92       	push	r4
    312e:	5f 92       	push	r5
    3130:	6f 92       	push	r6
    3132:	7f 92       	push	r7
    3134:	8f 92       	push	r8
    3136:	9f 92       	push	r9
    3138:	af 92       	push	r10
    313a:	bf 92       	push	r11
    313c:	cf 92       	push	r12
    313e:	df 92       	push	r13
    3140:	ef 92       	push	r14
    3142:	ff 92       	push	r15
    3144:	0f 93       	push	r16
    3146:	cf 93       	push	r28
    3148:	df 93       	push	r29
    314a:	4c 01       	movw	r8, r24
    314c:	6b 01       	movw	r12, r22
    314e:	5a 01       	movw	r10, r20
    3150:	29 01       	movw	r4, r18
    3152:	ca 01       	movw	r24, r20
    3154:	34 d9       	rcall	.-3480   	; 0x23be <pvPortMalloc>
    3156:	3c 01       	movw	r6, r24
    3158:	00 97       	sbiw	r24, 0x00	; 0
    315a:	09 f4       	brne	.+2      	; 0x315e <xTaskCreate+0x32>
    315c:	d0 c0       	rjmp	.+416    	; 0x32fe <xTaskCreate+0x1d2>
    315e:	8a e2       	ldi	r24, 0x2A	; 42
    3160:	90 e0       	ldi	r25, 0x00	; 0
    3162:	2d d9       	rcall	.-3494   	; 0x23be <pvPortMalloc>
    3164:	ec 01       	movw	r28, r24
    3166:	00 97       	sbiw	r24, 0x00	; 0
    3168:	71 f0       	breq	.+28     	; 0x3186 <xTaskCreate+0x5a>
    316a:	7c 8e       	std	Y+28, r7	; 0x1c
    316c:	6b 8e       	std	Y+27, r6	; 0x1b
    316e:	21 e0       	ldi	r18, 0x01	; 1
    3170:	a2 1a       	sub	r10, r18
    3172:	b1 08       	sbc	r11, r1
    3174:	6a 0c       	add	r6, r10
    3176:	7b 1c       	adc	r7, r11
    3178:	d6 01       	movw	r26, r12
    317a:	8c 91       	ld	r24, X
    317c:	8d 8f       	std	Y+29, r24	; 0x1d
    317e:	8c 91       	ld	r24, X
    3180:	81 11       	cpse	r24, r1
    3182:	04 c0       	rjmp	.+8      	; 0x318c <xTaskCreate+0x60>
    3184:	15 c0       	rjmp	.+42     	; 0x31b0 <xTaskCreate+0x84>
    3186:	c3 01       	movw	r24, r6
    3188:	b4 d9       	rcall	.-3224   	; 0x24f2 <vPortFree>
    318a:	b9 c0       	rjmp	.+370    	; 0x32fe <xTaskCreate+0x1d2>
    318c:	ae 01       	movw	r20, r28
    318e:	42 5e       	subi	r20, 0xE2	; 226
    3190:	5f 4f       	sbci	r21, 0xFF	; 255
    3192:	f6 01       	movw	r30, r12
    3194:	31 96       	adiw	r30, 0x01	; 1
    3196:	21 e0       	ldi	r18, 0x01	; 1
    3198:	cf 01       	movw	r24, r30
    319a:	31 91       	ld	r19, Z+
    319c:	da 01       	movw	r26, r20
    319e:	3d 93       	st	X+, r19
    31a0:	ad 01       	movw	r20, r26
    31a2:	dc 01       	movw	r26, r24
    31a4:	8c 91       	ld	r24, X
    31a6:	88 23       	and	r24, r24
    31a8:	19 f0       	breq	.+6      	; 0x31b0 <xTaskCreate+0x84>
    31aa:	2f 5f       	subi	r18, 0xFF	; 255
    31ac:	28 30       	cpi	r18, 0x08	; 8
    31ae:	a1 f7       	brne	.-24     	; 0x3198 <xTaskCreate+0x6c>
    31b0:	1c a2       	std	Y+36, r1	; 0x24
    31b2:	04 30       	cpi	r16, 0x04	; 4
    31b4:	08 f0       	brcs	.+2      	; 0x31b8 <xTaskCreate+0x8c>
    31b6:	03 e0       	ldi	r16, 0x03	; 3
    31b8:	0a 8f       	std	Y+26, r16	; 0x1a
    31ba:	6e 01       	movw	r12, r28
    31bc:	b2 e0       	ldi	r27, 0x02	; 2
    31be:	cb 0e       	add	r12, r27
    31c0:	d1 1c       	adc	r13, r1
    31c2:	c6 01       	movw	r24, r12
    31c4:	d8 d9       	rcall	.-3152   	; 0x2576 <vListInitialiseItem>
    31c6:	ce 01       	movw	r24, r28
    31c8:	0e 96       	adiw	r24, 0x0e	; 14
    31ca:	d5 d9       	rcall	.-3158   	; 0x2576 <vListInitialiseItem>
    31cc:	db 87       	std	Y+11, r29	; 0x0b
    31ce:	ca 87       	std	Y+10, r28	; 0x0a
    31d0:	84 e0       	ldi	r24, 0x04	; 4
    31d2:	90 e0       	ldi	r25, 0x00	; 0
    31d4:	a0 e0       	ldi	r26, 0x00	; 0
    31d6:	b0 e0       	ldi	r27, 0x00	; 0
    31d8:	80 1b       	sub	r24, r16
    31da:	91 09       	sbc	r25, r1
    31dc:	a1 09       	sbc	r26, r1
    31de:	b1 09       	sbc	r27, r1
    31e0:	8e 87       	std	Y+14, r24	; 0x0e
    31e2:	9f 87       	std	Y+15, r25	; 0x0f
    31e4:	a8 8b       	std	Y+16, r26	; 0x10
    31e6:	b9 8b       	std	Y+17, r27	; 0x11
    31e8:	df 8b       	std	Y+23, r29	; 0x17
    31ea:	ce 8b       	std	Y+22, r28	; 0x16
    31ec:	1d a2       	std	Y+37, r1	; 0x25
    31ee:	1e a2       	std	Y+38, r1	; 0x26
    31f0:	1f a2       	std	Y+39, r1	; 0x27
    31f2:	18 a6       	std	Y+40, r1	; 0x28
    31f4:	19 a6       	std	Y+41, r1	; 0x29
    31f6:	a2 01       	movw	r20, r4
    31f8:	b4 01       	movw	r22, r8
    31fa:	c3 01       	movw	r24, r6
    31fc:	45 da       	rcall	.-2934   	; 0x2688 <pxPortInitialiseStack>
    31fe:	99 83       	std	Y+1, r25	; 0x01
    3200:	88 83       	st	Y, r24
    3202:	e1 14       	cp	r14, r1
    3204:	f1 04       	cpc	r15, r1
    3206:	19 f0       	breq	.+6      	; 0x320e <xTaskCreate+0xe2>
    3208:	f7 01       	movw	r30, r14
    320a:	d1 83       	std	Z+1, r29	; 0x01
    320c:	c0 83       	st	Z, r28
    320e:	0f b6       	in	r0, 0x3f	; 63
    3210:	f8 94       	cli
    3212:	0f 92       	push	r0
    3214:	80 91 e5 0b 	lds	r24, 0x0BE5
    3218:	8f 5f       	subi	r24, 0xFF	; 255
    321a:	80 93 e5 0b 	sts	0x0BE5, r24
    321e:	80 91 4e 0c 	lds	r24, 0x0C4E
    3222:	90 91 4f 0c 	lds	r25, 0x0C4F
    3226:	89 2b       	or	r24, r25
    3228:	89 f5       	brne	.+98     	; 0x328c <xTaskCreate+0x160>
    322a:	d0 93 4f 0c 	sts	0x0C4F, r29
    322e:	c0 93 4e 0c 	sts	0x0C4E, r28
    3232:	80 91 e5 0b 	lds	r24, 0x0BE5
    3236:	81 30       	cpi	r24, 0x01	; 1
    3238:	09 f0       	breq	.+2      	; 0x323c <xTaskCreate+0x110>
    323a:	38 c0       	rjmp	.+112    	; 0x32ac <xTaskCreate+0x180>
    323c:	82 e2       	ldi	r24, 0x22	; 34
    323e:	9c e0       	ldi	r25, 0x0C	; 12
    3240:	89 d9       	rcall	.-3310   	; 0x2554 <vListInitialise>
    3242:	8d e2       	ldi	r24, 0x2D	; 45
    3244:	9c e0       	ldi	r25, 0x0C	; 12
    3246:	86 d9       	rcall	.-3316   	; 0x2554 <vListInitialise>
    3248:	88 e3       	ldi	r24, 0x38	; 56
    324a:	9c e0       	ldi	r25, 0x0C	; 12
    324c:	83 d9       	rcall	.-3322   	; 0x2554 <vListInitialise>
    324e:	83 e4       	ldi	r24, 0x43	; 67
    3250:	9c e0       	ldi	r25, 0x0C	; 12
    3252:	80 d9       	rcall	.-3328   	; 0x2554 <vListInitialise>
    3254:	87 e1       	ldi	r24, 0x17	; 23
    3256:	9c e0       	ldi	r25, 0x0C	; 12
    3258:	7d d9       	rcall	.-3334   	; 0x2554 <vListInitialise>
    325a:	8c e0       	ldi	r24, 0x0C	; 12
    325c:	9c e0       	ldi	r25, 0x0C	; 12
    325e:	7a d9       	rcall	.-3340   	; 0x2554 <vListInitialise>
    3260:	8d ef       	ldi	r24, 0xFD	; 253
    3262:	9b e0       	ldi	r25, 0x0B	; 11
    3264:	77 d9       	rcall	.-3346   	; 0x2554 <vListInitialise>
    3266:	82 ef       	ldi	r24, 0xF2	; 242
    3268:	9b e0       	ldi	r25, 0x0B	; 11
    326a:	74 d9       	rcall	.-3352   	; 0x2554 <vListInitialise>
    326c:	86 ee       	ldi	r24, 0xE6	; 230
    326e:	9b e0       	ldi	r25, 0x0B	; 11
    3270:	71 d9       	rcall	.-3358   	; 0x2554 <vListInitialise>
    3272:	87 e1       	ldi	r24, 0x17	; 23
    3274:	9c e0       	ldi	r25, 0x0C	; 12
    3276:	90 93 0b 0c 	sts	0x0C0B, r25
    327a:	80 93 0a 0c 	sts	0x0C0A, r24
    327e:	8c e0       	ldi	r24, 0x0C	; 12
    3280:	9c e0       	ldi	r25, 0x0C	; 12
    3282:	90 93 09 0c 	sts	0x0C09, r25
    3286:	80 93 08 0c 	sts	0x0C08, r24
    328a:	10 c0       	rjmp	.+32     	; 0x32ac <xTaskCreate+0x180>
    328c:	80 91 df 0b 	lds	r24, 0x0BDF
    3290:	81 11       	cpse	r24, r1
    3292:	0c c0       	rjmp	.+24     	; 0x32ac <xTaskCreate+0x180>
    3294:	e0 91 4e 0c 	lds	r30, 0x0C4E
    3298:	f0 91 4f 0c 	lds	r31, 0x0C4F
    329c:	92 8d       	ldd	r25, Z+26	; 0x1a
    329e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    32a0:	89 17       	cp	r24, r25
    32a2:	20 f0       	brcs	.+8      	; 0x32ac <xTaskCreate+0x180>
    32a4:	d0 93 4f 0c 	sts	0x0C4F, r29
    32a8:	c0 93 4e 0c 	sts	0x0C4E, r28
    32ac:	80 91 db 0b 	lds	r24, 0x0BDB
    32b0:	8f 5f       	subi	r24, 0xFF	; 255
    32b2:	80 93 db 0b 	sts	0x0BDB, r24
    32b6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    32b8:	90 91 e0 0b 	lds	r25, 0x0BE0
    32bc:	98 17       	cp	r25, r24
    32be:	10 f4       	brcc	.+4      	; 0x32c4 <xTaskCreate+0x198>
    32c0:	80 93 e0 0b 	sts	0x0BE0, r24
    32c4:	fb e0       	ldi	r31, 0x0B	; 11
    32c6:	8f 9f       	mul	r24, r31
    32c8:	c0 01       	movw	r24, r0
    32ca:	11 24       	eor	r1, r1
    32cc:	b6 01       	movw	r22, r12
    32ce:	8e 5d       	subi	r24, 0xDE	; 222
    32d0:	93 4f       	sbci	r25, 0xF3	; 243
    32d2:	55 d9       	rcall	.-3414   	; 0x257e <vListInsertEnd>
    32d4:	0f 90       	pop	r0
    32d6:	0f be       	out	0x3f, r0	; 63
    32d8:	80 91 df 0b 	lds	r24, 0x0BDF
    32dc:	88 23       	and	r24, r24
    32de:	59 f0       	breq	.+22     	; 0x32f6 <xTaskCreate+0x1ca>
    32e0:	e0 91 4e 0c 	lds	r30, 0x0C4E
    32e4:	f0 91 4f 0c 	lds	r31, 0x0C4F
    32e8:	92 8d       	ldd	r25, Z+26	; 0x1a
    32ea:	8a 8d       	ldd	r24, Y+26	; 0x1a
    32ec:	98 17       	cp	r25, r24
    32ee:	28 f4       	brcc	.+10     	; 0x32fa <xTaskCreate+0x1ce>
    32f0:	6d da       	rcall	.-2854   	; 0x27cc <vPortYield>
    32f2:	81 e0       	ldi	r24, 0x01	; 1
    32f4:	05 c0       	rjmp	.+10     	; 0x3300 <xTaskCreate+0x1d4>
    32f6:	81 e0       	ldi	r24, 0x01	; 1
    32f8:	03 c0       	rjmp	.+6      	; 0x3300 <xTaskCreate+0x1d4>
    32fa:	81 e0       	ldi	r24, 0x01	; 1
    32fc:	01 c0       	rjmp	.+2      	; 0x3300 <xTaskCreate+0x1d4>
    32fe:	8f ef       	ldi	r24, 0xFF	; 255
    3300:	df 91       	pop	r29
    3302:	cf 91       	pop	r28
    3304:	0f 91       	pop	r16
    3306:	ff 90       	pop	r15
    3308:	ef 90       	pop	r14
    330a:	df 90       	pop	r13
    330c:	cf 90       	pop	r12
    330e:	bf 90       	pop	r11
    3310:	af 90       	pop	r10
    3312:	9f 90       	pop	r9
    3314:	8f 90       	pop	r8
    3316:	7f 90       	pop	r7
    3318:	6f 90       	pop	r6
    331a:	5f 90       	pop	r5
    331c:	4f 90       	pop	r4
    331e:	08 95       	ret

00003320 <vTaskStartScheduler>:
    3320:	ef 92       	push	r14
    3322:	ff 92       	push	r15
    3324:	0f 93       	push	r16
    3326:	0f 2e       	mov	r0, r31
    3328:	f5 ed       	ldi	r31, 0xD5	; 213
    332a:	ef 2e       	mov	r14, r31
    332c:	fb e0       	ldi	r31, 0x0B	; 11
    332e:	ff 2e       	mov	r15, r31
    3330:	f0 2d       	mov	r31, r0
    3332:	00 e0       	ldi	r16, 0x00	; 0
    3334:	20 e0       	ldi	r18, 0x00	; 0
    3336:	30 e0       	ldi	r19, 0x00	; 0
    3338:	45 e5       	ldi	r20, 0x55	; 85
    333a:	50 e0       	ldi	r21, 0x00	; 0
    333c:	6a e7       	ldi	r22, 0x7A	; 122
    333e:	72 e0       	ldi	r23, 0x02	; 2
    3340:	89 ef       	ldi	r24, 0xF9	; 249
    3342:	97 e1       	ldi	r25, 0x17	; 23
    3344:	f3 de       	rcall	.-538    	; 0x312c <xTaskCreate>
    3346:	81 30       	cpi	r24, 0x01	; 1
    3348:	c1 f4       	brne	.+48     	; 0x337a <vTaskStartScheduler+0x5a>
    334a:	f8 94       	cli
    334c:	8f ef       	ldi	r24, 0xFF	; 255
    334e:	9f ef       	ldi	r25, 0xFF	; 255
    3350:	dc 01       	movw	r26, r24
    3352:	80 93 d7 0b 	sts	0x0BD7, r24
    3356:	90 93 d8 0b 	sts	0x0BD8, r25
    335a:	a0 93 d9 0b 	sts	0x0BD9, r26
    335e:	b0 93 da 0b 	sts	0x0BDA, r27
    3362:	81 e0       	ldi	r24, 0x01	; 1
    3364:	80 93 df 0b 	sts	0x0BDF, r24
    3368:	10 92 e1 0b 	sts	0x0BE1, r1
    336c:	10 92 e2 0b 	sts	0x0BE2, r1
    3370:	10 92 e3 0b 	sts	0x0BE3, r1
    3374:	10 92 e4 0b 	sts	0x0BE4, r1
    3378:	f3 d9       	rcall	.-3098   	; 0x2760 <xPortStartScheduler>
    337a:	0f 91       	pop	r16
    337c:	ff 90       	pop	r15
    337e:	ef 90       	pop	r14
    3380:	08 95       	ret

00003382 <vTaskSuspendAll>:
    3382:	80 91 d4 0b 	lds	r24, 0x0BD4
    3386:	8f 5f       	subi	r24, 0xFF	; 255
    3388:	80 93 d4 0b 	sts	0x0BD4, r24
    338c:	08 95       	ret

0000338e <xTaskIncrementTick>:
    338e:	9f 92       	push	r9
    3390:	af 92       	push	r10
    3392:	bf 92       	push	r11
    3394:	cf 92       	push	r12
    3396:	df 92       	push	r13
    3398:	ef 92       	push	r14
    339a:	ff 92       	push	r15
    339c:	0f 93       	push	r16
    339e:	1f 93       	push	r17
    33a0:	cf 93       	push	r28
    33a2:	df 93       	push	r29
    33a4:	80 91 d4 0b 	lds	r24, 0x0BD4
    33a8:	81 11       	cpse	r24, r1
    33aa:	a9 c0       	rjmp	.+338    	; 0x34fe <xTaskIncrementTick+0x170>
    33ac:	c0 90 e1 0b 	lds	r12, 0x0BE1
    33b0:	d0 90 e2 0b 	lds	r13, 0x0BE2
    33b4:	e0 90 e3 0b 	lds	r14, 0x0BE3
    33b8:	f0 90 e4 0b 	lds	r15, 0x0BE4
    33bc:	8f ef       	ldi	r24, 0xFF	; 255
    33be:	c8 1a       	sub	r12, r24
    33c0:	d8 0a       	sbc	r13, r24
    33c2:	e8 0a       	sbc	r14, r24
    33c4:	f8 0a       	sbc	r15, r24
    33c6:	c0 92 e1 0b 	sts	0x0BE1, r12
    33ca:	d0 92 e2 0b 	sts	0x0BE2, r13
    33ce:	e0 92 e3 0b 	sts	0x0BE3, r14
    33d2:	f0 92 e4 0b 	sts	0x0BE4, r15
    33d6:	c1 14       	cp	r12, r1
    33d8:	d1 04       	cpc	r13, r1
    33da:	e1 04       	cpc	r14, r1
    33dc:	f1 04       	cpc	r15, r1
    33de:	b1 f4       	brne	.+44     	; 0x340c <xTaskIncrementTick+0x7e>
    33e0:	80 91 0a 0c 	lds	r24, 0x0C0A
    33e4:	90 91 0b 0c 	lds	r25, 0x0C0B
    33e8:	20 91 08 0c 	lds	r18, 0x0C08
    33ec:	30 91 09 0c 	lds	r19, 0x0C09
    33f0:	30 93 0b 0c 	sts	0x0C0B, r19
    33f4:	20 93 0a 0c 	sts	0x0C0A, r18
    33f8:	90 93 09 0c 	sts	0x0C09, r25
    33fc:	80 93 08 0c 	sts	0x0C08, r24
    3400:	80 91 dc 0b 	lds	r24, 0x0BDC
    3404:	8f 5f       	subi	r24, 0xFF	; 255
    3406:	80 93 dc 0b 	sts	0x0BDC, r24
    340a:	c9 dd       	rcall	.-1134   	; 0x2f9e <prvResetNextTaskUnblockTime>
    340c:	80 91 d7 0b 	lds	r24, 0x0BD7
    3410:	90 91 d8 0b 	lds	r25, 0x0BD8
    3414:	a0 91 d9 0b 	lds	r26, 0x0BD9
    3418:	b0 91 da 0b 	lds	r27, 0x0BDA
    341c:	c8 16       	cp	r12, r24
    341e:	d9 06       	cpc	r13, r25
    3420:	ea 06       	cpc	r14, r26
    3422:	fb 06       	cpc	r15, r27
    3424:	08 f4       	brcc	.+2      	; 0x3428 <xTaskIncrementTick+0x9a>
    3426:	5b c0       	rjmp	.+182    	; 0x34de <xTaskIncrementTick+0x150>
    3428:	b1 2c       	mov	r11, r1
    342a:	0f 2e       	mov	r0, r31
    342c:	fb e0       	ldi	r31, 0x0B	; 11
    342e:	af 2e       	mov	r10, r31
    3430:	f0 2d       	mov	r31, r0
    3432:	99 24       	eor	r9, r9
    3434:	93 94       	inc	r9
    3436:	01 c0       	rjmp	.+2      	; 0x343a <xTaskIncrementTick+0xac>
    3438:	b9 2c       	mov	r11, r9
    343a:	e0 91 0a 0c 	lds	r30, 0x0C0A
    343e:	f0 91 0b 0c 	lds	r31, 0x0C0B
    3442:	80 81       	ld	r24, Z
    3444:	81 11       	cpse	r24, r1
    3446:	0c c0       	rjmp	.+24     	; 0x3460 <xTaskIncrementTick+0xd2>
    3448:	4f ef       	ldi	r20, 0xFF	; 255
    344a:	5f ef       	ldi	r21, 0xFF	; 255
    344c:	ba 01       	movw	r22, r20
    344e:	40 93 d7 0b 	sts	0x0BD7, r20
    3452:	50 93 d8 0b 	sts	0x0BD8, r21
    3456:	60 93 d9 0b 	sts	0x0BD9, r22
    345a:	70 93 da 0b 	sts	0x0BDA, r23
    345e:	40 c0       	rjmp	.+128    	; 0x34e0 <xTaskIncrementTick+0x152>
    3460:	e0 91 0a 0c 	lds	r30, 0x0C0A
    3464:	f0 91 0b 0c 	lds	r31, 0x0C0B
    3468:	07 80       	ldd	r0, Z+7	; 0x07
    346a:	f0 85       	ldd	r31, Z+8	; 0x08
    346c:	e0 2d       	mov	r30, r0
    346e:	c0 85       	ldd	r28, Z+8	; 0x08
    3470:	d1 85       	ldd	r29, Z+9	; 0x09
    3472:	4a 81       	ldd	r20, Y+2	; 0x02
    3474:	5b 81       	ldd	r21, Y+3	; 0x03
    3476:	6c 81       	ldd	r22, Y+4	; 0x04
    3478:	7d 81       	ldd	r23, Y+5	; 0x05
    347a:	c4 16       	cp	r12, r20
    347c:	d5 06       	cpc	r13, r21
    347e:	e6 06       	cpc	r14, r22
    3480:	f7 06       	cpc	r15, r23
    3482:	48 f4       	brcc	.+18     	; 0x3496 <xTaskIncrementTick+0x108>
    3484:	40 93 d7 0b 	sts	0x0BD7, r20
    3488:	50 93 d8 0b 	sts	0x0BD8, r21
    348c:	60 93 d9 0b 	sts	0x0BD9, r22
    3490:	70 93 da 0b 	sts	0x0BDA, r23
    3494:	25 c0       	rjmp	.+74     	; 0x34e0 <xTaskIncrementTick+0x152>
    3496:	8e 01       	movw	r16, r28
    3498:	0e 5f       	subi	r16, 0xFE	; 254
    349a:	1f 4f       	sbci	r17, 0xFF	; 255
    349c:	c8 01       	movw	r24, r16
    349e:	cd d8       	rcall	.-3686   	; 0x263a <uxListRemove>
    34a0:	88 8d       	ldd	r24, Y+24	; 0x18
    34a2:	99 8d       	ldd	r25, Y+25	; 0x19
    34a4:	89 2b       	or	r24, r25
    34a6:	19 f0       	breq	.+6      	; 0x34ae <xTaskIncrementTick+0x120>
    34a8:	ce 01       	movw	r24, r28
    34aa:	0e 96       	adiw	r24, 0x0e	; 14
    34ac:	c6 d8       	rcall	.-3700   	; 0x263a <uxListRemove>
    34ae:	8a 8d       	ldd	r24, Y+26	; 0x1a
    34b0:	90 91 e0 0b 	lds	r25, 0x0BE0
    34b4:	98 17       	cp	r25, r24
    34b6:	10 f4       	brcc	.+4      	; 0x34bc <xTaskIncrementTick+0x12e>
    34b8:	80 93 e0 0b 	sts	0x0BE0, r24
    34bc:	a8 9e       	mul	r10, r24
    34be:	c0 01       	movw	r24, r0
    34c0:	11 24       	eor	r1, r1
    34c2:	b8 01       	movw	r22, r16
    34c4:	8e 5d       	subi	r24, 0xDE	; 222
    34c6:	93 4f       	sbci	r25, 0xF3	; 243
    34c8:	5a d8       	rcall	.-3916   	; 0x257e <vListInsertEnd>
    34ca:	e0 91 4e 0c 	lds	r30, 0x0C4E
    34ce:	f0 91 4f 0c 	lds	r31, 0x0C4F
    34d2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    34d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    34d6:	98 17       	cp	r25, r24
    34d8:	08 f0       	brcs	.+2      	; 0x34dc <xTaskIncrementTick+0x14e>
    34da:	ae cf       	rjmp	.-164    	; 0x3438 <xTaskIncrementTick+0xaa>
    34dc:	ae cf       	rjmp	.-164    	; 0x343a <xTaskIncrementTick+0xac>
    34de:	b1 2c       	mov	r11, r1
    34e0:	e0 91 4e 0c 	lds	r30, 0x0C4E
    34e4:	f0 91 4f 0c 	lds	r31, 0x0C4F
    34e8:	e2 8d       	ldd	r30, Z+26	; 0x1a
    34ea:	8b e0       	ldi	r24, 0x0B	; 11
    34ec:	e8 9f       	mul	r30, r24
    34ee:	f0 01       	movw	r30, r0
    34f0:	11 24       	eor	r1, r1
    34f2:	ee 5d       	subi	r30, 0xDE	; 222
    34f4:	f3 4f       	sbci	r31, 0xF3	; 243
    34f6:	80 81       	ld	r24, Z
    34f8:	82 30       	cpi	r24, 0x02	; 2
    34fa:	40 f4       	brcc	.+16     	; 0x350c <xTaskIncrementTick+0x17e>
    34fc:	09 c0       	rjmp	.+18     	; 0x3510 <xTaskIncrementTick+0x182>
    34fe:	80 91 de 0b 	lds	r24, 0x0BDE
    3502:	8f 5f       	subi	r24, 0xFF	; 255
    3504:	80 93 de 0b 	sts	0x0BDE, r24
    3508:	b1 2c       	mov	r11, r1
    350a:	02 c0       	rjmp	.+4      	; 0x3510 <xTaskIncrementTick+0x182>
    350c:	bb 24       	eor	r11, r11
    350e:	b3 94       	inc	r11
    3510:	80 91 dd 0b 	lds	r24, 0x0BDD
    3514:	88 23       	and	r24, r24
    3516:	11 f0       	breq	.+4      	; 0x351c <xTaskIncrementTick+0x18e>
    3518:	bb 24       	eor	r11, r11
    351a:	b3 94       	inc	r11
    351c:	8b 2d       	mov	r24, r11
    351e:	df 91       	pop	r29
    3520:	cf 91       	pop	r28
    3522:	1f 91       	pop	r17
    3524:	0f 91       	pop	r16
    3526:	ff 90       	pop	r15
    3528:	ef 90       	pop	r14
    352a:	df 90       	pop	r13
    352c:	cf 90       	pop	r12
    352e:	bf 90       	pop	r11
    3530:	af 90       	pop	r10
    3532:	9f 90       	pop	r9
    3534:	08 95       	ret

00003536 <xTaskResumeAll>:
    3536:	cf 92       	push	r12
    3538:	df 92       	push	r13
    353a:	ef 92       	push	r14
    353c:	ff 92       	push	r15
    353e:	0f 93       	push	r16
    3540:	1f 93       	push	r17
    3542:	cf 93       	push	r28
    3544:	df 93       	push	r29
    3546:	0f b6       	in	r0, 0x3f	; 63
    3548:	f8 94       	cli
    354a:	0f 92       	push	r0
    354c:	80 91 d4 0b 	lds	r24, 0x0BD4
    3550:	81 50       	subi	r24, 0x01	; 1
    3552:	80 93 d4 0b 	sts	0x0BD4, r24
    3556:	80 91 d4 0b 	lds	r24, 0x0BD4
    355a:	81 11       	cpse	r24, r1
    355c:	56 c0       	rjmp	.+172    	; 0x360a <xTaskResumeAll+0xd4>
    355e:	80 91 e5 0b 	lds	r24, 0x0BE5
    3562:	88 23       	and	r24, r24
    3564:	09 f4       	brne	.+2      	; 0x3568 <xTaskResumeAll+0x32>
    3566:	53 c0       	rjmp	.+166    	; 0x360e <xTaskResumeAll+0xd8>
    3568:	c0 e0       	ldi	r28, 0x00	; 0
    356a:	d0 e0       	ldi	r29, 0x00	; 0
    356c:	0f 2e       	mov	r0, r31
    356e:	fd ef       	ldi	r31, 0xFD	; 253
    3570:	ef 2e       	mov	r14, r31
    3572:	fb e0       	ldi	r31, 0x0B	; 11
    3574:	ff 2e       	mov	r15, r31
    3576:	f0 2d       	mov	r31, r0
    3578:	0f 2e       	mov	r0, r31
    357a:	fb e0       	ldi	r31, 0x0B	; 11
    357c:	df 2e       	mov	r13, r31
    357e:	f0 2d       	mov	r31, r0
    3580:	cc 24       	eor	r12, r12
    3582:	c3 94       	inc	r12
    3584:	27 c0       	rjmp	.+78     	; 0x35d4 <xTaskResumeAll+0x9e>
    3586:	e0 91 04 0c 	lds	r30, 0x0C04
    358a:	f0 91 05 0c 	lds	r31, 0x0C05
    358e:	c0 85       	ldd	r28, Z+8	; 0x08
    3590:	d1 85       	ldd	r29, Z+9	; 0x09
    3592:	ce 01       	movw	r24, r28
    3594:	0e 96       	adiw	r24, 0x0e	; 14
    3596:	51 d8       	rcall	.-3934   	; 0x263a <uxListRemove>
    3598:	8e 01       	movw	r16, r28
    359a:	0e 5f       	subi	r16, 0xFE	; 254
    359c:	1f 4f       	sbci	r17, 0xFF	; 255
    359e:	c8 01       	movw	r24, r16
    35a0:	4c d8       	rcall	.-3944   	; 0x263a <uxListRemove>
    35a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    35a4:	90 91 e0 0b 	lds	r25, 0x0BE0
    35a8:	98 17       	cp	r25, r24
    35aa:	10 f4       	brcc	.+4      	; 0x35b0 <xTaskResumeAll+0x7a>
    35ac:	80 93 e0 0b 	sts	0x0BE0, r24
    35b0:	d8 9e       	mul	r13, r24
    35b2:	c0 01       	movw	r24, r0
    35b4:	11 24       	eor	r1, r1
    35b6:	b8 01       	movw	r22, r16
    35b8:	8e 5d       	subi	r24, 0xDE	; 222
    35ba:	93 4f       	sbci	r25, 0xF3	; 243
    35bc:	0e 94 bf 12 	call	0x257e	; 0x257e <vListInsertEnd>
    35c0:	e0 91 4e 0c 	lds	r30, 0x0C4E
    35c4:	f0 91 4f 0c 	lds	r31, 0x0C4F
    35c8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    35ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    35cc:	98 17       	cp	r25, r24
    35ce:	10 f0       	brcs	.+4      	; 0x35d4 <xTaskResumeAll+0x9e>
    35d0:	c0 92 dd 0b 	sts	0x0BDD, r12
    35d4:	f7 01       	movw	r30, r14
    35d6:	80 81       	ld	r24, Z
    35d8:	81 11       	cpse	r24, r1
    35da:	d5 cf       	rjmp	.-86     	; 0x3586 <xTaskResumeAll+0x50>
    35dc:	cd 2b       	or	r28, r29
    35de:	09 f0       	breq	.+2      	; 0x35e2 <xTaskResumeAll+0xac>
    35e0:	de dc       	rcall	.-1604   	; 0x2f9e <prvResetNextTaskUnblockTime>
    35e2:	c0 91 de 0b 	lds	r28, 0x0BDE
    35e6:	cc 23       	and	r28, r28
    35e8:	49 f0       	breq	.+18     	; 0x35fc <xTaskResumeAll+0xc6>
    35ea:	d1 e0       	ldi	r29, 0x01	; 1
    35ec:	d0 de       	rcall	.-608    	; 0x338e <xTaskIncrementTick>
    35ee:	81 11       	cpse	r24, r1
    35f0:	d0 93 dd 0b 	sts	0x0BDD, r29
    35f4:	c1 50       	subi	r28, 0x01	; 1
    35f6:	d1 f7       	brne	.-12     	; 0x35ec <xTaskResumeAll+0xb6>
    35f8:	10 92 de 0b 	sts	0x0BDE, r1
    35fc:	80 91 dd 0b 	lds	r24, 0x0BDD
    3600:	88 23       	and	r24, r24
    3602:	39 f0       	breq	.+14     	; 0x3612 <xTaskResumeAll+0xdc>
    3604:	e3 d8       	rcall	.-3642   	; 0x27cc <vPortYield>
    3606:	81 e0       	ldi	r24, 0x01	; 1
    3608:	05 c0       	rjmp	.+10     	; 0x3614 <xTaskResumeAll+0xde>
    360a:	80 e0       	ldi	r24, 0x00	; 0
    360c:	03 c0       	rjmp	.+6      	; 0x3614 <xTaskResumeAll+0xde>
    360e:	80 e0       	ldi	r24, 0x00	; 0
    3610:	01 c0       	rjmp	.+2      	; 0x3614 <xTaskResumeAll+0xde>
    3612:	80 e0       	ldi	r24, 0x00	; 0
    3614:	0f 90       	pop	r0
    3616:	0f be       	out	0x3f, r0	; 63
    3618:	df 91       	pop	r29
    361a:	cf 91       	pop	r28
    361c:	1f 91       	pop	r17
    361e:	0f 91       	pop	r16
    3620:	ff 90       	pop	r15
    3622:	ef 90       	pop	r14
    3624:	df 90       	pop	r13
    3626:	cf 90       	pop	r12
    3628:	08 95       	ret

0000362a <vTaskDelay>:
    362a:	cf 92       	push	r12
    362c:	df 92       	push	r13
    362e:	ef 92       	push	r14
    3630:	ff 92       	push	r15
    3632:	6b 01       	movw	r12, r22
    3634:	7c 01       	movw	r14, r24
    3636:	61 15       	cp	r22, r1
    3638:	71 05       	cpc	r23, r1
    363a:	81 05       	cpc	r24, r1
    363c:	91 05       	cpc	r25, r1
    363e:	41 f0       	breq	.+16     	; 0x3650 <vTaskDelay+0x26>
    3640:	a0 de       	rcall	.-704    	; 0x3382 <vTaskSuspendAll>
    3642:	40 e0       	ldi	r20, 0x00	; 0
    3644:	c7 01       	movw	r24, r14
    3646:	b6 01       	movw	r22, r12
    3648:	fe dc       	rcall	.-1540   	; 0x3046 <prvAddCurrentTaskToDelayedList>
    364a:	75 df       	rcall	.-278    	; 0x3536 <xTaskResumeAll>
    364c:	81 11       	cpse	r24, r1
    364e:	01 c0       	rjmp	.+2      	; 0x3652 <vTaskDelay+0x28>
    3650:	bd d8       	rcall	.-3718   	; 0x27cc <vPortYield>
    3652:	ff 90       	pop	r15
    3654:	ef 90       	pop	r14
    3656:	df 90       	pop	r13
    3658:	cf 90       	pop	r12
    365a:	08 95       	ret

0000365c <vTaskSwitchContext>:
    365c:	80 91 d4 0b 	lds	r24, 0x0BD4
    3660:	88 23       	and	r24, r24
    3662:	21 f0       	breq	.+8      	; 0x366c <vTaskSwitchContext+0x10>
    3664:	81 e0       	ldi	r24, 0x01	; 1
    3666:	80 93 dd 0b 	sts	0x0BDD, r24
    366a:	08 95       	ret
    366c:	10 92 dd 0b 	sts	0x0BDD, r1
    3670:	20 91 e0 0b 	lds	r18, 0x0BE0
    3674:	82 2f       	mov	r24, r18
    3676:	90 e0       	ldi	r25, 0x00	; 0
    3678:	3b e0       	ldi	r19, 0x0B	; 11
    367a:	23 9f       	mul	r18, r19
    367c:	f0 01       	movw	r30, r0
    367e:	11 24       	eor	r1, r1
    3680:	ee 5d       	subi	r30, 0xDE	; 222
    3682:	f3 4f       	sbci	r31, 0xF3	; 243
    3684:	30 81       	ld	r19, Z
    3686:	31 11       	cpse	r19, r1
    3688:	0e c0       	rjmp	.+28     	; 0x36a6 <vTaskSwitchContext+0x4a>
    368a:	4b e0       	ldi	r20, 0x0B	; 11
    368c:	21 50       	subi	r18, 0x01	; 1
    368e:	82 2f       	mov	r24, r18
    3690:	90 e0       	ldi	r25, 0x00	; 0
    3692:	48 9f       	mul	r20, r24
    3694:	f0 01       	movw	r30, r0
    3696:	49 9f       	mul	r20, r25
    3698:	f0 0d       	add	r31, r0
    369a:	11 24       	eor	r1, r1
    369c:	ee 5d       	subi	r30, 0xDE	; 222
    369e:	f3 4f       	sbci	r31, 0xF3	; 243
    36a0:	30 81       	ld	r19, Z
    36a2:	33 23       	and	r19, r19
    36a4:	99 f3       	breq	.-26     	; 0x368c <vTaskSwitchContext+0x30>
    36a6:	3b e0       	ldi	r19, 0x0B	; 11
    36a8:	38 9f       	mul	r19, r24
    36aa:	f0 01       	movw	r30, r0
    36ac:	39 9f       	mul	r19, r25
    36ae:	f0 0d       	add	r31, r0
    36b0:	11 24       	eor	r1, r1
    36b2:	ee 5d       	subi	r30, 0xDE	; 222
    36b4:	f3 4f       	sbci	r31, 0xF3	; 243
    36b6:	a1 81       	ldd	r26, Z+1	; 0x01
    36b8:	b2 81       	ldd	r27, Z+2	; 0x02
    36ba:	14 96       	adiw	r26, 0x04	; 4
    36bc:	0d 90       	ld	r0, X+
    36be:	bc 91       	ld	r27, X
    36c0:	a0 2d       	mov	r26, r0
    36c2:	b2 83       	std	Z+2, r27	; 0x02
    36c4:	a1 83       	std	Z+1, r26	; 0x01
    36c6:	cf 01       	movw	r24, r30
    36c8:	03 96       	adiw	r24, 0x03	; 3
    36ca:	a8 17       	cp	r26, r24
    36cc:	b9 07       	cpc	r27, r25
    36ce:	31 f4       	brne	.+12     	; 0x36dc <vTaskSwitchContext+0x80>
    36d0:	14 96       	adiw	r26, 0x04	; 4
    36d2:	8d 91       	ld	r24, X+
    36d4:	9c 91       	ld	r25, X
    36d6:	15 97       	sbiw	r26, 0x05	; 5
    36d8:	92 83       	std	Z+2, r25	; 0x02
    36da:	81 83       	std	Z+1, r24	; 0x01
    36dc:	01 80       	ldd	r0, Z+1	; 0x01
    36de:	f2 81       	ldd	r31, Z+2	; 0x02
    36e0:	e0 2d       	mov	r30, r0
    36e2:	80 85       	ldd	r24, Z+8	; 0x08
    36e4:	91 85       	ldd	r25, Z+9	; 0x09
    36e6:	90 93 4f 0c 	sts	0x0C4F, r25
    36ea:	80 93 4e 0c 	sts	0x0C4E, r24
    36ee:	20 93 e0 0b 	sts	0x0BE0, r18
    36f2:	08 95       	ret

000036f4 <vTaskPlaceOnEventList>:
    36f4:	cf 92       	push	r12
    36f6:	df 92       	push	r13
    36f8:	ef 92       	push	r14
    36fa:	ff 92       	push	r15
    36fc:	6a 01       	movw	r12, r20
    36fe:	7b 01       	movw	r14, r22
    3700:	60 91 4e 0c 	lds	r22, 0x0C4E
    3704:	70 91 4f 0c 	lds	r23, 0x0C4F
    3708:	62 5f       	subi	r22, 0xF2	; 242
    370a:	7f 4f       	sbci	r23, 0xFF	; 255
    370c:	0e 94 e0 12 	call	0x25c0	; 0x25c0 <vListInsert>
    3710:	41 e0       	ldi	r20, 0x01	; 1
    3712:	c7 01       	movw	r24, r14
    3714:	b6 01       	movw	r22, r12
    3716:	97 dc       	rcall	.-1746   	; 0x3046 <prvAddCurrentTaskToDelayedList>
    3718:	ff 90       	pop	r15
    371a:	ef 90       	pop	r14
    371c:	df 90       	pop	r13
    371e:	cf 90       	pop	r12
    3720:	08 95       	ret

00003722 <xTaskRemoveFromEventList>:
    3722:	0f 93       	push	r16
    3724:	1f 93       	push	r17
    3726:	cf 93       	push	r28
    3728:	df 93       	push	r29
    372a:	dc 01       	movw	r26, r24
    372c:	17 96       	adiw	r26, 0x07	; 7
    372e:	ed 91       	ld	r30, X+
    3730:	fc 91       	ld	r31, X
    3732:	18 97       	sbiw	r26, 0x08	; 8
    3734:	c0 85       	ldd	r28, Z+8	; 0x08
    3736:	d1 85       	ldd	r29, Z+9	; 0x09
    3738:	8e 01       	movw	r16, r28
    373a:	02 5f       	subi	r16, 0xF2	; 242
    373c:	1f 4f       	sbci	r17, 0xFF	; 255
    373e:	c8 01       	movw	r24, r16
    3740:	0e 94 1d 13 	call	0x263a	; 0x263a <uxListRemove>
    3744:	80 91 d4 0b 	lds	r24, 0x0BD4
    3748:	81 11       	cpse	r24, r1
    374a:	16 c0       	rjmp	.+44     	; 0x3778 <xTaskRemoveFromEventList+0x56>
    374c:	0c 50       	subi	r16, 0x0C	; 12
    374e:	11 09       	sbc	r17, r1
    3750:	c8 01       	movw	r24, r16
    3752:	0e 94 1d 13 	call	0x263a	; 0x263a <uxListRemove>
    3756:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3758:	90 91 e0 0b 	lds	r25, 0x0BE0
    375c:	98 17       	cp	r25, r24
    375e:	10 f4       	brcc	.+4      	; 0x3764 <xTaskRemoveFromEventList+0x42>
    3760:	80 93 e0 0b 	sts	0x0BE0, r24
    3764:	bb e0       	ldi	r27, 0x0B	; 11
    3766:	8b 9f       	mul	r24, r27
    3768:	c0 01       	movw	r24, r0
    376a:	11 24       	eor	r1, r1
    376c:	b8 01       	movw	r22, r16
    376e:	8e 5d       	subi	r24, 0xDE	; 222
    3770:	93 4f       	sbci	r25, 0xF3	; 243
    3772:	0e 94 bf 12 	call	0x257e	; 0x257e <vListInsertEnd>
    3776:	05 c0       	rjmp	.+10     	; 0x3782 <xTaskRemoveFromEventList+0x60>
    3778:	b8 01       	movw	r22, r16
    377a:	8d ef       	ldi	r24, 0xFD	; 253
    377c:	9b e0       	ldi	r25, 0x0B	; 11
    377e:	0e 94 bf 12 	call	0x257e	; 0x257e <vListInsertEnd>
    3782:	e0 91 4e 0c 	lds	r30, 0x0C4E
    3786:	f0 91 4f 0c 	lds	r31, 0x0C4F
    378a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    378c:	82 8d       	ldd	r24, Z+26	; 0x1a
    378e:	89 17       	cp	r24, r25
    3790:	20 f4       	brcc	.+8      	; 0x379a <xTaskRemoveFromEventList+0x78>
    3792:	81 e0       	ldi	r24, 0x01	; 1
    3794:	80 93 dd 0b 	sts	0x0BDD, r24
    3798:	01 c0       	rjmp	.+2      	; 0x379c <xTaskRemoveFromEventList+0x7a>
    379a:	80 e0       	ldi	r24, 0x00	; 0
    379c:	df 91       	pop	r29
    379e:	cf 91       	pop	r28
    37a0:	1f 91       	pop	r17
    37a2:	0f 91       	pop	r16
    37a4:	08 95       	ret

000037a6 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    37a6:	20 91 dc 0b 	lds	r18, 0x0BDC
    37aa:	fc 01       	movw	r30, r24
    37ac:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    37ae:	40 91 e1 0b 	lds	r20, 0x0BE1
    37b2:	50 91 e2 0b 	lds	r21, 0x0BE2
    37b6:	60 91 e3 0b 	lds	r22, 0x0BE3
    37ba:	70 91 e4 0b 	lds	r23, 0x0BE4
    37be:	41 83       	std	Z+1, r20	; 0x01
    37c0:	52 83       	std	Z+2, r21	; 0x02
    37c2:	63 83       	std	Z+3, r22	; 0x03
    37c4:	74 83       	std	Z+4, r23	; 0x04
    37c6:	08 95       	ret

000037c8 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    37c8:	cf 92       	push	r12
    37ca:	df 92       	push	r13
    37cc:	ef 92       	push	r14
    37ce:	ff 92       	push	r15
    37d0:	0f 93       	push	r16
    37d2:	1f 93       	push	r17
    37d4:	cf 93       	push	r28
    37d6:	df 93       	push	r29
    37d8:	fb 01       	movw	r30, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    37da:	0f b6       	in	r0, 0x3f	; 63
    37dc:	f8 94       	cli
    37de:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    37e0:	c0 90 e1 0b 	lds	r12, 0x0BE1
    37e4:	d0 90 e2 0b 	lds	r13, 0x0BE2
    37e8:	e0 90 e3 0b 	lds	r14, 0x0BE3
    37ec:	f0 90 e4 0b 	lds	r15, 0x0BE4
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    37f0:	dc 01       	movw	r26, r24
    37f2:	11 96       	adiw	r26, 0x01	; 1
    37f4:	0d 91       	ld	r16, X+
    37f6:	1d 91       	ld	r17, X+
    37f8:	2d 91       	ld	r18, X+
    37fa:	3c 91       	ld	r19, X
    37fc:	14 97       	sbiw	r26, 0x04	; 4
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    37fe:	40 81       	ld	r20, Z
    3800:	51 81       	ldd	r21, Z+1	; 0x01
    3802:	62 81       	ldd	r22, Z+2	; 0x02
    3804:	73 81       	ldd	r23, Z+3	; 0x03
    3806:	4f 3f       	cpi	r20, 0xFF	; 255
    3808:	bf ef       	ldi	r27, 0xFF	; 255
    380a:	5b 07       	cpc	r21, r27
    380c:	6b 07       	cpc	r22, r27
    380e:	7b 07       	cpc	r23, r27
    3810:	29 f1       	breq	.+74     	; 0x385c <xTaskCheckForTimeOut+0x94>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3812:	a0 91 dc 0b 	lds	r26, 0x0BDC
    3816:	ec 01       	movw	r28, r24
    3818:	b8 81       	ld	r27, Y
    381a:	ba 17       	cp	r27, r26
    381c:	29 f0       	breq	.+10     	; 0x3828 <xTaskCheckForTimeOut+0x60>
    381e:	c0 16       	cp	r12, r16
    3820:	d1 06       	cpc	r13, r17
    3822:	e2 06       	cpc	r14, r18
    3824:	f3 06       	cpc	r15, r19
    3826:	e0 f4       	brcc	.+56     	; 0x3860 <xTaskCheckForTimeOut+0x98>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3828:	c0 1a       	sub	r12, r16
    382a:	d1 0a       	sbc	r13, r17
    382c:	e2 0a       	sbc	r14, r18
    382e:	f3 0a       	sbc	r15, r19
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3830:	c4 16       	cp	r12, r20
    3832:	d5 06       	cpc	r13, r21
    3834:	e6 06       	cpc	r14, r22
    3836:	f7 06       	cpc	r15, r23
    3838:	58 f4       	brcc	.+22     	; 0x3850 <xTaskCheckForTimeOut+0x88>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    383a:	4c 19       	sub	r20, r12
    383c:	5d 09       	sbc	r21, r13
    383e:	6e 09       	sbc	r22, r14
    3840:	7f 09       	sbc	r23, r15
    3842:	40 83       	st	Z, r20
    3844:	51 83       	std	Z+1, r21	; 0x01
    3846:	62 83       	std	Z+2, r22	; 0x02
    3848:	73 83       	std	Z+3, r23	; 0x03
			vTaskInternalSetTimeOutState( pxTimeOut );
    384a:	ad df       	rcall	.-166    	; 0x37a6 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    384c:	80 e0       	ldi	r24, 0x00	; 0
    384e:	09 c0       	rjmp	.+18     	; 0x3862 <xTaskCheckForTimeOut+0x9a>
		}
		else
		{
			*pxTicksToWait = 0;
    3850:	10 82       	st	Z, r1
    3852:	11 82       	std	Z+1, r1	; 0x01
    3854:	12 82       	std	Z+2, r1	; 0x02
    3856:	13 82       	std	Z+3, r1	; 0x03
			xReturn = pdTRUE;
    3858:	81 e0       	ldi	r24, 0x01	; 1
    385a:	03 c0       	rjmp	.+6      	; 0x3862 <xTaskCheckForTimeOut+0x9a>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    385c:	80 e0       	ldi	r24, 0x00	; 0
    385e:	01 c0       	rjmp	.+2      	; 0x3862 <xTaskCheckForTimeOut+0x9a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3860:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    3862:	0f 90       	pop	r0
    3864:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    3866:	df 91       	pop	r29
    3868:	cf 91       	pop	r28
    386a:	1f 91       	pop	r17
    386c:	0f 91       	pop	r16
    386e:	ff 90       	pop	r15
    3870:	ef 90       	pop	r14
    3872:	df 90       	pop	r13
    3874:	cf 90       	pop	r12
    3876:	08 95       	ret

00003878 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    3878:	81 e0       	ldi	r24, 0x01	; 1
    387a:	80 93 dd 0b 	sts	0x0BDD, r24
    387e:	08 95       	ret

00003880 <readeeprom>:
		while(isbitset(*EEPROM_CONTROL_ADD,1));
	}
}

uint8 readeeprom(uint16 ADD)
{while(isbitset(*EEPROM_CONTROL_ADD,1));  /*checking the last write is done*/
    3880:	e1 99       	sbic	0x1c, 1	; 28
    3882:	fe cf       	rjmp	.-4      	; 0x3880 <readeeprom>
	*EEPROM_ADDRESS_HIGH_ADD=ADD>>8;
    3884:	9f bb       	out	0x1f, r25	; 31
	*EEPROM_ADDRESS_LOW_ADD=ADD;
    3886:	8e bb       	out	0x1e, r24	; 30
    clearbit(*EEPROM_CONTROL_ADD,2);
    3888:	e2 98       	cbi	0x1c, 2	; 28
	setbit(*EEPROM_CONTROL_ADD,0);	
    388a:	e0 9a       	sbi	0x1c, 0	; 28
	
	return *EEPROM_DATA_ADD;
    388c:	8d b3       	in	r24, 0x1d	; 29
}
    388e:	08 95       	ret

00003890 <writeeeprom>:
 *  Author: ideapad510
 */ 
#include "eeprom.h"

void writeeeprom(uint16 ADD,uint8 Data)
{
    3890:	1f 93       	push	r17
    3892:	cf 93       	push	r28
    3894:	df 93       	push	r29
    3896:	d8 2f       	mov	r29, r24
    3898:	19 2f       	mov	r17, r25
    389a:	c6 2f       	mov	r28, r22
	if (readeeprom(ADD)!=Data)
    389c:	f1 df       	rcall	.-30     	; 0x3880 <readeeprom>
    389e:	8c 17       	cp	r24, r28
    38a0:	51 f0       	breq	.+20     	; 0x38b6 <writeeeprom+0x26>
	{
		while(isbitset(*EEPROM_CONTROL_ADD,1));  /*checking the last write is done*/
    38a2:	e1 99       	sbic	0x1c, 1	; 28
    38a4:	fe cf       	rjmp	.-4      	; 0x38a2 <writeeeprom+0x12>
		*EEPROM_ADDRESS_HIGH_ADD=ADD>>8;
    38a6:	1f bb       	out	0x1f, r17	; 31
		*EEPROM_ADDRESS_LOW_ADD=ADD;
    38a8:	de bb       	out	0x1e, r29	; 30
		*EEPROM_DATA_ADD=Data;
    38aa:	cd bb       	out	0x1d, r28	; 29
		setbit(*EEPROM_CONTROL_ADD,2);
    38ac:	e2 9a       	sbi	0x1c, 2	; 28
		clearbit(*EEPROM_CONTROL_ADD,0);
    38ae:	e0 98       	cbi	0x1c, 0	; 28
		setbit(*EEPROM_CONTROL_ADD,1);
    38b0:	e1 9a       	sbi	0x1c, 1	; 28
		while(isbitset(*EEPROM_CONTROL_ADD,1));
    38b2:	e1 99       	sbic	0x1c, 1	; 28
    38b4:	fe cf       	rjmp	.-4      	; 0x38b2 <writeeeprom+0x22>
	}
}
    38b6:	df 91       	pop	r29
    38b8:	cf 91       	pop	r28
    38ba:	1f 91       	pop	r17
    38bc:	08 95       	ret

000038be <external_int_enable>:
 */ 
#include "EXINTEREPUT128A.h"

void external_int_enable(INT_ENABLE_NUMBER INT_NUM,INT_POLARTY POLARTY)
{
	global_interupt_disable();
    38be:	9f b7       	in	r25, 0x3f	; 63
    38c0:	9f 77       	andi	r25, 0x7F	; 127
    38c2:	9f bf       	out	0x3f, r25	; 63
	EIMSK|=INT_NUM;
    38c4:	99 b7       	in	r25, 0x39	; 57
    38c6:	98 2b       	or	r25, r24
    38c8:	99 bf       	out	0x39, r25	; 57
	switch(INT_NUM)
    38ca:	88 30       	cpi	r24, 0x08	; 8
    38cc:	c1 f1       	breq	.+112    	; 0x393e <external_int_enable+0x80>
    38ce:	40 f4       	brcc	.+16     	; 0x38e0 <external_int_enable+0x22>
    38d0:	82 30       	cpi	r24, 0x02	; 2
    38d2:	e9 f0       	breq	.+58     	; 0x390e <external_int_enable+0x50>
    38d4:	84 30       	cpi	r24, 0x04	; 4
    38d6:	31 f1       	breq	.+76     	; 0x3924 <external_int_enable+0x66>
    38d8:	81 30       	cpi	r24, 0x01	; 1
    38da:	09 f0       	breq	.+2      	; 0x38de <external_int_enable+0x20>
    38dc:	62 c0       	rjmp	.+196    	; 0x39a2 <external_int_enable+0xe4>
    38de:	0e c0       	rjmp	.+28     	; 0x38fc <external_int_enable+0x3e>
    38e0:	80 32       	cpi	r24, 0x20	; 32
    38e2:	09 f4       	brne	.+2      	; 0x38e6 <external_int_enable+0x28>
    38e4:	40 c0       	rjmp	.+128    	; 0x3966 <external_int_enable+0xa8>
    38e6:	18 f4       	brcc	.+6      	; 0x38ee <external_int_enable+0x30>
    38e8:	80 31       	cpi	r24, 0x10	; 16
    38ea:	b1 f1       	breq	.+108    	; 0x3958 <external_int_enable+0x9a>
    38ec:	5a c0       	rjmp	.+180    	; 0x39a2 <external_int_enable+0xe4>
    38ee:	80 34       	cpi	r24, 0x40	; 64
    38f0:	09 f4       	brne	.+2      	; 0x38f4 <external_int_enable+0x36>
    38f2:	42 c0       	rjmp	.+132    	; 0x3978 <external_int_enable+0xba>
    38f4:	80 38       	cpi	r24, 0x80	; 128
    38f6:	09 f4       	brne	.+2      	; 0x38fa <external_int_enable+0x3c>
    38f8:	4a c0       	rjmp	.+148    	; 0x398e <external_int_enable+0xd0>
    38fa:	53 c0       	rjmp	.+166    	; 0x39a2 <external_int_enable+0xe4>
	{   case INT0_ENABLE:EICRA&=0xfc;
    38fc:	ea e6       	ldi	r30, 0x6A	; 106
    38fe:	f0 e0       	ldi	r31, 0x00	; 0
    3900:	80 81       	ld	r24, Z
    3902:	8c 7f       	andi	r24, 0xFC	; 252
    3904:	80 83       	st	Z, r24
		                 EICRA|=POLARTY;
    3906:	80 81       	ld	r24, Z
    3908:	68 2b       	or	r22, r24
    390a:	60 83       	st	Z, r22
						 break;
    390c:	4a c0       	rjmp	.+148    	; 0x39a2 <external_int_enable+0xe4>
		case INT1_ENABLE:EICRA&=0xf3;
    390e:	ea e6       	ldi	r30, 0x6A	; 106
    3910:	f0 e0       	ldi	r31, 0x00	; 0
    3912:	80 81       	ld	r24, Z
    3914:	83 7f       	andi	r24, 0xF3	; 243
    3916:	80 83       	st	Z, r24
						 EICRA|=POLARTY<<2;
    3918:	80 81       	ld	r24, Z
    391a:	66 0f       	add	r22, r22
    391c:	66 0f       	add	r22, r22
    391e:	68 2b       	or	r22, r24
    3920:	60 83       	st	Z, r22
					     break;
    3922:	3f c0       	rjmp	.+126    	; 0x39a2 <external_int_enable+0xe4>
		
		case INT2_ENABLE:EICRA&=0xcf;
    3924:	ea e6       	ldi	r30, 0x6A	; 106
    3926:	f0 e0       	ldi	r31, 0x00	; 0
    3928:	80 81       	ld	r24, Z
    392a:	8f 7c       	andi	r24, 0xCF	; 207
    392c:	80 83       	st	Z, r24
						 EICRA|=POLARTY<<4;
    392e:	80 81       	ld	r24, Z
    3930:	90 e1       	ldi	r25, 0x10	; 16
    3932:	69 9f       	mul	r22, r25
    3934:	b0 01       	movw	r22, r0
    3936:	11 24       	eor	r1, r1
    3938:	68 2b       	or	r22, r24
    393a:	60 83       	st	Z, r22
						 break;
    393c:	32 c0       	rjmp	.+100    	; 0x39a2 <external_int_enable+0xe4>
		case INT3_ENABLE:EICRA&=0x3f;
    393e:	ea e6       	ldi	r30, 0x6A	; 106
    3940:	f0 e0       	ldi	r31, 0x00	; 0
    3942:	80 81       	ld	r24, Z
    3944:	8f 73       	andi	r24, 0x3F	; 63
    3946:	80 83       	st	Z, r24
					     EICRA|=POLARTY<<6;
    3948:	80 81       	ld	r24, Z
    394a:	90 e4       	ldi	r25, 0x40	; 64
    394c:	69 9f       	mul	r22, r25
    394e:	b0 01       	movw	r22, r0
    3950:	11 24       	eor	r1, r1
    3952:	68 2b       	or	r22, r24
    3954:	60 83       	st	Z, r22
						 break;
    3956:	25 c0       	rjmp	.+74     	; 0x39a2 <external_int_enable+0xe4>
		case INT4_ENABLE:EICRB&=0xfc;
    3958:	8a b7       	in	r24, 0x3a	; 58
    395a:	8c 7f       	andi	r24, 0xFC	; 252
    395c:	8a bf       	out	0x3a, r24	; 58
						 EICRB|=POLARTY;
    395e:	8a b7       	in	r24, 0x3a	; 58
    3960:	68 2b       	or	r22, r24
    3962:	6a bf       	out	0x3a, r22	; 58
						 break;
    3964:	1e c0       	rjmp	.+60     	; 0x39a2 <external_int_enable+0xe4>
		case INT5_ENABLE:EICRB&=0xf3;
    3966:	8a b7       	in	r24, 0x3a	; 58
    3968:	83 7f       	andi	r24, 0xF3	; 243
    396a:	8a bf       	out	0x3a, r24	; 58
						 EICRB|=POLARTY<<2;
    396c:	8a b7       	in	r24, 0x3a	; 58
    396e:	66 0f       	add	r22, r22
    3970:	66 0f       	add	r22, r22
    3972:	68 2b       	or	r22, r24
    3974:	6a bf       	out	0x3a, r22	; 58
						 break;
    3976:	15 c0       	rjmp	.+42     	; 0x39a2 <external_int_enable+0xe4>
		
		case INT6_ENABLE:EICRB&=0xcf;
    3978:	8a b7       	in	r24, 0x3a	; 58
    397a:	8f 7c       	andi	r24, 0xCF	; 207
    397c:	8a bf       	out	0x3a, r24	; 58
						 EICRB|=POLARTY<<4;
    397e:	8a b7       	in	r24, 0x3a	; 58
    3980:	90 e1       	ldi	r25, 0x10	; 16
    3982:	69 9f       	mul	r22, r25
    3984:	b0 01       	movw	r22, r0
    3986:	11 24       	eor	r1, r1
    3988:	68 2b       	or	r22, r24
    398a:	6a bf       	out	0x3a, r22	; 58
						 break;
    398c:	0a c0       	rjmp	.+20     	; 0x39a2 <external_int_enable+0xe4>
		case INT7_ENABLE:EICRB&=0x3f;
    398e:	8a b7       	in	r24, 0x3a	; 58
    3990:	8f 73       	andi	r24, 0x3F	; 63
    3992:	8a bf       	out	0x3a, r24	; 58
						 EICRB|=POLARTY<<6;
    3994:	8a b7       	in	r24, 0x3a	; 58
    3996:	90 e4       	ldi	r25, 0x40	; 64
    3998:	69 9f       	mul	r22, r25
    399a:	b0 01       	movw	r22, r0
    399c:	11 24       	eor	r1, r1
    399e:	68 2b       	or	r22, r24
    39a0:	6a bf       	out	0x3a, r22	; 58
						 break;
	}
	global_interupt_enable();
    39a2:	8f b7       	in	r24, 0x3f	; 63
    39a4:	80 68       	ori	r24, 0x80	; 128
    39a6:	8f bf       	out	0x3f, r24	; 63
    39a8:	08 95       	ret

000039aa <SPI_INT>:
 */ 

#include "spi.h"
 volatile  SPI_DATA data;
void SPI_INT(SPI_OPMODE opmode, SPI_PRESCALE prescale,SPI_MODE mode, SPI_INTURUPT intupt,SPI_DATA_ORDER order)
{	switch (opmode)
    39aa:	ff 92       	push	r15
    39ac:	0f 93       	push	r16
    39ae:	1f 93       	push	r17
    39b0:	cf 93       	push	r28
    39b2:	df 93       	push	r29
    39b4:	c6 2f       	mov	r28, r22
    39b6:	f7 2e       	mov	r15, r23
    39b8:	d4 2f       	mov	r29, r20
    39ba:	12 2f       	mov	r17, r18
    39bc:	88 23       	and	r24, r24
    39be:	29 f1       	breq	.+74     	; 0x3a0a <SPI_INT+0x60>
    39c0:	80 31       	cpi	r24, 0x10	; 16
    39c2:	89 f5       	brne	.+98     	; 0x3a26 <SPI_INT+0x7c>
	{
		case SPI_MASTER: gpio_outputconfg(DDR_MOSI_ADDRESS,PORT_OUTMOD_MOSI_ADDRESS,OUTPASS,MOSI_PIN);
    39c4:	22 e0       	ldi	r18, 0x02	; 2
    39c6:	40 e0       	ldi	r20, 0x00	; 0
    39c8:	66 e3       	ldi	r22, 0x36	; 54
    39ca:	70 e0       	ldi	r23, 0x00	; 0
    39cc:	87 e3       	ldi	r24, 0x37	; 55
    39ce:	90 e0       	ldi	r25, 0x00	; 0
    39d0:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
		                 gpio_outputconfg(DDR_SS_ADDRESS,PORT_OUTMOD_SS_ADDRESS,OUTPASS,SS_PIN);
    39d4:	20 e0       	ldi	r18, 0x00	; 0
    39d6:	40 e0       	ldi	r20, 0x00	; 0
    39d8:	66 e3       	ldi	r22, 0x36	; 54
    39da:	70 e0       	ldi	r23, 0x00	; 0
    39dc:	87 e3       	ldi	r24, 0x37	; 55
    39de:	90 e0       	ldi	r25, 0x00	; 0
    39e0:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
						 gpio_outputconfg(DDR_SCK_ADDRESS,PORT_OUTMOD_SCK_ADDRESS,OUTPASS,SCK_PIN);
    39e4:	21 e0       	ldi	r18, 0x01	; 1
    39e6:	40 e0       	ldi	r20, 0x00	; 0
    39e8:	66 e3       	ldi	r22, 0x36	; 54
    39ea:	70 e0       	ldi	r23, 0x00	; 0
    39ec:	87 e3       	ldi	r24, 0x37	; 55
    39ee:	90 e0       	ldi	r25, 0x00	; 0
    39f0:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
                        clearbit(*PORT_OUT_SCK_ADDRESS,SCK_PIN);
    39f4:	c1 98       	cbi	0x18, 1	; 24
						SPSR_ACCESS &=0xFE;
    39f6:	70 98       	cbi	0x0e, 0	; 14
						SPSR_ACCESS |=(prescale>>8);
    39f8:	8e b1       	in	r24, 0x0e	; 14
    39fa:	f8 2a       	or	r15, r24
    39fc:	fe b8       	out	0x0e, r15	; 14
						SPCR_ACCESS=opmode|prescale|mode|intupt|order|0X40;
    39fe:	00 65       	ori	r16, 0x50	; 80
    3a00:	10 2b       	or	r17, r16
    3a02:	d1 2b       	or	r29, r17
    3a04:	cd 2b       	or	r28, r29
    3a06:	cd b9       	out	0x0d, r28	; 13
						
						 break;	                 
    3a08:	0e c0       	rjmp	.+28     	; 0x3a26 <SPI_INT+0x7c>
		
		case SPI_SLAVE: gpio_outputconfg(DDR_MISO_ADDRESS,PORT_OUTMOD_MISO_ADDRESS,OUTPASS,MISO_PIN);
    3a0a:	23 e0       	ldi	r18, 0x03	; 3
    3a0c:	40 e0       	ldi	r20, 0x00	; 0
    3a0e:	66 e3       	ldi	r22, 0x36	; 54
    3a10:	70 e0       	ldi	r23, 0x00	; 0
    3a12:	87 e3       	ldi	r24, 0x37	; 55
    3a14:	90 e0       	ldi	r25, 0x00	; 0
    3a16:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
		              SPSR_ACCESS &=0xFE;
    3a1a:	70 98       	cbi	0x0e, 0	; 14
					  SPCR_ACCESS=opmode|prescale|mode|intupt|order|0X40;
    3a1c:	00 64       	ori	r16, 0x40	; 64
    3a1e:	10 2b       	or	r17, r16
    3a20:	d1 2b       	or	r29, r17
    3a22:	cd 2b       	or	r28, r29
    3a24:	cd b9       	out	0x0d, r28	; 13

	

/*	setbit(*PORT_OUT_SS_ADDRESS,SS_PIN);*/
/*	setbit(*PORT_OUT_SCK_ADDRESS,SCK_PIN);*/
}
    3a26:	df 91       	pop	r29
    3a28:	cf 91       	pop	r28
    3a2a:	1f 91       	pop	r17
    3a2c:	0f 91       	pop	r16
    3a2e:	ff 90       	pop	r15
    3a30:	08 95       	ret

00003a32 <TIMER0_ENABLE>:
			break;    
	case PWM_PHASE_CORRECT_MOD: break;
	
	default:return;
	}
}
    3a32:	13 be       	out	0x33, r1	; 51
    3a34:	97 b7       	in	r25, 0x37	; 55
    3a36:	9c 7f       	andi	r25, 0xFC	; 252
    3a38:	97 bf       	out	0x37, r25	; 55
    3a3a:	93 b7       	in	r25, 0x33	; 51
    3a3c:	49 2b       	or	r20, r25
    3a3e:	64 2b       	or	r22, r20
    3a40:	86 2b       	or	r24, r22
    3a42:	83 bf       	out	0x33, r24	; 51
    3a44:	87 b7       	in	r24, 0x37	; 55
    3a46:	28 2b       	or	r18, r24
    3a48:	27 bf       	out	0x37, r18	; 55
    3a4a:	08 95       	ret

00003a4c <TIMER0_READ_COUNTER>:
unsigned char TIMER0_READ_COUNTER()
{
	return TCNT0;
    3a4c:	82 b7       	in	r24, 0x32	; 50
}
    3a4e:	08 95       	ret

00003a50 <TIMER2_DISABLE>:
 * Created: 30/03/2020 11:57:31 
 *  Author: ideapad510
 */ 
#include "TIMER2.h"
void TIMER2_DISABLE()
{   TCNT2=0;
    3a50:	14 bc       	out	0x24, r1	; 36
	TCCR2=00;
    3a52:	15 bc       	out	0x25, r1	; 37
    3a54:	08 95       	ret

00003a56 <TIMER2_ENABLE>:
}

void TIMER2_ENABLE(WGM2_D MODE,T2_OC2_DATATYPE OC2_TYPE,T2_clock CLK_PRE,unsigned char as2_sync_mode /*1 or 0 default 0*/,T2_INT_DATATYPE out_compare_int,T2_INT_DATATYPE ovr_flow_int ,unsigned char ocr2)
{
    3a56:	cf 92       	push	r12
    3a58:	ef 92       	push	r14
    3a5a:	ff 92       	push	r15
    3a5c:	0f 93       	push	r16
    3a5e:	1f 93       	push	r17
	TCCR2_ACCESS=00;
    3a60:	15 bc       	out	0x25, r1	; 37
	TCCR2_ACCESS|=MODE;
    3a62:	95 b5       	in	r25, 0x25	; 37
    3a64:	89 2b       	or	r24, r25
    3a66:	85 bd       	out	0x25, r24	; 37
	TCCR2_ACCESS|=OC2_TYPE<<4;
    3a68:	35 b5       	in	r19, 0x25	; 37
    3a6a:	50 e1       	ldi	r21, 0x10	; 16
    3a6c:	65 9f       	mul	r22, r21
    3a6e:	c0 01       	movw	r24, r0
    3a70:	11 24       	eor	r1, r1
    3a72:	83 2b       	or	r24, r19
    3a74:	85 bd       	out	0x25, r24	; 37
	TCCR2_ACCESS|=CLK_PRE;
    3a76:	85 b5       	in	r24, 0x25	; 37
    3a78:	48 2b       	or	r20, r24
    3a7a:	45 bd       	out	0x25, r20	; 37
	OCR2_ACCESS=ocr2;
    3a7c:	c3 bc       	out	0x23, r12	; 35
	clearbit(ASSR,3);
    3a7e:	80 b7       	in	r24, 0x30	; 48
    3a80:	87 7f       	andi	r24, 0xF7	; 247
    3a82:	80 bf       	out	0x30, r24	; 48
	ASSR|=as2_sync_mode<<3;
    3a84:	80 b7       	in	r24, 0x30	; 48
    3a86:	22 0f       	add	r18, r18
    3a88:	22 0f       	add	r18, r18
    3a8a:	22 0f       	add	r18, r18
    3a8c:	28 2b       	or	r18, r24
    3a8e:	20 bf       	out	0x30, r18	; 48
	TIMSK_ACCESS&=0x3f;
    3a90:	87 b7       	in	r24, 0x37	; 55
    3a92:	8f 73       	andi	r24, 0x3F	; 63
    3a94:	87 bf       	out	0x37, r24	; 55
	TIMSK_ACCESS|=out_compare_int<<7;
    3a96:	87 b7       	in	r24, 0x37	; 55
    3a98:	90 e8       	ldi	r25, 0x80	; 128
    3a9a:	09 9f       	mul	r16, r25
    3a9c:	80 01       	movw	r16, r0
    3a9e:	11 24       	eor	r1, r1
    3aa0:	08 2b       	or	r16, r24
    3aa2:	07 bf       	out	0x37, r16	; 55
	TIMSK_ACCESS|=ovr_flow_int<<6;
    3aa4:	87 b7       	in	r24, 0x37	; 55
    3aa6:	50 e4       	ldi	r21, 0x40	; 64
    3aa8:	e5 9e       	mul	r14, r21
    3aaa:	70 01       	movw	r14, r0
    3aac:	11 24       	eor	r1, r1
    3aae:	e8 2a       	or	r14, r24
    3ab0:	e7 be       	out	0x37, r14	; 55
	if (OC2_TYPE!=T2_OC2_DISCONNECT)
    3ab2:	66 23       	and	r22, r22
    3ab4:	41 f0       	breq	.+16     	; 0x3ac6 <TIMER2_ENABLE+0x70>
	{gpio_outputconfg(DDR_OC2_ADDRESS,PORT_OUTMOD_OC2_ADDRESS,OUTPASS,OC2_PIN);
    3ab6:	27 e0       	ldi	r18, 0x07	; 7
    3ab8:	40 e0       	ldi	r20, 0x00	; 0
    3aba:	60 e3       	ldi	r22, 0x30	; 48
    3abc:	70 e0       	ldi	r23, 0x00	; 0
    3abe:	81 e3       	ldi	r24, 0x31	; 49
    3ac0:	90 e0       	ldi	r25, 0x00	; 0
    3ac2:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
	}	
}
    3ac6:	1f 91       	pop	r17
    3ac8:	0f 91       	pop	r16
    3aca:	ff 90       	pop	r15
    3acc:	ef 90       	pop	r14
    3ace:	cf 90       	pop	r12
    3ad0:	08 95       	ret

00003ad2 <TIMER3_ENABLE>:
				   T3_INT_DATATYPE OCIE3C_state,  
				   T3_INT_DATATYPE OCIE3B_state, 
				   T3_INT_DATATYPE OCIE3A_state, 
				   
				   T3_INT_DATATYPE TICIE3_state)
{
    3ad2:	8f 92       	push	r8
    3ad4:	9f 92       	push	r9
    3ad6:	af 92       	push	r10
    3ad8:	bf 92       	push	r11
    3ada:	cf 92       	push	r12
    3adc:	df 92       	push	r13
    3ade:	ef 92       	push	r14
    3ae0:	ff 92       	push	r15
    3ae2:	0f 93       	push	r16
    3ae4:	1f 93       	push	r17
    3ae6:	cf 93       	push	r28
    3ae8:	df 93       	push	r29
    3aea:	cd b7       	in	r28, 0x3d	; 61
    3aec:	de b7       	in	r29, 0x3e	; 62
    3aee:	96 2e       	mov	r9, r22
    3af0:	14 2f       	mov	r17, r20
	TCCR3A=00;
    3af2:	eb e8       	ldi	r30, 0x8B	; 139
    3af4:	f0 e0       	ldi	r31, 0x00	; 0
    3af6:	10 82       	st	Z, r1
	TCCR3B=00;
    3af8:	aa e8       	ldi	r26, 0x8A	; 138
    3afa:	b0 e0       	ldi	r27, 0x00	; 0
    3afc:	1c 92       	st	X, r1
	TCCR3A|=COM3A<<6;
    3afe:	90 81       	ld	r25, Z
    3b00:	30 e4       	ldi	r19, 0x40	; 64
    3b02:	83 9f       	mul	r24, r19
    3b04:	b0 01       	movw	r22, r0
    3b06:	11 24       	eor	r1, r1
    3b08:	69 2b       	or	r22, r25
    3b0a:	60 83       	st	Z, r22
	TCCR3A|=COM3B<<4;
    3b0c:	90 81       	ld	r25, Z
    3b0e:	30 e1       	ldi	r19, 0x10	; 16
    3b10:	93 9e       	mul	r9, r19
    3b12:	b0 01       	movw	r22, r0
    3b14:	11 24       	eor	r1, r1
    3b16:	69 2b       	or	r22, r25
    3b18:	60 83       	st	Z, r22
	TCCR3A|=COM3C<<2;
    3b1a:	90 81       	ld	r25, Z
    3b1c:	34 2f       	mov	r19, r20
    3b1e:	33 0f       	add	r19, r19
    3b20:	33 0f       	add	r19, r19
    3b22:	93 2b       	or	r25, r19
    3b24:	90 83       	st	Z, r25
	TCCR3A|=WGM3&0x03;
    3b26:	90 81       	ld	r25, Z
    3b28:	32 2f       	mov	r19, r18
    3b2a:	33 70       	andi	r19, 0x03	; 3
    3b2c:	93 2b       	or	r25, r19
    3b2e:	90 83       	st	Z, r25
	TCCR3B|=(WGM3&0x0c)<<1;
    3b30:	9c 91       	ld	r25, X
    3b32:	2c 70       	andi	r18, 0x0C	; 12
    3b34:	22 0f       	add	r18, r18
    3b36:	29 2b       	or	r18, r25
    3b38:	2c 93       	st	X, r18
    OCR3AH=OCR3A_DATA>>8;
    3b3a:	f0 92 87 00 	sts	0x0087, r15
	OCR3AL=OCR3A_DATA;
    3b3e:	e0 92 86 00 	sts	0x0086, r14
	OCR3BH=OCR3B_DATA>>8;
    3b42:	d0 92 85 00 	sts	0x0085, r13
	OCR3BL=OCR3B_DATA;
    3b46:	c0 92 84 00 	sts	0x0084, r12
	OCR3CH=OCR3C_DATA>>8;
    3b4a:	b0 92 83 00 	sts	0x0083, r11
	OCR3CL=OCR3C_DATA;
    3b4e:	a0 92 82 00 	sts	0x0082, r10
	
	unsigned char x=(OCIE3C_state<<1)|(TOIE3_state<<2)|(OCIE3B_state<<3)|(OCIE3A_state<<4)|(TICIE3_state<<5);
	ETIMSK&=0b00000001;
    3b52:	ed e7       	ldi	r30, 0x7D	; 125
    3b54:	f0 e0       	ldi	r31, 0x00	; 0
    3b56:	90 81       	ld	r25, Z
    3b58:	91 70       	andi	r25, 0x01	; 1
    3b5a:	90 83       	st	Z, r25
	ETIMSK|=x;
    3b5c:	90 81       	ld	r25, Z
	OCR3BH=OCR3B_DATA>>8;
	OCR3BL=OCR3B_DATA;
	OCR3CH=OCR3C_DATA>>8;
	OCR3CL=OCR3C_DATA;
	
	unsigned char x=(OCIE3C_state<<1)|(TOIE3_state<<2)|(OCIE3B_state<<3)|(OCIE3A_state<<4)|(TICIE3_state<<5);
    3b5e:	49 89       	ldd	r20, Y+17	; 0x11
    3b60:	60 e1       	ldi	r22, 0x10	; 16
    3b62:	46 9f       	mul	r20, r22
    3b64:	a0 01       	movw	r20, r0
    3b66:	11 24       	eor	r1, r1
    3b68:	2a 89       	ldd	r18, Y+18	; 0x12
    3b6a:	60 e2       	ldi	r22, 0x20	; 32
    3b6c:	26 9f       	mul	r18, r22
    3b6e:	90 01       	movw	r18, r0
    3b70:	11 24       	eor	r1, r1
    3b72:	42 2b       	or	r20, r18
    3b74:	28 89       	ldd	r18, Y+16	; 0x10
    3b76:	22 0f       	add	r18, r18
    3b78:	22 0f       	add	r18, r18
    3b7a:	22 0f       	add	r18, r18
    3b7c:	24 2b       	or	r18, r20
    3b7e:	48 2d       	mov	r20, r8
    3b80:	44 0f       	add	r20, r20
    3b82:	44 0f       	add	r20, r20
    3b84:	42 2b       	or	r20, r18
    3b86:	2f 85       	ldd	r18, Y+15	; 0x0f
    3b88:	22 0f       	add	r18, r18
    3b8a:	24 2b       	or	r18, r20
	ETIMSK&=0b00000001;
	ETIMSK|=x;
    3b8c:	29 2b       	or	r18, r25
    3b8e:	20 83       	st	Z, r18
	TCCR3B|=CS3;
    3b90:	9c 91       	ld	r25, X
    3b92:	09 2b       	or	r16, r25
    3b94:	0c 93       	st	X, r16
	if (COM3A!=T3_OCA3_DISCONNECT)
    3b96:	88 23       	and	r24, r24
    3b98:	41 f0       	breq	.+16     	; 0x3baa <TIMER3_ENABLE+0xd8>
	{gpio_outputconfg(DDR_OC3A_ADDRESS,PORT_OUTMOD_OC3A_ADDRESS,OUTPASS,OC3A_PIN);
    3b9a:	23 e0       	ldi	r18, 0x03	; 3
    3b9c:	40 e0       	ldi	r20, 0x00	; 0
    3b9e:	61 e2       	ldi	r22, 0x21	; 33
    3ba0:	70 e0       	ldi	r23, 0x00	; 0
    3ba2:	82 e2       	ldi	r24, 0x22	; 34
    3ba4:	90 e0       	ldi	r25, 0x00	; 0
    3ba6:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
	}
	if (COM3B!=T3_OCB3_DISCONNECT)
    3baa:	99 20       	and	r9, r9
    3bac:	41 f0       	breq	.+16     	; 0x3bbe <TIMER3_ENABLE+0xec>
	{gpio_outputconfg(DDR_OC3B_ADDRESS,PORT_OUTMOD_OC3B_ADDRESS,OUTPASS,OC3B_PIN);
    3bae:	24 e0       	ldi	r18, 0x04	; 4
    3bb0:	40 e0       	ldi	r20, 0x00	; 0
    3bb2:	61 e2       	ldi	r22, 0x21	; 33
    3bb4:	70 e0       	ldi	r23, 0x00	; 0
    3bb6:	82 e2       	ldi	r24, 0x22	; 34
    3bb8:	90 e0       	ldi	r25, 0x00	; 0
    3bba:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
	}
	if (COM3C!=T3_OCC3_DISCONNECT)
    3bbe:	11 23       	and	r17, r17
    3bc0:	41 f0       	breq	.+16     	; 0x3bd2 <TIMER3_ENABLE+0x100>
	{gpio_outputconfg(DDR_OC3C_ADDRESS,PORT_OUTMOD_OC3C_ADDRESS,OUTPASS,OC3C_PIN);
    3bc2:	25 e0       	ldi	r18, 0x05	; 5
    3bc4:	40 e0       	ldi	r20, 0x00	; 0
    3bc6:	61 e2       	ldi	r22, 0x21	; 33
    3bc8:	70 e0       	ldi	r23, 0x00	; 0
    3bca:	82 e2       	ldi	r24, 0x22	; 34
    3bcc:	90 e0       	ldi	r25, 0x00	; 0
    3bce:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
	}
	
}
    3bd2:	df 91       	pop	r29
    3bd4:	cf 91       	pop	r28
    3bd6:	1f 91       	pop	r17
    3bd8:	0f 91       	pop	r16
    3bda:	ff 90       	pop	r15
    3bdc:	ef 90       	pop	r14
    3bde:	df 90       	pop	r13
    3be0:	cf 90       	pop	r12
    3be2:	bf 90       	pop	r11
    3be4:	af 90       	pop	r10
    3be6:	9f 90       	pop	r9
    3be8:	8f 90       	pop	r8
    3bea:	08 95       	ret

00003bec <USART0_SEND_byte>:
	if (USART1_SEND_byte(DATA[i])==0)
	{
		return 0;
	}
	return 1;
}
    3bec:	cf 93       	push	r28
    3bee:	df 93       	push	r29
    3bf0:	00 d0       	rcall	.+0      	; 0x3bf2 <USART0_SEND_byte+0x6>
    3bf2:	00 d0       	rcall	.+0      	; 0x3bf4 <USART0_SEND_byte+0x8>
    3bf4:	cd b7       	in	r28, 0x3d	; 61
    3bf6:	de b7       	in	r29, 0x3e	; 62
    3bf8:	19 82       	std	Y+1, r1	; 0x01
    3bfa:	1a 82       	std	Y+2, r1	; 0x02
    3bfc:	1b 82       	std	Y+3, r1	; 0x03
    3bfe:	1c 82       	std	Y+4, r1	; 0x04
    3c00:	8c b9       	out	0x0c, r24	; 12
    3c02:	15 c0       	rjmp	.+42     	; 0x3c2e <USART0_SEND_byte+0x42>
    3c04:	49 81       	ldd	r20, Y+1	; 0x01
    3c06:	5a 81       	ldd	r21, Y+2	; 0x02
    3c08:	6b 81       	ldd	r22, Y+3	; 0x03
    3c0a:	7c 81       	ldd	r23, Y+4	; 0x04
    3c0c:	4f 5f       	subi	r20, 0xFF	; 255
    3c0e:	5f 4f       	sbci	r21, 0xFF	; 255
    3c10:	6f 4f       	sbci	r22, 0xFF	; 255
    3c12:	7f 4f       	sbci	r23, 0xFF	; 255
    3c14:	49 83       	std	Y+1, r20	; 0x01
    3c16:	5a 83       	std	Y+2, r21	; 0x02
    3c18:	6b 83       	std	Y+3, r22	; 0x03
    3c1a:	7c 83       	std	Y+4, r23	; 0x04
    3c1c:	49 81       	ldd	r20, Y+1	; 0x01
    3c1e:	5a 81       	ldd	r21, Y+2	; 0x02
    3c20:	6b 81       	ldd	r22, Y+3	; 0x03
    3c22:	7c 81       	ldd	r23, Y+4	; 0x04
    3c24:	48 3e       	cpi	r20, 0xE8	; 232
    3c26:	53 40       	sbci	r21, 0x03	; 3
    3c28:	61 05       	cpc	r22, r1
    3c2a:	71 05       	cpc	r23, r1
    3c2c:	31 f0       	breq	.+12     	; 0x3c3a <USART0_SEND_byte+0x4e>
    3c2e:	9b b1       	in	r25, 0x0b	; 11
    3c30:	89 2f       	mov	r24, r25
    3c32:	80 72       	andi	r24, 0x20	; 32
    3c34:	95 ff       	sbrs	r25, 5
    3c36:	e6 cf       	rjmp	.-52     	; 0x3c04 <USART0_SEND_byte+0x18>
    3c38:	81 e0       	ldi	r24, 0x01	; 1
    3c3a:	0f 90       	pop	r0
    3c3c:	0f 90       	pop	r0
    3c3e:	0f 90       	pop	r0
    3c40:	0f 90       	pop	r0
    3c42:	df 91       	pop	r29
    3c44:	cf 91       	pop	r28
    3c46:	08 95       	ret

00003c48 <USART0_INIT>:
    3c48:	5f 92       	push	r5
    3c4a:	6f 92       	push	r6
    3c4c:	7f 92       	push	r7
    3c4e:	8f 92       	push	r8
    3c50:	9f 92       	push	r9
    3c52:	af 92       	push	r10
    3c54:	bf 92       	push	r11
    3c56:	cf 92       	push	r12
    3c58:	df 92       	push	r13
    3c5a:	ef 92       	push	r14
    3c5c:	ff 92       	push	r15
    3c5e:	0f 93       	push	r16
    3c60:	1f 93       	push	r17
    3c62:	cf 93       	push	r28
    3c64:	df 93       	push	r29
    3c66:	cd b7       	in	r28, 0x3d	; 61
    3c68:	de b7       	in	r29, 0x3e	; 62
    3c6a:	3c 01       	movw	r6, r24
    3c6c:	f6 2e       	mov	r15, r22
    3c6e:	14 2f       	mov	r17, r20
    3c70:	52 2e       	mov	r5, r18
    3c72:	21 e0       	ldi	r18, 0x01	; 1
    3c74:	40 e0       	ldi	r20, 0x00	; 0
    3c76:	61 e2       	ldi	r22, 0x21	; 33
    3c78:	70 e0       	ldi	r23, 0x00	; 0
    3c7a:	82 e2       	ldi	r24, 0x22	; 34
    3c7c:	90 e0       	ldi	r25, 0x00	; 0
    3c7e:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
    3c82:	20 e0       	ldi	r18, 0x00	; 0
    3c84:	40 e0       	ldi	r20, 0x00	; 0
    3c86:	63 e2       	ldi	r22, 0x23	; 35
    3c88:	70 e0       	ldi	r23, 0x00	; 0
    3c8a:	82 e2       	ldi	r24, 0x22	; 34
    3c8c:	90 e0       	ldi	r25, 0x00	; 0
    3c8e:	0e 94 55 08 	call	0x10aa	; 0x10aa <gpio_inputconfg>
    3c92:	1a b8       	out	0x0a, r1	; 10
    3c94:	8e 2d       	mov	r24, r14
    3c96:	8c 29       	or	r24, r12
    3c98:	80 68       	ori	r24, 0x80	; 128
    3c9a:	e8 2e       	mov	r14, r24
    3c9c:	e6 28       	or	r14, r6
    3c9e:	e0 92 95 00 	sts	0x0095, r14
    3ca2:	8a b1       	in	r24, 0x0a	; 10
    3ca4:	d8 2a       	or	r13, r24
    3ca6:	80 e2       	ldi	r24, 0x20	; 32
    3ca8:	58 9e       	mul	r5, r24
    3caa:	90 01       	movw	r18, r0
    3cac:	11 24       	eor	r1, r1
    3cae:	02 2b       	or	r16, r18
    3cb0:	80 e4       	ldi	r24, 0x40	; 64
    3cb2:	f8 9e       	mul	r15, r24
    3cb4:	90 01       	movw	r18, r0
    3cb6:	11 24       	eor	r1, r1
    3cb8:	20 2b       	or	r18, r16
    3cba:	30 e8       	ldi	r19, 0x80	; 128
    3cbc:	13 9f       	mul	r17, r19
    3cbe:	c0 01       	movw	r24, r0
    3cc0:	11 24       	eor	r1, r1
    3cc2:	82 2b       	or	r24, r18
    3cc4:	8d 29       	or	r24, r13
    3cc6:	8a b9       	out	0x0a, r24	; 10
    3cc8:	8b b1       	in	r24, 0x0b	; 11
    3cca:	87 29       	or	r24, r7
    3ccc:	8b b9       	out	0x0b, r24	; 11
    3cce:	82 e4       	ldi	r24, 0x42	; 66
    3cd0:	68 16       	cp	r6, r24
    3cd2:	71 04       	cpc	r7, r1
    3cd4:	38 f4       	brcc	.+14     	; 0x3ce4 <USART0_INIT+0x9c>
    3cd6:	30 e4       	ldi	r19, 0x40	; 64
    3cd8:	63 16       	cp	r6, r19
    3cda:	71 04       	cpc	r7, r1
    3cdc:	d0 f5       	brcc	.+116    	; 0x3d52 <USART0_INIT+0x10a>
    3cde:	67 28       	or	r6, r7
    3ce0:	31 f0       	breq	.+12     	; 0x3cee <USART0_INIT+0xa6>
    3ce2:	51 c0       	rjmp	.+162    	; 0x3d86 <USART0_INIT+0x13e>
    3ce4:	61 14       	cp	r6, r1
    3ce6:	82 e0       	ldi	r24, 0x02	; 2
    3ce8:	78 06       	cpc	r7, r24
    3cea:	e1 f0       	breq	.+56     	; 0x3d24 <USART0_INIT+0xdc>
    3cec:	4c c0       	rjmp	.+152    	; 0x3d86 <USART0_INIT+0x13e>
    3cee:	88 0c       	add	r8, r8
    3cf0:	99 1c       	adc	r9, r9
    3cf2:	aa 1c       	adc	r10, r10
    3cf4:	bb 1c       	adc	r11, r11
    3cf6:	88 0c       	add	r8, r8
    3cf8:	99 1c       	adc	r9, r9
    3cfa:	aa 1c       	adc	r10, r10
    3cfc:	bb 1c       	adc	r11, r11
    3cfe:	a5 01       	movw	r20, r10
    3d00:	94 01       	movw	r18, r8
    3d02:	22 0f       	add	r18, r18
    3d04:	33 1f       	adc	r19, r19
    3d06:	44 1f       	adc	r20, r20
    3d08:	55 1f       	adc	r21, r21
    3d0a:	22 0f       	add	r18, r18
    3d0c:	33 1f       	adc	r19, r19
    3d0e:	44 1f       	adc	r20, r20
    3d10:	55 1f       	adc	r21, r21
    3d12:	60 e0       	ldi	r22, 0x00	; 0
    3d14:	74 e2       	ldi	r23, 0x24	; 36
    3d16:	84 ef       	ldi	r24, 0xF4	; 244
    3d18:	90 e0       	ldi	r25, 0x00	; 0
    3d1a:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
    3d1e:	21 50       	subi	r18, 0x01	; 1
    3d20:	31 09       	sbc	r19, r1
    3d22:	33 c0       	rjmp	.+102    	; 0x3d8a <USART0_INIT+0x142>
    3d24:	88 0c       	add	r8, r8
    3d26:	99 1c       	adc	r9, r9
    3d28:	aa 1c       	adc	r10, r10
    3d2a:	bb 1c       	adc	r11, r11
    3d2c:	88 0c       	add	r8, r8
    3d2e:	99 1c       	adc	r9, r9
    3d30:	aa 1c       	adc	r10, r10
    3d32:	bb 1c       	adc	r11, r11
    3d34:	a5 01       	movw	r20, r10
    3d36:	94 01       	movw	r18, r8
    3d38:	22 0f       	add	r18, r18
    3d3a:	33 1f       	adc	r19, r19
    3d3c:	44 1f       	adc	r20, r20
    3d3e:	55 1f       	adc	r21, r21
    3d40:	60 e0       	ldi	r22, 0x00	; 0
    3d42:	74 e2       	ldi	r23, 0x24	; 36
    3d44:	84 ef       	ldi	r24, 0xF4	; 244
    3d46:	90 e0       	ldi	r25, 0x00	; 0
    3d48:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
    3d4c:	21 50       	subi	r18, 0x01	; 1
    3d4e:	31 09       	sbc	r19, r1
    3d50:	1c c0       	rjmp	.+56     	; 0x3d8a <USART0_INIT+0x142>
    3d52:	c5 01       	movw	r24, r10
    3d54:	b4 01       	movw	r22, r8
    3d56:	0e 94 7c 41 	call	0x82f8	; 0x82f8 <__floatunsisf>
    3d5a:	9b 01       	movw	r18, r22
    3d5c:	ac 01       	movw	r20, r24
    3d5e:	0e 94 84 40 	call	0x8108	; 0x8108 <__addsf3>
    3d62:	9b 01       	movw	r18, r22
    3d64:	ac 01       	movw	r20, r24
    3d66:	60 e0       	ldi	r22, 0x00	; 0
    3d68:	74 e2       	ldi	r23, 0x24	; 36
    3d6a:	84 e7       	ldi	r24, 0x74	; 116
    3d6c:	9b e4       	ldi	r25, 0x4B	; 75
    3d6e:	0e 94 e8 40 	call	0x81d0	; 0x81d0 <__divsf3>
    3d72:	20 e0       	ldi	r18, 0x00	; 0
    3d74:	30 e0       	ldi	r19, 0x00	; 0
    3d76:	40 e8       	ldi	r20, 0x80	; 128
    3d78:	5f e3       	ldi	r21, 0x3F	; 63
    3d7a:	0e 94 83 40 	call	0x8106	; 0x8106 <__subsf3>
    3d7e:	0e 94 50 41 	call	0x82a0	; 0x82a0 <__fixunssfsi>
    3d82:	9b 01       	movw	r18, r22
    3d84:	02 c0       	rjmp	.+4      	; 0x3d8a <USART0_INIT+0x142>
    3d86:	20 e0       	ldi	r18, 0x00	; 0
    3d88:	30 e0       	ldi	r19, 0x00	; 0
    3d8a:	29 b9       	out	0x09, r18	; 9
    3d8c:	83 2f       	mov	r24, r19
    3d8e:	8f 70       	andi	r24, 0x0F	; 15
    3d90:	80 93 90 00 	sts	0x0090, r24
    3d94:	df 91       	pop	r29
    3d96:	cf 91       	pop	r28
    3d98:	1f 91       	pop	r17
    3d9a:	0f 91       	pop	r16
    3d9c:	ff 90       	pop	r15
    3d9e:	ef 90       	pop	r14
    3da0:	df 90       	pop	r13
    3da2:	cf 90       	pop	r12
    3da4:	bf 90       	pop	r11
    3da6:	af 90       	pop	r10
    3da8:	9f 90       	pop	r9
    3daa:	8f 90       	pop	r8
    3dac:	7f 90       	pop	r7
    3dae:	6f 90       	pop	r6
    3db0:	5f 90       	pop	r5
    3db2:	08 95       	ret

00003db4 <USART1_INIT>:
    3db4:	5f 92       	push	r5
    3db6:	6f 92       	push	r6
    3db8:	7f 92       	push	r7
    3dba:	8f 92       	push	r8
    3dbc:	9f 92       	push	r9
    3dbe:	af 92       	push	r10
    3dc0:	bf 92       	push	r11
    3dc2:	cf 92       	push	r12
    3dc4:	df 92       	push	r13
    3dc6:	ef 92       	push	r14
    3dc8:	ff 92       	push	r15
    3dca:	0f 93       	push	r16
    3dcc:	1f 93       	push	r17
    3dce:	cf 93       	push	r28
    3dd0:	df 93       	push	r29
    3dd2:	cd b7       	in	r28, 0x3d	; 61
    3dd4:	de b7       	in	r29, 0x3e	; 62
    3dd6:	3c 01       	movw	r6, r24
    3dd8:	f6 2e       	mov	r15, r22
    3dda:	14 2f       	mov	r17, r20
    3ddc:	52 2e       	mov	r5, r18
    3dde:	23 e0       	ldi	r18, 0x03	; 3
    3de0:	40 e0       	ldi	r20, 0x00	; 0
    3de2:	60 e3       	ldi	r22, 0x30	; 48
    3de4:	70 e0       	ldi	r23, 0x00	; 0
    3de6:	81 e3       	ldi	r24, 0x31	; 49
    3de8:	90 e0       	ldi	r25, 0x00	; 0
    3dea:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
    3dee:	22 e0       	ldi	r18, 0x02	; 2
    3df0:	40 e0       	ldi	r20, 0x00	; 0
    3df2:	62 e3       	ldi	r22, 0x32	; 50
    3df4:	70 e0       	ldi	r23, 0x00	; 0
    3df6:	81 e3       	ldi	r24, 0x31	; 49
    3df8:	90 e0       	ldi	r25, 0x00	; 0
    3dfa:	0e 94 55 08 	call	0x10aa	; 0x10aa <gpio_inputconfg>
    3dfe:	ea e9       	ldi	r30, 0x9A	; 154
    3e00:	f0 e0       	ldi	r31, 0x00	; 0
    3e02:	10 82       	st	Z, r1
    3e04:	8e 2d       	mov	r24, r14
    3e06:	8c 29       	or	r24, r12
    3e08:	80 68       	ori	r24, 0x80	; 128
    3e0a:	e8 2e       	mov	r14, r24
    3e0c:	e6 28       	or	r14, r6
    3e0e:	e0 92 9d 00 	sts	0x009D, r14
    3e12:	80 81       	ld	r24, Z
    3e14:	d8 2a       	or	r13, r24
    3e16:	80 e2       	ldi	r24, 0x20	; 32
    3e18:	58 9e       	mul	r5, r24
    3e1a:	90 01       	movw	r18, r0
    3e1c:	11 24       	eor	r1, r1
    3e1e:	02 2b       	or	r16, r18
    3e20:	80 e4       	ldi	r24, 0x40	; 64
    3e22:	f8 9e       	mul	r15, r24
    3e24:	90 01       	movw	r18, r0
    3e26:	11 24       	eor	r1, r1
    3e28:	20 2b       	or	r18, r16
    3e2a:	30 e8       	ldi	r19, 0x80	; 128
    3e2c:	13 9f       	mul	r17, r19
    3e2e:	c0 01       	movw	r24, r0
    3e30:	11 24       	eor	r1, r1
    3e32:	82 2b       	or	r24, r18
    3e34:	8d 29       	or	r24, r13
    3e36:	80 83       	st	Z, r24
    3e38:	eb e9       	ldi	r30, 0x9B	; 155
    3e3a:	f0 e0       	ldi	r31, 0x00	; 0
    3e3c:	80 81       	ld	r24, Z
    3e3e:	87 29       	or	r24, r7
    3e40:	80 83       	st	Z, r24
    3e42:	82 e4       	ldi	r24, 0x42	; 66
    3e44:	68 16       	cp	r6, r24
    3e46:	71 04       	cpc	r7, r1
    3e48:	38 f4       	brcc	.+14     	; 0x3e58 <USART1_INIT+0xa4>
    3e4a:	30 e4       	ldi	r19, 0x40	; 64
    3e4c:	63 16       	cp	r6, r19
    3e4e:	71 04       	cpc	r7, r1
    3e50:	d0 f5       	brcc	.+116    	; 0x3ec6 <USART1_INIT+0x112>
    3e52:	67 28       	or	r6, r7
    3e54:	31 f0       	breq	.+12     	; 0x3e62 <USART1_INIT+0xae>
    3e56:	51 c0       	rjmp	.+162    	; 0x3efa <USART1_INIT+0x146>
    3e58:	61 14       	cp	r6, r1
    3e5a:	82 e0       	ldi	r24, 0x02	; 2
    3e5c:	78 06       	cpc	r7, r24
    3e5e:	e1 f0       	breq	.+56     	; 0x3e98 <USART1_INIT+0xe4>
    3e60:	4c c0       	rjmp	.+152    	; 0x3efa <USART1_INIT+0x146>
    3e62:	88 0c       	add	r8, r8
    3e64:	99 1c       	adc	r9, r9
    3e66:	aa 1c       	adc	r10, r10
    3e68:	bb 1c       	adc	r11, r11
    3e6a:	88 0c       	add	r8, r8
    3e6c:	99 1c       	adc	r9, r9
    3e6e:	aa 1c       	adc	r10, r10
    3e70:	bb 1c       	adc	r11, r11
    3e72:	a5 01       	movw	r20, r10
    3e74:	94 01       	movw	r18, r8
    3e76:	22 0f       	add	r18, r18
    3e78:	33 1f       	adc	r19, r19
    3e7a:	44 1f       	adc	r20, r20
    3e7c:	55 1f       	adc	r21, r21
    3e7e:	22 0f       	add	r18, r18
    3e80:	33 1f       	adc	r19, r19
    3e82:	44 1f       	adc	r20, r20
    3e84:	55 1f       	adc	r21, r21
    3e86:	60 e0       	ldi	r22, 0x00	; 0
    3e88:	74 e2       	ldi	r23, 0x24	; 36
    3e8a:	84 ef       	ldi	r24, 0xF4	; 244
    3e8c:	90 e0       	ldi	r25, 0x00	; 0
    3e8e:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
    3e92:	21 50       	subi	r18, 0x01	; 1
    3e94:	31 09       	sbc	r19, r1
    3e96:	33 c0       	rjmp	.+102    	; 0x3efe <USART1_INIT+0x14a>
    3e98:	88 0c       	add	r8, r8
    3e9a:	99 1c       	adc	r9, r9
    3e9c:	aa 1c       	adc	r10, r10
    3e9e:	bb 1c       	adc	r11, r11
    3ea0:	88 0c       	add	r8, r8
    3ea2:	99 1c       	adc	r9, r9
    3ea4:	aa 1c       	adc	r10, r10
    3ea6:	bb 1c       	adc	r11, r11
    3ea8:	a5 01       	movw	r20, r10
    3eaa:	94 01       	movw	r18, r8
    3eac:	22 0f       	add	r18, r18
    3eae:	33 1f       	adc	r19, r19
    3eb0:	44 1f       	adc	r20, r20
    3eb2:	55 1f       	adc	r21, r21
    3eb4:	60 e0       	ldi	r22, 0x00	; 0
    3eb6:	74 e2       	ldi	r23, 0x24	; 36
    3eb8:	84 ef       	ldi	r24, 0xF4	; 244
    3eba:	90 e0       	ldi	r25, 0x00	; 0
    3ebc:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
    3ec0:	21 50       	subi	r18, 0x01	; 1
    3ec2:	31 09       	sbc	r19, r1
    3ec4:	1c c0       	rjmp	.+56     	; 0x3efe <USART1_INIT+0x14a>
    3ec6:	c5 01       	movw	r24, r10
    3ec8:	b4 01       	movw	r22, r8
    3eca:	0e 94 7c 41 	call	0x82f8	; 0x82f8 <__floatunsisf>
    3ece:	9b 01       	movw	r18, r22
    3ed0:	ac 01       	movw	r20, r24
    3ed2:	0e 94 84 40 	call	0x8108	; 0x8108 <__addsf3>
    3ed6:	9b 01       	movw	r18, r22
    3ed8:	ac 01       	movw	r20, r24
    3eda:	60 e0       	ldi	r22, 0x00	; 0
    3edc:	74 e2       	ldi	r23, 0x24	; 36
    3ede:	84 e7       	ldi	r24, 0x74	; 116
    3ee0:	9b e4       	ldi	r25, 0x4B	; 75
    3ee2:	0e 94 e8 40 	call	0x81d0	; 0x81d0 <__divsf3>
    3ee6:	20 e0       	ldi	r18, 0x00	; 0
    3ee8:	30 e0       	ldi	r19, 0x00	; 0
    3eea:	40 e8       	ldi	r20, 0x80	; 128
    3eec:	5f e3       	ldi	r21, 0x3F	; 63
    3eee:	0e 94 83 40 	call	0x8106	; 0x8106 <__subsf3>
    3ef2:	0e 94 50 41 	call	0x82a0	; 0x82a0 <__fixunssfsi>
    3ef6:	9b 01       	movw	r18, r22
    3ef8:	02 c0       	rjmp	.+4      	; 0x3efe <USART1_INIT+0x14a>
    3efa:	20 e0       	ldi	r18, 0x00	; 0
    3efc:	30 e0       	ldi	r19, 0x00	; 0
    3efe:	20 93 99 00 	sts	0x0099, r18
    3f02:	83 2f       	mov	r24, r19
    3f04:	8f 70       	andi	r24, 0x0F	; 15
    3f06:	80 93 98 00 	sts	0x0098, r24
    3f0a:	df 91       	pop	r29
    3f0c:	cf 91       	pop	r28
    3f0e:	1f 91       	pop	r17
    3f10:	0f 91       	pop	r16
    3f12:	ff 90       	pop	r15
    3f14:	ef 90       	pop	r14
    3f16:	df 90       	pop	r13
    3f18:	cf 90       	pop	r12
    3f1a:	bf 90       	pop	r11
    3f1c:	af 90       	pop	r10
    3f1e:	9f 90       	pop	r9
    3f20:	8f 90       	pop	r8
    3f22:	7f 90       	pop	r7
    3f24:	6f 90       	pop	r6
    3f26:	5f 90       	pop	r5
    3f28:	08 95       	ret

00003f2a <USART0_SEND_str>:
    3f2a:	0f 93       	push	r16
    3f2c:	1f 93       	push	r17
    3f2e:	cf 93       	push	r28
    3f30:	df 93       	push	r29
    3f32:	00 d0       	rcall	.+0      	; 0x3f34 <USART0_SEND_str+0xa>
    3f34:	cd b7       	in	r28, 0x3d	; 61
    3f36:	de b7       	in	r29, 0x3e	; 62
    3f38:	8c 01       	movw	r16, r24
    3f3a:	1a 82       	std	Y+2, r1	; 0x02
    3f3c:	19 82       	std	Y+1, r1	; 0x01
    3f3e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f40:	fa 81       	ldd	r31, Y+2	; 0x02
    3f42:	e8 0f       	add	r30, r24
    3f44:	f9 1f       	adc	r31, r25
    3f46:	80 81       	ld	r24, Z
    3f48:	88 23       	and	r24, r24
    3f4a:	a9 f0       	breq	.+42     	; 0x3f76 <USART0_SEND_str+0x4c>
    3f4c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f4e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f50:	e0 0f       	add	r30, r16
    3f52:	f1 1f       	adc	r31, r17
    3f54:	80 81       	ld	r24, Z
    3f56:	4a de       	rcall	.-876    	; 0x3bec <USART0_SEND_byte>
    3f58:	98 2f       	mov	r25, r24
    3f5a:	88 23       	and	r24, r24
    3f5c:	e1 f0       	breq	.+56     	; 0x3f96 <USART0_SEND_str+0x6c>
    3f5e:	89 81       	ldd	r24, Y+1	; 0x01
    3f60:	9a 81       	ldd	r25, Y+2	; 0x02
    3f62:	01 96       	adiw	r24, 0x01	; 1
    3f64:	9a 83       	std	Y+2, r25	; 0x02
    3f66:	89 83       	std	Y+1, r24	; 0x01
    3f68:	e9 81       	ldd	r30, Y+1	; 0x01
    3f6a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f6c:	e0 0f       	add	r30, r16
    3f6e:	f1 1f       	adc	r31, r17
    3f70:	80 81       	ld	r24, Z
    3f72:	81 11       	cpse	r24, r1
    3f74:	eb cf       	rjmp	.-42     	; 0x3f4c <USART0_SEND_str+0x22>
    3f76:	e9 81       	ldd	r30, Y+1	; 0x01
    3f78:	fa 81       	ldd	r31, Y+2	; 0x02
    3f7a:	e0 0f       	add	r30, r16
    3f7c:	f1 1f       	adc	r31, r17
    3f7e:	10 82       	st	Z, r1
    3f80:	89 81       	ldd	r24, Y+1	; 0x01
    3f82:	9a 81       	ldd	r25, Y+2	; 0x02
    3f84:	f8 01       	movw	r30, r16
    3f86:	e8 0f       	add	r30, r24
    3f88:	f9 1f       	adc	r31, r25
    3f8a:	80 81       	ld	r24, Z
    3f8c:	2f de       	rcall	.-930    	; 0x3bec <USART0_SEND_byte>
    3f8e:	91 e0       	ldi	r25, 0x01	; 1
    3f90:	81 11       	cpse	r24, r1
    3f92:	01 c0       	rjmp	.+2      	; 0x3f96 <USART0_SEND_str+0x6c>
    3f94:	90 e0       	ldi	r25, 0x00	; 0
    3f96:	89 2f       	mov	r24, r25
    3f98:	0f 90       	pop	r0
    3f9a:	0f 90       	pop	r0
    3f9c:	df 91       	pop	r29
    3f9e:	cf 91       	pop	r28
    3fa0:	1f 91       	pop	r17
    3fa2:	0f 91       	pop	r16
    3fa4:	08 95       	ret

00003fa6 <USART0_SEND_ARRAY>:

unsigned char USART0_SEND_ARRAY(unsigned char *DATA,unsigned short N)
{
    3fa6:	0f 93       	push	r16
    3fa8:	1f 93       	push	r17
    3faa:	cf 93       	push	r28
    3fac:	df 93       	push	r29
	unsigned short i=0;
	for(i=0;i<N;i++)
    3fae:	61 15       	cp	r22, r1
    3fb0:	71 05       	cpc	r23, r1
    3fb2:	61 f0       	breq	.+24     	; 0x3fcc <USART0_SEND_ARRAY+0x26>
    3fb4:	ec 01       	movw	r28, r24
    3fb6:	8c 01       	movw	r16, r24
    3fb8:	06 0f       	add	r16, r22
    3fba:	17 1f       	adc	r17, r23
	{
		if(USART0_SEND_byte(DATA[i])!=1)
    3fbc:	89 91       	ld	r24, Y+
    3fbe:	16 de       	rcall	.-980    	; 0x3bec <USART0_SEND_byte>
    3fc0:	81 30       	cpi	r24, 0x01	; 1
    3fc2:	31 f4       	brne	.+12     	; 0x3fd0 <USART0_SEND_ARRAY+0x2a>
}

unsigned char USART0_SEND_ARRAY(unsigned char *DATA,unsigned short N)
{
	unsigned short i=0;
	for(i=0;i<N;i++)
    3fc4:	c0 17       	cp	r28, r16
    3fc6:	d1 07       	cpc	r29, r17
    3fc8:	c9 f7       	brne	.-14     	; 0x3fbc <USART0_SEND_ARRAY+0x16>
    3fca:	03 c0       	rjmp	.+6      	; 0x3fd2 <USART0_SEND_ARRAY+0x2c>
			return 0;
		}
	
	}
	
return 1;
    3fcc:	81 e0       	ldi	r24, 0x01	; 1
    3fce:	01 c0       	rjmp	.+2      	; 0x3fd2 <USART0_SEND_ARRAY+0x2c>
	unsigned short i=0;
	for(i=0;i<N;i++)
	{
		if(USART0_SEND_byte(DATA[i])!=1)
		{
			return 0;
    3fd0:	80 e0       	ldi	r24, 0x00	; 0
		}
	
	}
	
return 1;
}
    3fd2:	df 91       	pop	r29
    3fd4:	cf 91       	pop	r28
    3fd6:	1f 91       	pop	r17
    3fd8:	0f 91       	pop	r16
    3fda:	08 95       	ret

00003fdc <INT0_NRF_ISR>:
SemaphoreHandle_t NRF_IRQ_SEMAPHORE;


void INT0_NRF_ISR()
{
	xSemaphoreGiveFromISR(NRF_IRQ_SEMAPHORE,NULL);
    3fdc:	60 e0       	ldi	r22, 0x00	; 0
    3fde:	70 e0       	ldi	r23, 0x00	; 0
    3fe0:	80 91 de 0c 	lds	r24, 0x0CDE
    3fe4:	90 91 df 0c 	lds	r25, 0x0CDF
    3fe8:	0c 94 88 16 	jmp	0x2d10	; 0x2d10 <xQueueGiveFromISR>
    3fec:	08 95       	ret

00003fee <PROTOCOL_SETUP>:
}

void PROTOCOL_SETUP()
{    NRF_IRQ_SEMAPHORE=xSemaphoreCreateBinary();
    3fee:	43 e0       	ldi	r20, 0x03	; 3
    3ff0:	60 e0       	ldi	r22, 0x00	; 0
    3ff2:	81 e0       	ldi	r24, 0x01	; 1
    3ff4:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <xQueueGenericCreate>
    3ff8:	90 93 df 0c 	sts	0x0CDF, r25
    3ffc:	80 93 de 0c 	sts	0x0CDE, r24
	
	 external_int_enable(INT0_ENABLE,INT_FALLING);
    4000:	62 e0       	ldi	r22, 0x02	; 2
    4002:	81 e0       	ldi	r24, 0x01	; 1
    4004:	5c dc       	rcall	.-1864   	; 0x38be <external_int_enable>
	 NRF_SETUP_USED_CONFIG();
    4006:	0c 94 df 10 	jmp	0x21be	; 0x21be <NRF_SETUP_USED_CONFIG>
    400a:	08 95       	ret

0000400c <PROTOCOL_IO_SETUP>:
}

void PROTOCOL_IO_SETUP()
{
	 NRF_IO_SETUP();
    400c:	0c 94 c6 10 	jmp	0x218c	; 0x218c <NRF_IO_SETUP>
    4010:	08 95       	ret

00004012 <PROTOCOL_CHECK_RECIVED_PACKET>:




unsigned char PROTOCOL_CHECK_RECIVED_PACKET(unsigned char *PACKET, unsigned char *SENSOR_ADDRESS,unsigned char LENGTH,unsigned char*KEY)
{
    4012:	ef 92       	push	r14
    4014:	ff 92       	push	r15
    4016:	0f 93       	push	r16
    4018:	1f 93       	push	r17
    401a:	cf 93       	push	r28
    401c:	df 93       	push	r29
    401e:	00 d0       	rcall	.+0      	; 0x4020 <PROTOCOL_CHECK_RECIVED_PACKET+0xe>
    4020:	cd b7       	in	r28, 0x3d	; 61
    4022:	de b7       	in	r29, 0x3e	; 62
    4024:	8c 01       	movw	r16, r24
	if (LENGTH!=(0b01111111 & PACKET[0]))
    4026:	fc 01       	movw	r30, r24
    4028:	80 81       	ld	r24, Z
    402a:	f8 2f       	mov	r31, r24
    402c:	ff 77       	andi	r31, 0x7F	; 127
    402e:	ef 2e       	mov	r14, r31
    4030:	f4 13       	cpse	r31, r20
    4032:	3c c0       	rjmp	.+120    	; 0x40ac <PROTOCOL_CHECK_RECIVED_PACKET+0x9a>
	{
		return 0;
	}
	if (PACKET[1]>PROTOCOL_CURRENT_VERSION)
    4034:	f8 01       	movw	r30, r16
    4036:	91 81       	ldd	r25, Z+1	; 0x01
    4038:	92 30       	cpi	r25, 0x02	; 2
    403a:	d0 f5       	brcc	.+116    	; 0x40b0 <PROTOCOL_CHECK_RECIVED_PACKET+0x9e>
		return 0;
	}
	unsigned char i;
	for(i=0;i<5;i++)
	{
		if (PACKET[2+i]!=SENSOR_ADDRESS[i])
    403c:	42 81       	ldd	r20, Z+2	; 0x02
    403e:	fb 01       	movw	r30, r22
    4040:	90 81       	ld	r25, Z
    4042:	49 13       	cpse	r20, r25
    4044:	37 c0       	rjmp	.+110    	; 0x40b4 <PROTOCOL_CHECK_RECIVED_PACKET+0xa2>
    4046:	d8 01       	movw	r26, r16
    4048:	13 96       	adiw	r26, 0x03	; 3
    404a:	31 96       	adiw	r30, 0x01	; 1
    404c:	68 94       	set
    404e:	ff 24       	eor	r15, r15
    4050:	f2 f8       	bld	r15, 2
    4052:	4d 91       	ld	r20, X+
    4054:	91 91       	ld	r25, Z+
    4056:	49 13       	cpse	r20, r25
    4058:	2f c0       	rjmp	.+94     	; 0x40b8 <PROTOCOL_CHECK_RECIVED_PACKET+0xa6>
    405a:	fa 94       	dec	r15
	if (PACKET[1]>PROTOCOL_CURRENT_VERSION)
	{
		return 0;
	}
	unsigned char i;
	for(i=0;i<5;i++)
    405c:	d1 f7       	brne	.-12     	; 0x4052 <PROTOCOL_CHECK_RECIVED_PACKET+0x40>
	}
	
	
	
	unsigned char HASH_VALUE[2];
	if (0b10000000&PACKET[0])
    405e:	88 23       	and	r24, r24
    4060:	44 f4       	brge	.+16     	; 0x4072 <PROTOCOL_CHECK_RECIVED_PACKET+0x60>
	{
		HASH_PASWORD_KEY(PACKET,HASH_VALUE,LENGTH-2,KEY);
    4062:	4e ef       	ldi	r20, 0xFE	; 254
    4064:	4e 0d       	add	r20, r14
    4066:	be 01       	movw	r22, r28
    4068:	6f 5f       	subi	r22, 0xFF	; 255
    406a:	7f 4f       	sbci	r23, 0xFF	; 255
    406c:	c8 01       	movw	r24, r16
    406e:	f8 d5       	rcall	.+3056   	; 0x4c60 <HASH_PASWORD_KEY>
    4070:	07 c0       	rjmp	.+14     	; 0x4080 <PROTOCOL_CHECK_RECIVED_PACKET+0x6e>
	}
	else
	{
		HASH_SESSION_KEY(PACKET,HASH_VALUE,LENGTH-2,KEY);
    4072:	4e ef       	ldi	r20, 0xFE	; 254
    4074:	4e 0d       	add	r20, r14
    4076:	be 01       	movw	r22, r28
    4078:	6f 5f       	subi	r22, 0xFF	; 255
    407a:	7f 4f       	sbci	r23, 0xFF	; 255
    407c:	c8 01       	movw	r24, r16
    407e:	61 d5       	rcall	.+2754   	; 0x4b42 <HASH_SESSION_KEY>
	}
	if ((HASH_VALUE[0]==PACKET[LENGTH-2])&&(HASH_VALUE[1]==PACKET[LENGTH-1]))
    4080:	2e 2d       	mov	r18, r14
    4082:	30 e0       	ldi	r19, 0x00	; 0
    4084:	f8 01       	movw	r30, r16
    4086:	e2 0f       	add	r30, r18
    4088:	f3 1f       	adc	r31, r19
    408a:	32 97       	sbiw	r30, 0x02	; 2
    408c:	99 81       	ldd	r25, Y+1	; 0x01
    408e:	80 81       	ld	r24, Z
    4090:	98 13       	cpse	r25, r24
    4092:	13 c0       	rjmp	.+38     	; 0x40ba <PROTOCOL_CHECK_RECIVED_PACKET+0xa8>
    4094:	02 0f       	add	r16, r18
    4096:	13 1f       	adc	r17, r19
    4098:	f8 01       	movw	r30, r16
    409a:	31 97       	sbiw	r30, 0x01	; 1
    409c:	ff 24       	eor	r15, r15
    409e:	f3 94       	inc	r15
    40a0:	9a 81       	ldd	r25, Y+2	; 0x02
    40a2:	80 81       	ld	r24, Z
    40a4:	98 17       	cp	r25, r24
    40a6:	49 f0       	breq	.+18     	; 0x40ba <PROTOCOL_CHECK_RECIVED_PACKET+0xa8>
    40a8:	f1 2c       	mov	r15, r1
    40aa:	07 c0       	rjmp	.+14     	; 0x40ba <PROTOCOL_CHECK_RECIVED_PACKET+0xa8>

unsigned char PROTOCOL_CHECK_RECIVED_PACKET(unsigned char *PACKET, unsigned char *SENSOR_ADDRESS,unsigned char LENGTH,unsigned char*KEY)
{
	if (LENGTH!=(0b01111111 & PACKET[0]))
	{
		return 0;
    40ac:	f1 2c       	mov	r15, r1
    40ae:	05 c0       	rjmp	.+10     	; 0x40ba <PROTOCOL_CHECK_RECIVED_PACKET+0xa8>
	}
	if (PACKET[1]>PROTOCOL_CURRENT_VERSION)
	{
		return 0;
    40b0:	f1 2c       	mov	r15, r1
    40b2:	03 c0       	rjmp	.+6      	; 0x40ba <PROTOCOL_CHECK_RECIVED_PACKET+0xa8>
	unsigned char i;
	for(i=0;i<5;i++)
	{
		if (PACKET[2+i]!=SENSOR_ADDRESS[i])
		{
			return 0;
    40b4:	f1 2c       	mov	r15, r1
    40b6:	01 c0       	rjmp	.+2      	; 0x40ba <PROTOCOL_CHECK_RECIVED_PACKET+0xa8>
    40b8:	f1 2c       	mov	r15, r1
	{
		return 1;
	}
	return 0;
	
}
    40ba:	8f 2d       	mov	r24, r15
    40bc:	0f 90       	pop	r0
    40be:	0f 90       	pop	r0
    40c0:	df 91       	pop	r29
    40c2:	cf 91       	pop	r28
    40c4:	1f 91       	pop	r17
    40c6:	0f 91       	pop	r16
    40c8:	ff 90       	pop	r15
    40ca:	ef 90       	pop	r14
    40cc:	08 95       	ret

000040ce <PROTOCOL_MASTER_CONNECT_TO_SENSOR>:
{
	 NRF_IO_SETUP();
}

unsigned char PROTOCOL_MASTER_CONNECT_TO_SENSOR(unsigned char*SENSOR_ADDRESS,unsigned char SENSOR_VERSION,unsigned char SENSOR_ADDRESS_LENGTH,unsigned char*PASSWORD_KEY)
{
    40ce:	6f 92       	push	r6
    40d0:	7f 92       	push	r7
    40d2:	8f 92       	push	r8
    40d4:	9f 92       	push	r9
    40d6:	af 92       	push	r10
    40d8:	bf 92       	push	r11
    40da:	cf 92       	push	r12
    40dc:	df 92       	push	r13
    40de:	ef 92       	push	r14
    40e0:	ff 92       	push	r15
    40e2:	0f 93       	push	r16
    40e4:	1f 93       	push	r17
    40e6:	cf 93       	push	r28
    40e8:	df 93       	push	r29
    40ea:	cd b7       	in	r28, 0x3d	; 61
    40ec:	de b7       	in	r29, 0x3e	; 62
    40ee:	68 97       	sbiw	r28, 0x18	; 24
    40f0:	0f b6       	in	r0, 0x3f	; 63
    40f2:	f8 94       	cli
    40f4:	de bf       	out	0x3e, r29	; 62
    40f6:	0f be       	out	0x3f, r0	; 63
    40f8:	cd bf       	out	0x3d, r28	; 61
    40fa:	7c 01       	movw	r14, r24
    40fc:	96 2e       	mov	r9, r22
    40fe:	b4 2e       	mov	r11, r20
    4100:	89 01       	movw	r16, r18
	unsigned char PACKET_TEMP[12];
	unsigned char i,RX_LENGTH;
	unsigned char HASH_VALUE[2];
	volatile unsigned long COUNT_TIMER=0;
    4102:	18 8a       	std	Y+16, r1	; 0x10
    4104:	19 8a       	std	Y+17, r1	; 0x11
    4106:	1a 8a       	std	Y+18, r1	; 0x12
    4108:	1b 8a       	std	Y+19, r1	; 0x13
	
	
	
	/*********SEND MASTER NEEDS TO CONNECT**********/
	PACKET_TEMP[0]=10|0B10000000;
    410a:	8a e8       	ldi	r24, 0x8A	; 138
    410c:	89 83       	std	Y+1, r24	; 0x01
	PACKET_TEMP[1]=SENSOR_VERSION;
    410e:	6a 83       	std	Y+2, r22	; 0x02
    4110:	0f 2e       	mov	r0, r31
    4112:	fa e0       	ldi	r31, 0x0A	; 10
    4114:	cf 2e       	mov	r12, r31
    4116:	f1 e0       	ldi	r31, 0x01	; 1
    4118:	df 2e       	mov	r13, r31
    411a:	f0 2d       	mov	r31, r0
    411c:	8f e0       	ldi	r24, 0x0F	; 15
    411e:	91 e0       	ldi	r25, 0x01	; 1
    4120:	de 01       	movw	r26, r28
    4122:	13 96       	adiw	r26, 0x03	; 3
    4124:	f6 01       	movw	r30, r12
	for (i=0;i<5;i++)
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
    4126:	21 91       	ld	r18, Z+
    4128:	2d 93       	st	X+, r18
	
	
	/*********SEND MASTER NEEDS TO CONNECT**********/
	PACKET_TEMP[0]=10|0B10000000;
	PACKET_TEMP[1]=SENSOR_VERSION;
	for (i=0;i<5;i++)
    412a:	e8 17       	cp	r30, r24
    412c:	f9 07       	cpc	r31, r25
    412e:	d9 f7       	brne	.-10     	; 0x4126 <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x58>
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
	}
	PACKET_TEMP[7]=MASTER_REQUEST_CONNECT_CODE;
    4130:	81 e0       	ldi	r24, 0x01	; 1
    4132:	88 87       	std	Y+8, r24	; 0x08
	HASH_PASWORD_KEY(PACKET_TEMP,HASH_VALUE,8,PASSWORD_KEY);
    4134:	98 01       	movw	r18, r16
    4136:	48 e0       	ldi	r20, 0x08	; 8
    4138:	be 01       	movw	r22, r28
    413a:	62 5f       	subi	r22, 0xF2	; 242
    413c:	7f 4f       	sbci	r23, 0xFF	; 255
    413e:	ce 01       	movw	r24, r28
    4140:	01 96       	adiw	r24, 0x01	; 1
    4142:	8e d5       	rcall	.+2844   	; 0x4c60 <HASH_PASWORD_KEY>
	PACKET_TEMP[8]=HASH_VALUE[0];
    4144:	8e 85       	ldd	r24, Y+14	; 0x0e
    4146:	89 87       	std	Y+9, r24	; 0x09
	PACKET_TEMP[9]=HASH_VALUE[1];
    4148:	8f 85       	ldd	r24, Y+15	; 0x0f
    414a:	8a 87       	std	Y+10, r24	; 0x0a
	if (!NRF_SEND_DATA_WITH_ACK(SENSOR_ADDRESS,SENSOR_ADDRESS_LENGTH,PACKET_TEMP,10))
    414c:	2a e0       	ldi	r18, 0x0A	; 10
    414e:	ae 01       	movw	r20, r28
    4150:	4f 5f       	subi	r20, 0xFF	; 255
    4152:	5f 4f       	sbci	r21, 0xFF	; 255
    4154:	6b 2d       	mov	r22, r11
    4156:	c7 01       	movw	r24, r14
    4158:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <NRF_SEND_DATA_WITH_ACK>
    415c:	a8 2e       	mov	r10, r24
    415e:	81 11       	cpse	r24, r1
    4160:	05 c0       	rjmp	.+10     	; 0x416c <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x9e>
	{
		TEST_UART_SEND_str("FIRST FAIL\n");
    4162:	8f e7       	ldi	r24, 0x7F	; 127
    4164:	92 e0       	ldi	r25, 0x02	; 2
    4166:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
		return 0;
    416a:	c9 c0       	rjmp	.+402    	; 0x42fe <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x230>
	}
	/*****************************************************************************************/
	
	
	/******************************RECIVE SENSOR CHALLANGE*******************************************/
	NRF_START_RX_MODE();
    416c:	0e 94 ad 11 	call	0x235a	; 0x235a <NRF_START_RX_MODE>
	TEST_UART_SEND_str("FIRST PASS\n");
    4170:	8b e8       	ldi	r24, 0x8B	; 139
    4172:	92 e0       	ldi	r25, 0x02	; 2
    4174:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	
	if(pdPASS!=xSemaphoreTake(NRF_IRQ_SEMAPHORE,pdMS_TO_TICKS(3000)))
    4178:	4c e2       	ldi	r20, 0x2C	; 44
    417a:	51 e0       	ldi	r21, 0x01	; 1
    417c:	60 e0       	ldi	r22, 0x00	; 0
    417e:	70 e0       	ldi	r23, 0x00	; 0
    4180:	80 91 de 0c 	lds	r24, 0x0CDE
    4184:	90 91 df 0c 	lds	r25, 0x0CDF
    4188:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    418c:	81 30       	cpi	r24, 0x01	; 1
    418e:	41 f0       	breq	.+16     	; 0x41a0 <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0xd2>
	{
		TEST_UART_SEND_str("FAIL 2\n");
    4190:	87 e9       	ldi	r24, 0x97	; 151
    4192:	92 e0       	ldi	r25, 0x02	; 2
    4194:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
		NRF_STOP_RX_MODE();
    4198:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
		return 0;
    419c:	a1 2c       	mov	r10, r1
    419e:	af c0       	rjmp	.+350    	; 0x42fe <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x230>
	}
	
	NRF_CHECK_RX_PL(PACKET_TEMP,&RX_LENGTH);
    41a0:	be 01       	movw	r22, r28
    41a2:	63 5f       	subi	r22, 0xF3	; 243
    41a4:	7f 4f       	sbci	r23, 0xFF	; 255
    41a6:	ce 01       	movw	r24, r28
    41a8:	01 96       	adiw	r24, 0x01	; 1
    41aa:	0e 94 c5 11 	call	0x238a	; 0x238a <NRF_CHECK_RX_PL>
	
	
	NRF_STOP_RX_MODE();
    41ae:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
	
	if (!PROTOCOL_CHECK_RECIVED_PACKET(PACKET_TEMP, SENSOR_ADDRESS,RX_LENGTH,PASSWORD_KEY))
    41b2:	98 01       	movw	r18, r16
    41b4:	4d 85       	ldd	r20, Y+13	; 0x0d
    41b6:	b7 01       	movw	r22, r14
    41b8:	ce 01       	movw	r24, r28
    41ba:	01 96       	adiw	r24, 0x01	; 1
    41bc:	2a df       	rcall	.-428    	; 0x4012 <PROTOCOL_CHECK_RECIVED_PACKET>
    41be:	a8 2e       	mov	r10, r24
    41c0:	88 23       	and	r24, r24
    41c2:	09 f4       	brne	.+2      	; 0x41c6 <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0xf8>
    41c4:	9c c0       	rjmp	.+312    	; 0x42fe <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x230>
	{
		return 0;
	}
	if(PACKET_TEMP[7]!=SENSOR_CHALLENGE_CODE)
    41c6:	88 85       	ldd	r24, Y+8	; 0x08
    41c8:	82 30       	cpi	r24, 0x02	; 2
    41ca:	09 f0       	breq	.+2      	; 0x41ce <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x100>
    41cc:	93 c0       	rjmp	.+294    	; 0x42f4 <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x226>
	
	/**************************************************************************************************/
	
	/****************************************SEND THE ENCRYPTED RANDOM NUMBER***********************************************************/
	unsigned char R_N[2],ENC_R_N[2];
	R_N[0]=PACKET_TEMP[8];
    41ce:	89 85       	ldd	r24, Y+9	; 0x09
    41d0:	8c 8b       	std	Y+20, r24	; 0x14
	R_N[1]=PACKET_TEMP[9];
    41d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    41d4:	8d 8b       	std	Y+21, r24	; 0x15
	ENCRYPT_ALGORISM_2_V1(R_N,ENC_R_N,2,PASSWORD_KEY);
    41d6:	98 01       	movw	r18, r16
    41d8:	42 e0       	ldi	r20, 0x02	; 2
    41da:	be 01       	movw	r22, r28
    41dc:	6a 5e       	subi	r22, 0xEA	; 234
    41de:	7f 4f       	sbci	r23, 0xFF	; 255
    41e0:	ce 01       	movw	r24, r28
    41e2:	44 96       	adiw	r24, 0x14	; 20
    41e4:	78 d4       	rcall	.+2288   	; 0x4ad6 <ENCRYPT_ALGORISM_2_V1>
	
	PACKET_TEMP[0]=12|0B10000000;
    41e6:	8c e8       	ldi	r24, 0x8C	; 140
    41e8:	89 83       	std	Y+1, r24	; 0x01
	PACKET_TEMP[1]=SENSOR_VERSION;
    41ea:	9a 82       	std	Y+2, r9	; 0x02
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    41ec:	bb 20       	and	r11, r11
    41ee:	51 f0       	breq	.+20     	; 0x4204 <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x136>
    41f0:	de 01       	movw	r26, r28
    41f2:	13 96       	adiw	r26, 0x03	; 3
    41f4:	ea e0       	ldi	r30, 0x0A	; 10
    41f6:	f1 e0       	ldi	r31, 0x01	; 1
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
    41f8:	81 91       	ld	r24, Z+
    41fa:	8d 93       	st	X+, r24
    41fc:	8e 2f       	mov	r24, r30
    41fe:	8c 19       	sub	r24, r12
	R_N[1]=PACKET_TEMP[9];
	ENCRYPT_ALGORISM_2_V1(R_N,ENC_R_N,2,PASSWORD_KEY);
	
	PACKET_TEMP[0]=12|0B10000000;
	PACKET_TEMP[1]=SENSOR_VERSION;
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    4200:	8b 15       	cp	r24, r11
    4202:	d0 f3       	brcs	.-12     	; 0x41f8 <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x12a>
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
	}
	PACKET_TEMP[7]=CHALLENGE_ANSWER_CODE;
    4204:	83 e0       	ldi	r24, 0x03	; 3
    4206:	88 87       	std	Y+8, r24	; 0x08
	PACKET_TEMP[8]=ENC_R_N[0];
    4208:	8e 89       	ldd	r24, Y+22	; 0x16
    420a:	89 87       	std	Y+9, r24	; 0x09
	PACKET_TEMP[9]=ENC_R_N[1];
    420c:	8f 89       	ldd	r24, Y+23	; 0x17
    420e:	8a 87       	std	Y+10, r24	; 0x0a
	HASH_PASWORD_KEY(PACKET_TEMP,HASH_VALUE,10,PASSWORD_KEY);
    4210:	98 01       	movw	r18, r16
    4212:	4a e0       	ldi	r20, 0x0A	; 10
    4214:	be 01       	movw	r22, r28
    4216:	62 5f       	subi	r22, 0xF2	; 242
    4218:	7f 4f       	sbci	r23, 0xFF	; 255
    421a:	ce 01       	movw	r24, r28
    421c:	01 96       	adiw	r24, 0x01	; 1
    421e:	20 d5       	rcall	.+2624   	; 0x4c60 <HASH_PASWORD_KEY>
	PACKET_TEMP[10]=HASH_VALUE[0];
    4220:	8e 85       	ldd	r24, Y+14	; 0x0e
    4222:	8b 87       	std	Y+11, r24	; 0x0b
	PACKET_TEMP[11]=HASH_VALUE[1];
    4224:	8f 85       	ldd	r24, Y+15	; 0x0f
    4226:	8c 87       	std	Y+12, r24	; 0x0c
	if (!NRF_SEND_DATA_WITH_ACK(SENSOR_ADDRESS,SENSOR_ADDRESS_LENGTH,PACKET_TEMP,12))
    4228:	2c e0       	ldi	r18, 0x0C	; 12
    422a:	ae 01       	movw	r20, r28
    422c:	4f 5f       	subi	r20, 0xFF	; 255
    422e:	5f 4f       	sbci	r21, 0xFF	; 255
    4230:	6b 2d       	mov	r22, r11
    4232:	c7 01       	movw	r24, r14
    4234:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <NRF_SEND_DATA_WITH_ACK>
    4238:	a8 2e       	mov	r10, r24
    423a:	88 23       	and	r24, r24
    423c:	09 f4       	brne	.+2      	; 0x4240 <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x172>
    423e:	5f c0       	rjmp	.+190    	; 0x42fe <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x230>
	}
	/******************************************************************************************************************************/
	
	
	/****************************************CHECK THE RESULT OF CHALLANGE***********************************************************/
	COUNT_TIMER=0;
    4240:	18 8a       	std	Y+16, r1	; 0x10
    4242:	19 8a       	std	Y+17, r1	; 0x11
    4244:	1a 8a       	std	Y+18, r1	; 0x12
    4246:	1b 8a       	std	Y+19, r1	; 0x13
	NRF_START_RX_MODE();
    4248:	0e 94 ad 11 	call	0x235a	; 0x235a <NRF_START_RX_MODE>
	
	if(pdPASS!=xSemaphoreTake(NRF_IRQ_SEMAPHORE,pdMS_TO_TICKS(3000)))
    424c:	4c e2       	ldi	r20, 0x2C	; 44
    424e:	51 e0       	ldi	r21, 0x01	; 1
    4250:	60 e0       	ldi	r22, 0x00	; 0
    4252:	70 e0       	ldi	r23, 0x00	; 0
    4254:	80 91 de 0c 	lds	r24, 0x0CDE
    4258:	90 91 df 0c 	lds	r25, 0x0CDF
    425c:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    4260:	81 30       	cpi	r24, 0x01	; 1
    4262:	41 f0       	breq	.+16     	; 0x4274 <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x1a6>
	{
		TEST_UART_SEND_str("FAIL 3\n");
    4264:	8f e9       	ldi	r24, 0x9F	; 159
    4266:	92 e0       	ldi	r25, 0x02	; 2
    4268:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
		NRF_STOP_RX_MODE();
    426c:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
		return 0;
    4270:	a1 2c       	mov	r10, r1
    4272:	45 c0       	rjmp	.+138    	; 0x42fe <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x230>
	}
	
	NRF_CHECK_RX_PL(PACKET_TEMP,&RX_LENGTH);
    4274:	be 01       	movw	r22, r28
    4276:	63 5f       	subi	r22, 0xF3	; 243
    4278:	7f 4f       	sbci	r23, 0xFF	; 255
    427a:	ce 01       	movw	r24, r28
    427c:	01 96       	adiw	r24, 0x01	; 1
    427e:	0e 94 c5 11 	call	0x238a	; 0x238a <NRF_CHECK_RX_PL>
	
	TEST_UART_SEND_str("counter=");
    4282:	87 ea       	ldi	r24, 0xA7	; 167
    4284:	92 e0       	ldi	r25, 0x02	; 2
    4286:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	TEST_UART_SEND_VALUE(COUNT_TIMER);
    428a:	88 89       	ldd	r24, Y+16	; 0x10
    428c:	99 89       	ldd	r25, Y+17	; 0x11
    428e:	aa 89       	ldd	r26, Y+18	; 0x12
    4290:	bb 89       	ldd	r27, Y+19	; 0x13
    4292:	3c 01       	movw	r6, r24
    4294:	4d 01       	movw	r8, r26
    4296:	28 2f       	mov	r18, r24
    4298:	37 2d       	mov	r19, r7
    429a:	48 2d       	mov	r20, r8
    429c:	59 2d       	mov	r21, r9
    429e:	60 e0       	ldi	r22, 0x00	; 0
    42a0:	70 e0       	ldi	r23, 0x00	; 0
    42a2:	80 e0       	ldi	r24, 0x00	; 0
    42a4:	90 e0       	ldi	r25, 0x00	; 0
    42a6:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
	TEST_UART_SEND_str("\n");
    42aa:	84 e9       	ldi	r24, 0x94	; 148
    42ac:	91 e0       	ldi	r25, 0x01	; 1
    42ae:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	NRF_STOP_RX_MODE();
    42b2:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
	if (!PROTOCOL_CHECK_RECIVED_PACKET(PACKET_TEMP, SENSOR_ADDRESS,RX_LENGTH,PASSWORD_KEY))
    42b6:	98 01       	movw	r18, r16
    42b8:	4d 85       	ldd	r20, Y+13	; 0x0d
    42ba:	b7 01       	movw	r22, r14
    42bc:	ce 01       	movw	r24, r28
    42be:	01 96       	adiw	r24, 0x01	; 1
    42c0:	a8 de       	rcall	.-688    	; 0x4012 <PROTOCOL_CHECK_RECIVED_PACKET>
    42c2:	a8 2e       	mov	r10, r24
    42c4:	88 23       	and	r24, r24
    42c6:	d9 f0       	breq	.+54     	; 0x42fe <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x230>
	{
		return 0;
	}	
	if(PACKET_TEMP[7]!=CHALLENGE_RESULT_CODE)
    42c8:	88 85       	ldd	r24, Y+8	; 0x08
    42ca:	84 30       	cpi	r24, 0x04	; 4
    42cc:	a9 f4       	brne	.+42     	; 0x42f8 <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x22a>
	{
		return 0;
	}
	unsigned char TEMP=0;
    42ce:	18 8e       	std	Y+24, r1	; 0x18
	DECRYPT_ALGORISM_2_V1(&TEMP,&PACKET_TEMP[8],1,PASSWORD_KEY);
    42d0:	98 01       	movw	r18, r16
    42d2:	41 e0       	ldi	r20, 0x01	; 1
    42d4:	be 01       	movw	r22, r28
    42d6:	67 5f       	subi	r22, 0xF7	; 247
    42d8:	7f 4f       	sbci	r23, 0xFF	; 255
    42da:	ce 01       	movw	r24, r28
    42dc:	48 96       	adiw	r24, 0x18	; 24
    42de:	16 d4       	rcall	.+2092   	; 0x4b0c <DECRYPT_ALGORISM_2_V1>
	
	if(TEMP!=CHALLANGE_RESULT_SUCCESS)
    42e0:	88 8d       	ldd	r24, Y+24	; 0x18
    42e2:	84 34       	cpi	r24, 0x44	; 68
    42e4:	59 f4       	brne	.+22     	; 0x42fc <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x22e>
	{
		return 0;
	}
	TEST_UART_SEND_str("SENSOR CONNECTED\n");
    42e6:	80 eb       	ldi	r24, 0xB0	; 176
    42e8:	92 e0       	ldi	r25, 0x02	; 2
    42ea:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	return 1;
    42ee:	aa 24       	eor	r10, r10
    42f0:	a3 94       	inc	r10
    42f2:	05 c0       	rjmp	.+10     	; 0x42fe <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x230>
	{
		return 0;
	}
	if(PACKET_TEMP[7]!=SENSOR_CHALLENGE_CODE)
	{
		return 0;
    42f4:	a1 2c       	mov	r10, r1
    42f6:	03 c0       	rjmp	.+6      	; 0x42fe <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x230>
	{
		return 0;
	}	
	if(PACKET_TEMP[7]!=CHALLENGE_RESULT_CODE)
	{
		return 0;
    42f8:	a1 2c       	mov	r10, r1
    42fa:	01 c0       	rjmp	.+2      	; 0x42fe <PROTOCOL_MASTER_CONNECT_TO_SENSOR+0x230>
	unsigned char TEMP=0;
	DECRYPT_ALGORISM_2_V1(&TEMP,&PACKET_TEMP[8],1,PASSWORD_KEY);
	
	if(TEMP!=CHALLANGE_RESULT_SUCCESS)
	{
		return 0;
    42fc:	a1 2c       	mov	r10, r1
	}
	TEST_UART_SEND_str("SENSOR CONNECTED\n");
	return 1;
}
    42fe:	8a 2d       	mov	r24, r10
    4300:	68 96       	adiw	r28, 0x18	; 24
    4302:	0f b6       	in	r0, 0x3f	; 63
    4304:	f8 94       	cli
    4306:	de bf       	out	0x3e, r29	; 62
    4308:	0f be       	out	0x3f, r0	; 63
    430a:	cd bf       	out	0x3d, r28	; 61
    430c:	df 91       	pop	r29
    430e:	cf 91       	pop	r28
    4310:	1f 91       	pop	r17
    4312:	0f 91       	pop	r16
    4314:	ff 90       	pop	r15
    4316:	ef 90       	pop	r14
    4318:	df 90       	pop	r13
    431a:	cf 90       	pop	r12
    431c:	bf 90       	pop	r11
    431e:	af 90       	pop	r10
    4320:	9f 90       	pop	r9
    4322:	8f 90       	pop	r8
    4324:	7f 90       	pop	r7
    4326:	6f 90       	pop	r6
    4328:	08 95       	ret

0000432a <PROTOCOL_SEND_BEACON>:
	return 0;
	
}

unsigned char PROTOCOL_SEND_BEACON(unsigned char*SENSOR_ADDRESS,unsigned char SENSOR_VERSION,unsigned char SENSOR_ADDRESS_LENGTH,unsigned char*SESSION_KEY)
{
    432a:	6f 92       	push	r6
    432c:	7f 92       	push	r7
    432e:	8f 92       	push	r8
    4330:	9f 92       	push	r9
    4332:	af 92       	push	r10
    4334:	bf 92       	push	r11
    4336:	cf 92       	push	r12
    4338:	df 92       	push	r13
    433a:	ef 92       	push	r14
    433c:	ff 92       	push	r15
    433e:	0f 93       	push	r16
    4340:	1f 93       	push	r17
    4342:	cf 93       	push	r28
    4344:	df 93       	push	r29
    4346:	cd b7       	in	r28, 0x3d	; 61
    4348:	de b7       	in	r29, 0x3e	; 62
    434a:	61 97       	sbiw	r28, 0x11	; 17
    434c:	0f b6       	in	r0, 0x3f	; 63
    434e:	f8 94       	cli
    4350:	de bf       	out	0x3e, r29	; 62
    4352:	0f be       	out	0x3f, r0	; 63
    4354:	cd bf       	out	0x3d, r28	; 61
    4356:	8c 01       	movw	r16, r24
    4358:	d4 2e       	mov	r13, r20
    435a:	79 01       	movw	r14, r18
	unsigned char PACKET_TEMP[10];
	unsigned char i,RX_LENGTH;
	unsigned char HASH_VALUE[2];
	volatile unsigned long COUNT_TIMER=0;
    435c:	1e 86       	std	Y+14, r1	; 0x0e
    435e:	1f 86       	std	Y+15, r1	; 0x0f
    4360:	18 8a       	std	Y+16, r1	; 0x10
    4362:	19 8a       	std	Y+17, r1	; 0x11
	
	
	
	/*********SEND BEACON**********/
	PACKET_TEMP[0]=10|0B00000000;
    4364:	8a e0       	ldi	r24, 0x0A	; 10
    4366:	89 83       	std	Y+1, r24	; 0x01
	PACKET_TEMP[1]=SENSOR_VERSION;
    4368:	6a 83       	std	Y+2, r22	; 0x02
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    436a:	44 23       	and	r20, r20
    436c:	59 f0       	breq	.+22     	; 0x4384 <PROTOCOL_SEND_BEACON+0x5a>
    436e:	8a e0       	ldi	r24, 0x0A	; 10
    4370:	91 e0       	ldi	r25, 0x01	; 1
    4372:	de 01       	movw	r26, r28
    4374:	13 96       	adiw	r26, 0x03	; 3
    4376:	fc 01       	movw	r30, r24
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
    4378:	21 91       	ld	r18, Z+
    437a:	2d 93       	st	X+, r18
    437c:	2e 2f       	mov	r18, r30
    437e:	28 1b       	sub	r18, r24
	
	
	/*********SEND BEACON**********/
	PACKET_TEMP[0]=10|0B00000000;
	PACKET_TEMP[1]=SENSOR_VERSION;
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    4380:	2d 15       	cp	r18, r13
    4382:	d0 f3       	brcs	.-12     	; 0x4378 <PROTOCOL_SEND_BEACON+0x4e>
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
	}
	PACKET_TEMP[7]=BEACON_CODE;
    4384:	85 e0       	ldi	r24, 0x05	; 5
    4386:	88 87       	std	Y+8, r24	; 0x08
	HASH_SESSION_KEY(PACKET_TEMP,HASH_VALUE,8,SESSION_KEY);
    4388:	97 01       	movw	r18, r14
    438a:	48 e0       	ldi	r20, 0x08	; 8
    438c:	be 01       	movw	r22, r28
    438e:	64 5f       	subi	r22, 0xF4	; 244
    4390:	7f 4f       	sbci	r23, 0xFF	; 255
    4392:	ce 01       	movw	r24, r28
    4394:	01 96       	adiw	r24, 0x01	; 1
    4396:	d5 d3       	rcall	.+1962   	; 0x4b42 <HASH_SESSION_KEY>
	PACKET_TEMP[8]=HASH_VALUE[0];
    4398:	8c 85       	ldd	r24, Y+12	; 0x0c
    439a:	89 87       	std	Y+9, r24	; 0x09
	PACKET_TEMP[9]=HASH_VALUE[1];
    439c:	8d 85       	ldd	r24, Y+13	; 0x0d
    439e:	8a 87       	std	Y+10, r24	; 0x0a
	if (!NRF_SEND_DATA_WITH_ACK(SENSOR_ADDRESS,SENSOR_ADDRESS_LENGTH,PACKET_TEMP,10))
    43a0:	2a e0       	ldi	r18, 0x0A	; 10
    43a2:	ae 01       	movw	r20, r28
    43a4:	4f 5f       	subi	r20, 0xFF	; 255
    43a6:	5f 4f       	sbci	r21, 0xFF	; 255
    43a8:	6d 2d       	mov	r22, r13
    43aa:	c8 01       	movw	r24, r16
    43ac:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <NRF_SEND_DATA_WITH_ACK>
    43b0:	88 23       	and	r24, r24
    43b2:	09 f4       	brne	.+2      	; 0x43b6 <PROTOCOL_SEND_BEACON+0x8c>
    43b4:	44 c0       	rjmp	.+136    	; 0x443e <PROTOCOL_SEND_BEACON+0x114>
	}
	/*****************************************************************************************/
	
	
	/******************************RECIVE BEACON *******************************************/
	NRF_START_RX_MODE();
    43b6:	0e 94 ad 11 	call	0x235a	; 0x235a <NRF_START_RX_MODE>
	
		if(pdPASS!=xSemaphoreTake(NRF_IRQ_SEMAPHORE,pdMS_TO_TICKS(3000)))
    43ba:	4c e2       	ldi	r20, 0x2C	; 44
    43bc:	51 e0       	ldi	r21, 0x01	; 1
    43be:	60 e0       	ldi	r22, 0x00	; 0
    43c0:	70 e0       	ldi	r23, 0x00	; 0
    43c2:	80 91 de 0c 	lds	r24, 0x0CDE
    43c6:	90 91 df 0c 	lds	r25, 0x0CDF
    43ca:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    43ce:	81 30       	cpi	r24, 0x01	; 1
    43d0:	41 f0       	breq	.+16     	; 0x43e2 <PROTOCOL_SEND_BEACON+0xb8>
		{
			TEST_UART_SEND_str("BEACON FAIL\n");
    43d2:	82 ec       	ldi	r24, 0xC2	; 194
    43d4:	92 e0       	ldi	r25, 0x02	; 2
    43d6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
			NRF_STOP_RX_MODE();
    43da:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
			return 0;
    43de:	80 e0       	ldi	r24, 0x00	; 0
    43e0:	2e c0       	rjmp	.+92     	; 0x443e <PROTOCOL_SEND_BEACON+0x114>
		}
		
		NRF_CHECK_RX_PL(PACKET_TEMP,&RX_LENGTH);
    43e2:	be 01       	movw	r22, r28
    43e4:	65 5f       	subi	r22, 0xF5	; 245
    43e6:	7f 4f       	sbci	r23, 0xFF	; 255
    43e8:	ce 01       	movw	r24, r28
    43ea:	01 96       	adiw	r24, 0x01	; 1
    43ec:	0e 94 c5 11 	call	0x238a	; 0x238a <NRF_CHECK_RX_PL>
	
	
	
	
	
	TEST_UART_SEND_str("counter=");
    43f0:	87 ea       	ldi	r24, 0xA7	; 167
    43f2:	92 e0       	ldi	r25, 0x02	; 2
    43f4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	TEST_UART_SEND_VALUE(COUNT_TIMER);
    43f8:	8e 85       	ldd	r24, Y+14	; 0x0e
    43fa:	9f 85       	ldd	r25, Y+15	; 0x0f
    43fc:	a8 89       	ldd	r26, Y+16	; 0x10
    43fe:	b9 89       	ldd	r27, Y+17	; 0x11
    4400:	3c 01       	movw	r6, r24
    4402:	4d 01       	movw	r8, r26
    4404:	28 2f       	mov	r18, r24
    4406:	37 2d       	mov	r19, r7
    4408:	48 2d       	mov	r20, r8
    440a:	59 2d       	mov	r21, r9
    440c:	60 e0       	ldi	r22, 0x00	; 0
    440e:	70 e0       	ldi	r23, 0x00	; 0
    4410:	80 e0       	ldi	r24, 0x00	; 0
    4412:	90 e0       	ldi	r25, 0x00	; 0
    4414:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
	TEST_UART_SEND_str("\n");
    4418:	84 e9       	ldi	r24, 0x94	; 148
    441a:	91 e0       	ldi	r25, 0x01	; 1
    441c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	NRF_STOP_RX_MODE();
    4420:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
	if (!PROTOCOL_CHECK_RECIVED_PACKET(PACKET_TEMP, SENSOR_ADDRESS,RX_LENGTH,SESSION_KEY))
    4424:	97 01       	movw	r18, r14
    4426:	4b 85       	ldd	r20, Y+11	; 0x0b
    4428:	b8 01       	movw	r22, r16
    442a:	ce 01       	movw	r24, r28
    442c:	01 96       	adiw	r24, 0x01	; 1
    442e:	f1 dd       	rcall	.-1054   	; 0x4012 <PROTOCOL_CHECK_RECIVED_PACKET>
    4430:	88 23       	and	r24, r24
    4432:	29 f0       	breq	.+10     	; 0x443e <PROTOCOL_SEND_BEACON+0x114>
	{
		return 0;
	}
	if(PACKET_TEMP[7]!=BEACON_RECEIVED_CODE)
    4434:	81 e0       	ldi	r24, 0x01	; 1
    4436:	98 85       	ldd	r25, Y+8	; 0x08
    4438:	96 30       	cpi	r25, 0x06	; 6
    443a:	09 f0       	breq	.+2      	; 0x443e <PROTOCOL_SEND_BEACON+0x114>
    443c:	80 e0       	ldi	r24, 0x00	; 0
	{
		return 0;
	}
	
	return 1;
}
    443e:	61 96       	adiw	r28, 0x11	; 17
    4440:	0f b6       	in	r0, 0x3f	; 63
    4442:	f8 94       	cli
    4444:	de bf       	out	0x3e, r29	; 62
    4446:	0f be       	out	0x3f, r0	; 63
    4448:	cd bf       	out	0x3d, r28	; 61
    444a:	df 91       	pop	r29
    444c:	cf 91       	pop	r28
    444e:	1f 91       	pop	r17
    4450:	0f 91       	pop	r16
    4452:	ff 90       	pop	r15
    4454:	ef 90       	pop	r14
    4456:	df 90       	pop	r13
    4458:	cf 90       	pop	r12
    445a:	bf 90       	pop	r11
    445c:	af 90       	pop	r10
    445e:	9f 90       	pop	r9
    4460:	8f 90       	pop	r8
    4462:	7f 90       	pop	r7
    4464:	6f 90       	pop	r6
    4466:	08 95       	ret

00004468 <PROTOCOL_SEND_SESSION_KEY>:

unsigned char PROTOCOL_SEND_SESSION_KEY(unsigned char*SENSOR_ADDRESS,unsigned char SENSOR_VERSION,unsigned char SENSOR_ADDRESS_LENGTH,unsigned char*SESSION_KEY,unsigned char*PASSWORD_KEY)
{
    4468:	6f 92       	push	r6
    446a:	7f 92       	push	r7
    446c:	8f 92       	push	r8
    446e:	9f 92       	push	r9
    4470:	af 92       	push	r10
    4472:	bf 92       	push	r11
    4474:	cf 92       	push	r12
    4476:	df 92       	push	r13
    4478:	ef 92       	push	r14
    447a:	ff 92       	push	r15
    447c:	0f 93       	push	r16
    447e:	1f 93       	push	r17
    4480:	cf 93       	push	r28
    4482:	df 93       	push	r29
    4484:	cd b7       	in	r28, 0x3d	; 61
    4486:	de b7       	in	r29, 0x3e	; 62
    4488:	66 97       	sbiw	r28, 0x16	; 22
    448a:	0f b6       	in	r0, 0x3f	; 63
    448c:	f8 94       	cli
    448e:	de bf       	out	0x3e, r29	; 62
    4490:	0f be       	out	0x3f, r0	; 63
    4492:	cd bf       	out	0x3d, r28	; 61
    4494:	7c 01       	movw	r14, r24
    4496:	b4 2e       	mov	r11, r20
    4498:	c9 01       	movw	r24, r18
	unsigned char PACKET_TEMP[12];
	unsigned char i,RX_LENGTH;
	unsigned char HASH_VALUE[2];
	volatile unsigned long COUNT_TIMER=0;
    449a:	18 8a       	std	Y+16, r1	; 0x10
    449c:	19 8a       	std	Y+17, r1	; 0x11
    449e:	1a 8a       	std	Y+18, r1	; 0x12
    44a0:	1b 8a       	std	Y+19, r1	; 0x13
	
	
	
	/*********NEW SESSION**********/
	PACKET_TEMP[0]=12|0B10000000;
    44a2:	2c e8       	ldi	r18, 0x8C	; 140
    44a4:	29 83       	std	Y+1, r18	; 0x01
	PACKET_TEMP[1]=SENSOR_VERSION;
    44a6:	6a 83       	std	Y+2, r22	; 0x02
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    44a8:	44 23       	and	r20, r20
    44aa:	59 f0       	breq	.+22     	; 0x44c2 <PROTOCOL_SEND_SESSION_KEY+0x5a>
    44ac:	4a e0       	ldi	r20, 0x0A	; 10
    44ae:	51 e0       	ldi	r21, 0x01	; 1
    44b0:	de 01       	movw	r26, r28
    44b2:	13 96       	adiw	r26, 0x03	; 3
    44b4:	fa 01       	movw	r30, r20
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
    44b6:	21 91       	ld	r18, Z+
    44b8:	2d 93       	st	X+, r18
    44ba:	2e 2f       	mov	r18, r30
    44bc:	24 1b       	sub	r18, r20
	
	
	/*********NEW SESSION**********/
	PACKET_TEMP[0]=12|0B10000000;
	PACKET_TEMP[1]=SENSOR_VERSION;
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    44be:	2b 15       	cp	r18, r11
    44c0:	d0 f3       	brcs	.-12     	; 0x44b6 <PROTOCOL_SEND_SESSION_KEY+0x4e>
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
	}
	PACKET_TEMP[7]=NEW_SESSION_KEY_CODE;
    44c2:	27 e0       	ldi	r18, 0x07	; 7
    44c4:	28 87       	std	Y+8, r18	; 0x08
	unsigned char ENC_SESSION[2];
	ENCRYPT_ALGORISM_2_V1(SESSION_KEY,ENC_SESSION,2,PASSWORD_KEY);
    44c6:	98 01       	movw	r18, r16
    44c8:	42 e0       	ldi	r20, 0x02	; 2
    44ca:	be 01       	movw	r22, r28
    44cc:	6c 5e       	subi	r22, 0xEC	; 236
    44ce:	7f 4f       	sbci	r23, 0xFF	; 255
    44d0:	02 d3       	rcall	.+1540   	; 0x4ad6 <ENCRYPT_ALGORISM_2_V1>
	PACKET_TEMP[8]=ENC_SESSION[0];
    44d2:	8c 89       	ldd	r24, Y+20	; 0x14
    44d4:	89 87       	std	Y+9, r24	; 0x09
	PACKET_TEMP[9]=ENC_SESSION[1];
    44d6:	8d 89       	ldd	r24, Y+21	; 0x15
    44d8:	8a 87       	std	Y+10, r24	; 0x0a
	HASH_PASWORD_KEY(PACKET_TEMP,HASH_VALUE,10,PASSWORD_KEY);
    44da:	98 01       	movw	r18, r16
    44dc:	4a e0       	ldi	r20, 0x0A	; 10
    44de:	be 01       	movw	r22, r28
    44e0:	62 5f       	subi	r22, 0xF2	; 242
    44e2:	7f 4f       	sbci	r23, 0xFF	; 255
    44e4:	ce 01       	movw	r24, r28
    44e6:	01 96       	adiw	r24, 0x01	; 1
    44e8:	bb d3       	rcall	.+1910   	; 0x4c60 <HASH_PASWORD_KEY>
	PACKET_TEMP[10]=HASH_VALUE[0];
    44ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    44ec:	8b 87       	std	Y+11, r24	; 0x0b
	PACKET_TEMP[11]=HASH_VALUE[1];
    44ee:	8f 85       	ldd	r24, Y+15	; 0x0f
    44f0:	8c 87       	std	Y+12, r24	; 0x0c
	if (!NRF_SEND_DATA_WITH_ACK(SENSOR_ADDRESS,SENSOR_ADDRESS_LENGTH,PACKET_TEMP,12))
    44f2:	2c e0       	ldi	r18, 0x0C	; 12
    44f4:	ae 01       	movw	r20, r28
    44f6:	4f 5f       	subi	r20, 0xFF	; 255
    44f8:	5f 4f       	sbci	r21, 0xFF	; 255
    44fa:	6b 2d       	mov	r22, r11
    44fc:	c7 01       	movw	r24, r14
    44fe:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <NRF_SEND_DATA_WITH_ACK>
    4502:	88 23       	and	r24, r24
    4504:	09 f4       	brne	.+2      	; 0x4508 <PROTOCOL_SEND_SESSION_KEY+0xa0>
    4506:	52 c0       	rjmp	.+164    	; 0x45ac <PROTOCOL_SEND_SESSION_KEY+0x144>
	}
	/*****************************************************************************************/
	
	
	/******************************SESSION KEY APPLIED*******************************************/
	NRF_START_RX_MODE();
    4508:	0e 94 ad 11 	call	0x235a	; 0x235a <NRF_START_RX_MODE>
	
	
	
	if(pdPASS!=xSemaphoreTake(NRF_IRQ_SEMAPHORE,pdMS_TO_TICKS(3000)))
    450c:	4c e2       	ldi	r20, 0x2C	; 44
    450e:	51 e0       	ldi	r21, 0x01	; 1
    4510:	60 e0       	ldi	r22, 0x00	; 0
    4512:	70 e0       	ldi	r23, 0x00	; 0
    4514:	80 91 de 0c 	lds	r24, 0x0CDE
    4518:	90 91 df 0c 	lds	r25, 0x0CDF
    451c:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    4520:	81 30       	cpi	r24, 0x01	; 1
    4522:	41 f0       	breq	.+16     	; 0x4534 <PROTOCOL_SEND_SESSION_KEY+0xcc>
	{
		TEST_UART_SEND_str("SESSION FAIL\n");
    4524:	8f ec       	ldi	r24, 0xCF	; 207
    4526:	92 e0       	ldi	r25, 0x02	; 2
    4528:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
		NRF_STOP_RX_MODE();
    452c:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
		return 0;
    4530:	80 e0       	ldi	r24, 0x00	; 0
    4532:	3c c0       	rjmp	.+120    	; 0x45ac <PROTOCOL_SEND_SESSION_KEY+0x144>
	}
	
	NRF_CHECK_RX_PL(PACKET_TEMP,&RX_LENGTH);
    4534:	be 01       	movw	r22, r28
    4536:	63 5f       	subi	r22, 0xF3	; 243
    4538:	7f 4f       	sbci	r23, 0xFF	; 255
    453a:	ce 01       	movw	r24, r28
    453c:	01 96       	adiw	r24, 0x01	; 1
    453e:	0e 94 c5 11 	call	0x238a	; 0x238a <NRF_CHECK_RX_PL>
	
	
	
	TEST_UART_SEND_str("counter=");
    4542:	87 ea       	ldi	r24, 0xA7	; 167
    4544:	92 e0       	ldi	r25, 0x02	; 2
    4546:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	TEST_UART_SEND_VALUE(COUNT_TIMER);
    454a:	88 89       	ldd	r24, Y+16	; 0x10
    454c:	99 89       	ldd	r25, Y+17	; 0x11
    454e:	aa 89       	ldd	r26, Y+18	; 0x12
    4550:	bb 89       	ldd	r27, Y+19	; 0x13
    4552:	3c 01       	movw	r6, r24
    4554:	4d 01       	movw	r8, r26
    4556:	28 2f       	mov	r18, r24
    4558:	37 2d       	mov	r19, r7
    455a:	48 2d       	mov	r20, r8
    455c:	59 2d       	mov	r21, r9
    455e:	60 e0       	ldi	r22, 0x00	; 0
    4560:	70 e0       	ldi	r23, 0x00	; 0
    4562:	80 e0       	ldi	r24, 0x00	; 0
    4564:	90 e0       	ldi	r25, 0x00	; 0
    4566:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
	TEST_UART_SEND_str("\n");
    456a:	84 e9       	ldi	r24, 0x94	; 148
    456c:	91 e0       	ldi	r25, 0x01	; 1
    456e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	NRF_STOP_RX_MODE();
    4572:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
	if (!PROTOCOL_CHECK_RECIVED_PACKET(PACKET_TEMP, SENSOR_ADDRESS,RX_LENGTH,PASSWORD_KEY))
    4576:	98 01       	movw	r18, r16
    4578:	4d 85       	ldd	r20, Y+13	; 0x0d
    457a:	b7 01       	movw	r22, r14
    457c:	ce 01       	movw	r24, r28
    457e:	01 96       	adiw	r24, 0x01	; 1
    4580:	48 dd       	rcall	.-1392   	; 0x4012 <PROTOCOL_CHECK_RECIVED_PACKET>
    4582:	88 23       	and	r24, r24
    4584:	99 f0       	breq	.+38     	; 0x45ac <PROTOCOL_SEND_SESSION_KEY+0x144>
	{
		return 0;
	}
	if(PACKET_TEMP[7]!=NEW_SESSION_KEY_APPLIED_CODE)
    4586:	88 85       	ldd	r24, Y+8	; 0x08
    4588:	88 30       	cpi	r24, 0x08	; 8
    458a:	79 f4       	brne	.+30     	; 0x45aa <PROTOCOL_SEND_SESSION_KEY+0x142>
	{
		return 0;
	}
	unsigned char TEMP=0;
    458c:	1e 8a       	std	Y+22, r1	; 0x16
	DECRYPT_ALGORISM_2_V1(&TEMP,&PACKET_TEMP[8],1,PASSWORD_KEY);
    458e:	98 01       	movw	r18, r16
    4590:	41 e0       	ldi	r20, 0x01	; 1
    4592:	be 01       	movw	r22, r28
    4594:	67 5f       	subi	r22, 0xF7	; 247
    4596:	7f 4f       	sbci	r23, 0xFF	; 255
    4598:	ce 01       	movw	r24, r28
    459a:	46 96       	adiw	r24, 0x16	; 22
    459c:	b7 d2       	rcall	.+1390   	; 0x4b0c <DECRYPT_ALGORISM_2_V1>
	
	if(TEMP!=CHALLANGE_RESULT_SUCCESS)
    459e:	81 e0       	ldi	r24, 0x01	; 1
    45a0:	9e 89       	ldd	r25, Y+22	; 0x16
    45a2:	94 34       	cpi	r25, 0x44	; 68
    45a4:	19 f0       	breq	.+6      	; 0x45ac <PROTOCOL_SEND_SESSION_KEY+0x144>
    45a6:	80 e0       	ldi	r24, 0x00	; 0
    45a8:	01 c0       	rjmp	.+2      	; 0x45ac <PROTOCOL_SEND_SESSION_KEY+0x144>
	{
		return 0;
	}
	if(PACKET_TEMP[7]!=NEW_SESSION_KEY_APPLIED_CODE)
	{
		return 0;
    45aa:	80 e0       	ldi	r24, 0x00	; 0
		return 0;
	}
	return 1;
	
	
}
    45ac:	66 96       	adiw	r28, 0x16	; 22
    45ae:	0f b6       	in	r0, 0x3f	; 63
    45b0:	f8 94       	cli
    45b2:	de bf       	out	0x3e, r29	; 62
    45b4:	0f be       	out	0x3f, r0	; 63
    45b6:	cd bf       	out	0x3d, r28	; 61
    45b8:	df 91       	pop	r29
    45ba:	cf 91       	pop	r28
    45bc:	1f 91       	pop	r17
    45be:	0f 91       	pop	r16
    45c0:	ff 90       	pop	r15
    45c2:	ef 90       	pop	r14
    45c4:	df 90       	pop	r13
    45c6:	cf 90       	pop	r12
    45c8:	bf 90       	pop	r11
    45ca:	af 90       	pop	r10
    45cc:	9f 90       	pop	r9
    45ce:	8f 90       	pop	r8
    45d0:	7f 90       	pop	r7
    45d2:	6f 90       	pop	r6
    45d4:	08 95       	ret

000045d6 <PROTOCOL_CHANGE_CHANNEL>:

unsigned char PROTOCOL_CHANGE_CHANNEL(unsigned char*SENSOR_ADDRESS,unsigned char SENSOR_VERSION,unsigned char SENSOR_ADDRESS_LENGTH,unsigned char*SESSION_KEY,unsigned char CHANNEL)
{
    45d6:	4f 92       	push	r4
    45d8:	5f 92       	push	r5
    45da:	6f 92       	push	r6
    45dc:	7f 92       	push	r7
    45de:	8f 92       	push	r8
    45e0:	9f 92       	push	r9
    45e2:	af 92       	push	r10
    45e4:	bf 92       	push	r11
    45e6:	cf 92       	push	r12
    45e8:	df 92       	push	r13
    45ea:	ef 92       	push	r14
    45ec:	ff 92       	push	r15
    45ee:	0f 93       	push	r16
    45f0:	cf 93       	push	r28
    45f2:	df 93       	push	r29
    45f4:	cd b7       	in	r28, 0x3d	; 61
    45f6:	de b7       	in	r29, 0x3e	; 62
    45f8:	66 97       	sbiw	r28, 0x16	; 22
    45fa:	0f b6       	in	r0, 0x3f	; 63
    45fc:	f8 94       	cli
    45fe:	de bf       	out	0x3e, r29	; 62
    4600:	0f be       	out	0x3f, r0	; 63
    4602:	cd bf       	out	0x3d, r28	; 61
    4604:	6c 01       	movw	r12, r24
    4606:	b4 2e       	mov	r11, r20
    4608:	79 01       	movw	r14, r18
    460a:	0e 8b       	std	Y+22, r16	; 0x16
	volatile unsigned char PACKET_TEMP[12];
	unsigned char i,RX_LENGTH;
	unsigned char HASH_VALUE[2];
	volatile unsigned long COUNT_TIMER=0;
    460c:	18 8a       	std	Y+16, r1	; 0x10
    460e:	19 8a       	std	Y+17, r1	; 0x11
    4610:	1a 8a       	std	Y+18, r1	; 0x12
    4612:	1b 8a       	std	Y+19, r1	; 0x13
	
	
	
	/*********NEW CHANNEL**********/
	PACKET_TEMP[0]=11|0B00000000;
    4614:	8b e0       	ldi	r24, 0x0B	; 11
    4616:	89 83       	std	Y+1, r24	; 0x01
	PACKET_TEMP[1]=SENSOR_VERSION;
    4618:	6a 83       	std	Y+2, r22	; 0x02
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    461a:	44 23       	and	r20, r20
    461c:	91 f0       	breq	.+36     	; 0x4642 <PROTOCOL_CHANGE_CHANNEL+0x6c>
    461e:	2a e0       	ldi	r18, 0x0A	; 10
    4620:	31 e0       	ldi	r19, 0x01	; 1
    4622:	f9 01       	movw	r30, r18
    4624:	82 e0       	ldi	r24, 0x02	; 2
    4626:	90 e0       	ldi	r25, 0x00	; 0
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
    4628:	51 91       	ld	r21, Z+
    462a:	a1 e0       	ldi	r26, 0x01	; 1
    462c:	b0 e0       	ldi	r27, 0x00	; 0
    462e:	ac 0f       	add	r26, r28
    4630:	bd 1f       	adc	r27, r29
    4632:	a8 0f       	add	r26, r24
    4634:	b9 1f       	adc	r27, r25
    4636:	5c 93       	st	X, r21
    4638:	01 96       	adiw	r24, 0x01	; 1
    463a:	5e 2f       	mov	r21, r30
    463c:	52 1b       	sub	r21, r18
	
	
	/*********NEW CHANNEL**********/
	PACKET_TEMP[0]=11|0B00000000;
	PACKET_TEMP[1]=SENSOR_VERSION;
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    463e:	5b 15       	cp	r21, r11
    4640:	98 f3       	brcs	.-26     	; 0x4628 <PROTOCOL_CHANGE_CHANNEL+0x52>
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
	}
	PACKET_TEMP[7]=MASTER_CHANGE_CHANNEL_CODE;
    4642:	89 e0       	ldi	r24, 0x09	; 9
    4644:	88 87       	std	Y+8, r24	; 0x08
	unsigned char ENC_CHANNEL;
	ENCRYPT_ALGORISM_1_V1(&CHANNEL,&ENC_CHANNEL,1,SESSION_KEY);
    4646:	97 01       	movw	r18, r14
    4648:	41 e0       	ldi	r20, 0x01	; 1
    464a:	be 01       	movw	r22, r28
    464c:	6c 5e       	subi	r22, 0xEC	; 236
    464e:	7f 4f       	sbci	r23, 0xFF	; 255
    4650:	ce 01       	movw	r24, r28
    4652:	46 96       	adiw	r24, 0x16	; 22
    4654:	04 d2       	rcall	.+1032   	; 0x4a5e <ENCRYPT_ALGORISM_1_V1>
	PACKET_TEMP[8]=ENC_CHANNEL;
    4656:	8c 89       	ldd	r24, Y+20	; 0x14
    4658:	89 87       	std	Y+9, r24	; 0x09
	HASH_SESSION_KEY(PACKET_TEMP,HASH_VALUE,9,SESSION_KEY);
    465a:	97 01       	movw	r18, r14
    465c:	49 e0       	ldi	r20, 0x09	; 9
    465e:	be 01       	movw	r22, r28
    4660:	62 5f       	subi	r22, 0xF2	; 242
    4662:	7f 4f       	sbci	r23, 0xFF	; 255
    4664:	ce 01       	movw	r24, r28
    4666:	01 96       	adiw	r24, 0x01	; 1
    4668:	6c d2       	rcall	.+1240   	; 0x4b42 <HASH_SESSION_KEY>
	PACKET_TEMP[9]=HASH_VALUE[0];
    466a:	8e 85       	ldd	r24, Y+14	; 0x0e
    466c:	8a 87       	std	Y+10, r24	; 0x0a
	PACKET_TEMP[10]=HASH_VALUE[1];
    466e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4670:	8b 87       	std	Y+11, r24	; 0x0b
	if (!NRF_SEND_DATA_WITH_ACK(SENSOR_ADDRESS,SENSOR_ADDRESS_LENGTH,PACKET_TEMP,11))
    4672:	2b e0       	ldi	r18, 0x0B	; 11
    4674:	ae 01       	movw	r20, r28
    4676:	4f 5f       	subi	r20, 0xFF	; 255
    4678:	5f 4f       	sbci	r21, 0xFF	; 255
    467a:	6b 2d       	mov	r22, r11
    467c:	c6 01       	movw	r24, r12
    467e:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <NRF_SEND_DATA_WITH_ACK>
    4682:	88 23       	and	r24, r24
    4684:	09 f4       	brne	.+2      	; 0x4688 <PROTOCOL_CHANGE_CHANNEL+0xb2>
    4686:	50 c0       	rjmp	.+160    	; 0x4728 <PROTOCOL_CHANGE_CHANNEL+0x152>
	}
	/*****************************************************************************************/
	
	
	/******************************CHANNEL APPLIED*******************************************/
	NRF_START_RX_MODE();
    4688:	0e 94 ad 11 	call	0x235a	; 0x235a <NRF_START_RX_MODE>
	
	
	if(pdPASS!=xSemaphoreTake(NRF_IRQ_SEMAPHORE,pdMS_TO_TICKS(3000)))
    468c:	4c e2       	ldi	r20, 0x2C	; 44
    468e:	51 e0       	ldi	r21, 0x01	; 1
    4690:	60 e0       	ldi	r22, 0x00	; 0
    4692:	70 e0       	ldi	r23, 0x00	; 0
    4694:	80 91 de 0c 	lds	r24, 0x0CDE
    4698:	90 91 df 0c 	lds	r25, 0x0CDF
    469c:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    46a0:	81 30       	cpi	r24, 0x01	; 1
    46a2:	41 f0       	breq	.+16     	; 0x46b4 <PROTOCOL_CHANGE_CHANNEL+0xde>
	{
		TEST_UART_SEND_str("CHANNEL FAIL\n");
    46a4:	8d ed       	ldi	r24, 0xDD	; 221
    46a6:	92 e0       	ldi	r25, 0x02	; 2
    46a8:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
		NRF_STOP_RX_MODE();
    46ac:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
		return 0;
    46b0:	80 e0       	ldi	r24, 0x00	; 0
    46b2:	3a c0       	rjmp	.+116    	; 0x4728 <PROTOCOL_CHANGE_CHANNEL+0x152>
	}
	
	NRF_CHECK_RX_PL(PACKET_TEMP,&RX_LENGTH);
    46b4:	be 01       	movw	r22, r28
    46b6:	63 5f       	subi	r22, 0xF3	; 243
    46b8:	7f 4f       	sbci	r23, 0xFF	; 255
    46ba:	ce 01       	movw	r24, r28
    46bc:	01 96       	adiw	r24, 0x01	; 1
    46be:	0e 94 c5 11 	call	0x238a	; 0x238a <NRF_CHECK_RX_PL>
	
	
	TEST_UART_SEND_str("counter=");
    46c2:	87 ea       	ldi	r24, 0xA7	; 167
    46c4:	92 e0       	ldi	r25, 0x02	; 2
    46c6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	TEST_UART_SEND_VALUE(COUNT_TIMER);
    46ca:	48 88       	ldd	r4, Y+16	; 0x10
    46cc:	59 88       	ldd	r5, Y+17	; 0x11
    46ce:	6a 88       	ldd	r6, Y+18	; 0x12
    46d0:	7b 88       	ldd	r7, Y+19	; 0x13
    46d2:	24 2d       	mov	r18, r4
    46d4:	35 2d       	mov	r19, r5
    46d6:	46 2d       	mov	r20, r6
    46d8:	57 2d       	mov	r21, r7
    46da:	60 e0       	ldi	r22, 0x00	; 0
    46dc:	70 e0       	ldi	r23, 0x00	; 0
    46de:	80 e0       	ldi	r24, 0x00	; 0
    46e0:	90 e0       	ldi	r25, 0x00	; 0
    46e2:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
	TEST_UART_SEND_str("\n");
    46e6:	84 e9       	ldi	r24, 0x94	; 148
    46e8:	91 e0       	ldi	r25, 0x01	; 1
    46ea:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	NRF_STOP_RX_MODE();
    46ee:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
	if (!PROTOCOL_CHECK_RECIVED_PACKET(PACKET_TEMP, SENSOR_ADDRESS,RX_LENGTH,SESSION_KEY))
    46f2:	97 01       	movw	r18, r14
    46f4:	4d 85       	ldd	r20, Y+13	; 0x0d
    46f6:	b6 01       	movw	r22, r12
    46f8:	ce 01       	movw	r24, r28
    46fa:	01 96       	adiw	r24, 0x01	; 1
    46fc:	8a dc       	rcall	.-1772   	; 0x4012 <PROTOCOL_CHECK_RECIVED_PACKET>
    46fe:	88 23       	and	r24, r24
    4700:	99 f0       	breq	.+38     	; 0x4728 <PROTOCOL_CHANGE_CHANNEL+0x152>
	{
		return 0;
	}
	if(PACKET_TEMP[7]!=CHANNEL_CHANGED_CODE)
    4702:	88 85       	ldd	r24, Y+8	; 0x08
    4704:	8a 30       	cpi	r24, 0x0A	; 10
    4706:	79 f4       	brne	.+30     	; 0x4726 <PROTOCOL_CHANGE_CHANNEL+0x150>
	{
		return 0;
	}
	unsigned char TEMP=0;
    4708:	1d 8a       	std	Y+21, r1	; 0x15
	DECRYPT_ALGORISM_1_V1(&TEMP,&PACKET_TEMP[8],1,SESSION_KEY);
    470a:	97 01       	movw	r18, r14
    470c:	41 e0       	ldi	r20, 0x01	; 1
    470e:	be 01       	movw	r22, r28
    4710:	67 5f       	subi	r22, 0xF7	; 247
    4712:	7f 4f       	sbci	r23, 0xFF	; 255
    4714:	ce 01       	movw	r24, r28
    4716:	45 96       	adiw	r24, 0x15	; 21
    4718:	c0 d1       	rcall	.+896    	; 0x4a9a <DECRYPT_ALGORISM_1_V1>
	
	if(TEMP!=CHALLANGE_RESULT_SUCCESS)
    471a:	81 e0       	ldi	r24, 0x01	; 1
    471c:	9d 89       	ldd	r25, Y+21	; 0x15
    471e:	94 34       	cpi	r25, 0x44	; 68
    4720:	19 f0       	breq	.+6      	; 0x4728 <PROTOCOL_CHANGE_CHANNEL+0x152>
    4722:	80 e0       	ldi	r24, 0x00	; 0
    4724:	01 c0       	rjmp	.+2      	; 0x4728 <PROTOCOL_CHANGE_CHANNEL+0x152>
	{
		return 0;
	}
	if(PACKET_TEMP[7]!=CHANNEL_CHANGED_CODE)
	{
		return 0;
    4726:	80 e0       	ldi	r24, 0x00	; 0
	if(TEMP!=CHALLANGE_RESULT_SUCCESS)
	{
		return 0;
	}
	return 1;
}
    4728:	66 96       	adiw	r28, 0x16	; 22
    472a:	0f b6       	in	r0, 0x3f	; 63
    472c:	f8 94       	cli
    472e:	de bf       	out	0x3e, r29	; 62
    4730:	0f be       	out	0x3f, r0	; 63
    4732:	cd bf       	out	0x3d, r28	; 61
    4734:	df 91       	pop	r29
    4736:	cf 91       	pop	r28
    4738:	0f 91       	pop	r16
    473a:	ff 90       	pop	r15
    473c:	ef 90       	pop	r14
    473e:	df 90       	pop	r13
    4740:	cf 90       	pop	r12
    4742:	bf 90       	pop	r11
    4744:	af 90       	pop	r10
    4746:	9f 90       	pop	r9
    4748:	8f 90       	pop	r8
    474a:	7f 90       	pop	r7
    474c:	6f 90       	pop	r6
    474e:	5f 90       	pop	r5
    4750:	4f 90       	pop	r4
    4752:	08 95       	ret

00004754 <PROTOCOL_DATA_SEND>:

unsigned char PROTOCOL_DATA_SEND(unsigned char*SENSOR_ADDRESS,unsigned char SENSOR_VERSION,unsigned char SENSOR_ADDRESS_LENGTH,unsigned char*SESSION_KEY,unsigned char *REGISTER_ADDRESS,unsigned char*DATA_SEND_BUFFER)
{
    4754:	2f 92       	push	r2
    4756:	3f 92       	push	r3
    4758:	4f 92       	push	r4
    475a:	5f 92       	push	r5
    475c:	6f 92       	push	r6
    475e:	7f 92       	push	r7
    4760:	8f 92       	push	r8
    4762:	9f 92       	push	r9
    4764:	af 92       	push	r10
    4766:	bf 92       	push	r11
    4768:	cf 92       	push	r12
    476a:	df 92       	push	r13
    476c:	ef 92       	push	r14
    476e:	ff 92       	push	r15
    4770:	0f 93       	push	r16
    4772:	1f 93       	push	r17
    4774:	cf 93       	push	r28
    4776:	df 93       	push	r29
    4778:	cd b7       	in	r28, 0x3d	; 61
    477a:	de b7       	in	r29, 0x3e	; 62
    477c:	6d 97       	sbiw	r28, 0x1d	; 29
    477e:	0f b6       	in	r0, 0x3f	; 63
    4780:	f8 94       	cli
    4782:	de bf       	out	0x3e, r29	; 62
    4784:	0f be       	out	0x3f, r0	; 63
    4786:	cd bf       	out	0x3d, r28	; 61
    4788:	5c 01       	movw	r10, r24
    478a:	94 2e       	mov	r9, r20
    478c:	69 01       	movw	r12, r18
	unsigned char PACKET_TEMP[14];
	unsigned char i,RX_LENGTH;
	unsigned char HASH_VALUE[2];
	volatile unsigned long COUNT_TIMER=0;
    478e:	1a 8a       	std	Y+18, r1	; 0x12
    4790:	1b 8a       	std	Y+19, r1	; 0x13
    4792:	1c 8a       	std	Y+20, r1	; 0x14
    4794:	1d 8a       	std	Y+21, r1	; 0x15
	
	
	
	/*********SEND DATA**********/
	PACKET_TEMP[0]=14|0B00000000;
    4796:	8e e0       	ldi	r24, 0x0E	; 14
    4798:	89 83       	std	Y+1, r24	; 0x01
	PACKET_TEMP[1]=SENSOR_VERSION;
    479a:	6a 83       	std	Y+2, r22	; 0x02
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    479c:	44 23       	and	r20, r20
    479e:	59 f0       	breq	.+22     	; 0x47b6 <PROTOCOL_DATA_SEND+0x62>
    47a0:	8a e0       	ldi	r24, 0x0A	; 10
    47a2:	91 e0       	ldi	r25, 0x01	; 1
    47a4:	de 01       	movw	r26, r28
    47a6:	13 96       	adiw	r26, 0x03	; 3
    47a8:	fc 01       	movw	r30, r24
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
    47aa:	21 91       	ld	r18, Z+
    47ac:	2d 93       	st	X+, r18
    47ae:	2e 2f       	mov	r18, r30
    47b0:	28 1b       	sub	r18, r24
	
	
	/*********SEND DATA**********/
	PACKET_TEMP[0]=14|0B00000000;
	PACKET_TEMP[1]=SENSOR_VERSION;
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    47b2:	29 15       	cp	r18, r9
    47b4:	d0 f3       	brcs	.-12     	; 0x47aa <PROTOCOL_DATA_SEND+0x56>
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
	}
	PACKET_TEMP[7]=MASTER_CHANGE_DATA_CODE;
    47b6:	80 e1       	ldi	r24, 0x10	; 16
    47b8:	88 87       	std	Y+8, r24	; 0x08
	unsigned char PLAIN_TEXT[4],CIPHER_TEXT[4];
	PLAIN_TEXT[0]=REGISTER_ADDRESS[0];
    47ba:	f8 01       	movw	r30, r16
    47bc:	80 81       	ld	r24, Z
    47be:	8e 8b       	std	Y+22, r24	; 0x16
	PLAIN_TEXT[1]=REGISTER_ADDRESS[1];
    47c0:	81 81       	ldd	r24, Z+1	; 0x01
    47c2:	8f 8b       	std	Y+23, r24	; 0x17
	PLAIN_TEXT[2]=DATA_SEND_BUFFER[0];
    47c4:	f7 01       	movw	r30, r14
    47c6:	80 81       	ld	r24, Z
    47c8:	88 8f       	std	Y+24, r24	; 0x18
	PLAIN_TEXT[3]=DATA_SEND_BUFFER[1];
    47ca:	81 81       	ldd	r24, Z+1	; 0x01
    47cc:	89 8f       	std	Y+25, r24	; 0x19
	ENCRYPT_ALGORISM_1_V1(PLAIN_TEXT,CIPHER_TEXT,4,SESSION_KEY);
    47ce:	96 01       	movw	r18, r12
    47d0:	44 e0       	ldi	r20, 0x04	; 4
    47d2:	be 01       	movw	r22, r28
    47d4:	66 5e       	subi	r22, 0xE6	; 230
    47d6:	7f 4f       	sbci	r23, 0xFF	; 255
    47d8:	ce 01       	movw	r24, r28
    47da:	46 96       	adiw	r24, 0x16	; 22
    47dc:	40 d1       	rcall	.+640    	; 0x4a5e <ENCRYPT_ALGORISM_1_V1>
	PACKET_TEMP[8]=CIPHER_TEXT[0];
    47de:	8a 8d       	ldd	r24, Y+26	; 0x1a
    47e0:	89 87       	std	Y+9, r24	; 0x09
	PACKET_TEMP[9]=CIPHER_TEXT[1];
    47e2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    47e4:	8a 87       	std	Y+10, r24	; 0x0a
	PACKET_TEMP[10]=CIPHER_TEXT[2];
    47e6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    47e8:	8b 87       	std	Y+11, r24	; 0x0b
	PACKET_TEMP[11]=CIPHER_TEXT[3];
    47ea:	8d 8d       	ldd	r24, Y+29	; 0x1d
    47ec:	8c 87       	std	Y+12, r24	; 0x0c
	HASH_SESSION_KEY(PACKET_TEMP,HASH_VALUE,12,SESSION_KEY);
    47ee:	96 01       	movw	r18, r12
    47f0:	4c e0       	ldi	r20, 0x0C	; 12
    47f2:	be 01       	movw	r22, r28
    47f4:	60 5f       	subi	r22, 0xF0	; 240
    47f6:	7f 4f       	sbci	r23, 0xFF	; 255
    47f8:	ce 01       	movw	r24, r28
    47fa:	01 96       	adiw	r24, 0x01	; 1
    47fc:	a2 d1       	rcall	.+836    	; 0x4b42 <HASH_SESSION_KEY>
	PACKET_TEMP[12]=HASH_VALUE[0];
    47fe:	88 89       	ldd	r24, Y+16	; 0x10
    4800:	8d 87       	std	Y+13, r24	; 0x0d
	PACKET_TEMP[13]=HASH_VALUE[1];
    4802:	89 89       	ldd	r24, Y+17	; 0x11
    4804:	8e 87       	std	Y+14, r24	; 0x0e
	if (!NRF_SEND_DATA_WITH_ACK(SENSOR_ADDRESS,SENSOR_ADDRESS_LENGTH,PACKET_TEMP,14))
    4806:	2e e0       	ldi	r18, 0x0E	; 14
    4808:	ae 01       	movw	r20, r28
    480a:	4f 5f       	subi	r20, 0xFF	; 255
    480c:	5f 4f       	sbci	r21, 0xFF	; 255
    480e:	69 2d       	mov	r22, r9
    4810:	c5 01       	movw	r24, r10
    4812:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <NRF_SEND_DATA_WITH_ACK>
    4816:	88 23       	and	r24, r24
    4818:	09 f4       	brne	.+2      	; 0x481c <PROTOCOL_DATA_SEND+0xc8>
    481a:	44 c0       	rjmp	.+136    	; 0x48a4 <PROTOCOL_DATA_SEND+0x150>
	}
	/*****************************************************************************************/
	
	
	/******************************DATA SEND APPLIED*******************************************/
	NRF_START_RX_MODE();
    481c:	0e 94 ad 11 	call	0x235a	; 0x235a <NRF_START_RX_MODE>
	
	if(pdPASS!=xSemaphoreTake(NRF_IRQ_SEMAPHORE,pdMS_TO_TICKS(3000)))
    4820:	4c e2       	ldi	r20, 0x2C	; 44
    4822:	51 e0       	ldi	r21, 0x01	; 1
    4824:	60 e0       	ldi	r22, 0x00	; 0
    4826:	70 e0       	ldi	r23, 0x00	; 0
    4828:	80 91 de 0c 	lds	r24, 0x0CDE
    482c:	90 91 df 0c 	lds	r25, 0x0CDF
    4830:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    4834:	81 30       	cpi	r24, 0x01	; 1
    4836:	41 f0       	breq	.+16     	; 0x4848 <PROTOCOL_DATA_SEND+0xf4>
	{
		TEST_UART_SEND_str("SEND FAIL\n");
    4838:	8b ee       	ldi	r24, 0xEB	; 235
    483a:	92 e0       	ldi	r25, 0x02	; 2
    483c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
		NRF_STOP_RX_MODE();
    4840:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
		return 0;
    4844:	80 e0       	ldi	r24, 0x00	; 0
    4846:	2e c0       	rjmp	.+92     	; 0x48a4 <PROTOCOL_DATA_SEND+0x150>
	}
	
	NRF_CHECK_RX_PL(PACKET_TEMP,&RX_LENGTH);
    4848:	be 01       	movw	r22, r28
    484a:	61 5f       	subi	r22, 0xF1	; 241
    484c:	7f 4f       	sbci	r23, 0xFF	; 255
    484e:	ce 01       	movw	r24, r28
    4850:	01 96       	adiw	r24, 0x01	; 1
    4852:	0e 94 c5 11 	call	0x238a	; 0x238a <NRF_CHECK_RX_PL>
	
	
	
	TEST_UART_SEND_str("counter=");
    4856:	87 ea       	ldi	r24, 0xA7	; 167
    4858:	92 e0       	ldi	r25, 0x02	; 2
    485a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	TEST_UART_SEND_VALUE(COUNT_TIMER);
    485e:	8a 89       	ldd	r24, Y+18	; 0x12
    4860:	9b 89       	ldd	r25, Y+19	; 0x13
    4862:	ac 89       	ldd	r26, Y+20	; 0x14
    4864:	bd 89       	ldd	r27, Y+21	; 0x15
    4866:	1c 01       	movw	r2, r24
    4868:	2d 01       	movw	r4, r26
    486a:	28 2f       	mov	r18, r24
    486c:	33 2d       	mov	r19, r3
    486e:	44 2d       	mov	r20, r4
    4870:	55 2d       	mov	r21, r5
    4872:	60 e0       	ldi	r22, 0x00	; 0
    4874:	70 e0       	ldi	r23, 0x00	; 0
    4876:	80 e0       	ldi	r24, 0x00	; 0
    4878:	90 e0       	ldi	r25, 0x00	; 0
    487a:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
	TEST_UART_SEND_str("\n");
    487e:	84 e9       	ldi	r24, 0x94	; 148
    4880:	91 e0       	ldi	r25, 0x01	; 1
    4882:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	NRF_STOP_RX_MODE();
    4886:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
	if (!PROTOCOL_CHECK_RECIVED_PACKET(PACKET_TEMP, SENSOR_ADDRESS,RX_LENGTH,SESSION_KEY))
    488a:	96 01       	movw	r18, r12
    488c:	4f 85       	ldd	r20, Y+15	; 0x0f
    488e:	b5 01       	movw	r22, r10
    4890:	ce 01       	movw	r24, r28
    4892:	01 96       	adiw	r24, 0x01	; 1
    4894:	be db       	rcall	.-2180   	; 0x4012 <PROTOCOL_CHECK_RECIVED_PACKET>
    4896:	88 23       	and	r24, r24
    4898:	29 f0       	breq	.+10     	; 0x48a4 <PROTOCOL_DATA_SEND+0x150>
	{
		return 0;
	}
	if(PACKET_TEMP[7]!=DATA_CHANGED_CODE)
    489a:	81 e0       	ldi	r24, 0x01	; 1
    489c:	98 85       	ldd	r25, Y+8	; 0x08
    489e:	91 31       	cpi	r25, 0x11	; 17
    48a0:	09 f0       	breq	.+2      	; 0x48a4 <PROTOCOL_DATA_SEND+0x150>
    48a2:	80 e0       	ldi	r24, 0x00	; 0
	{
		return 0;
	}
	return 1;
}
    48a4:	6d 96       	adiw	r28, 0x1d	; 29
    48a6:	0f b6       	in	r0, 0x3f	; 63
    48a8:	f8 94       	cli
    48aa:	de bf       	out	0x3e, r29	; 62
    48ac:	0f be       	out	0x3f, r0	; 63
    48ae:	cd bf       	out	0x3d, r28	; 61
    48b0:	df 91       	pop	r29
    48b2:	cf 91       	pop	r28
    48b4:	1f 91       	pop	r17
    48b6:	0f 91       	pop	r16
    48b8:	ff 90       	pop	r15
    48ba:	ef 90       	pop	r14
    48bc:	df 90       	pop	r13
    48be:	cf 90       	pop	r12
    48c0:	bf 90       	pop	r11
    48c2:	af 90       	pop	r10
    48c4:	9f 90       	pop	r9
    48c6:	8f 90       	pop	r8
    48c8:	7f 90       	pop	r7
    48ca:	6f 90       	pop	r6
    48cc:	5f 90       	pop	r5
    48ce:	4f 90       	pop	r4
    48d0:	3f 90       	pop	r3
    48d2:	2f 90       	pop	r2
    48d4:	08 95       	ret

000048d6 <PROTOCOL_DATA_READ>:

unsigned char PROTOCOL_DATA_READ(unsigned char*SENSOR_ADDRESS,unsigned char SENSOR_VERSION,unsigned char SENSOR_ADDRESS_LENGTH,unsigned char*SESSION_KEY,unsigned char *REGISTER_ADDRESS,unsigned char*DATA_READ_BUFFER)
{
    48d6:	2f 92       	push	r2
    48d8:	3f 92       	push	r3
    48da:	4f 92       	push	r4
    48dc:	5f 92       	push	r5
    48de:	6f 92       	push	r6
    48e0:	7f 92       	push	r7
    48e2:	8f 92       	push	r8
    48e4:	9f 92       	push	r9
    48e6:	af 92       	push	r10
    48e8:	bf 92       	push	r11
    48ea:	cf 92       	push	r12
    48ec:	df 92       	push	r13
    48ee:	ef 92       	push	r14
    48f0:	ff 92       	push	r15
    48f2:	0f 93       	push	r16
    48f4:	1f 93       	push	r17
    48f6:	cf 93       	push	r28
    48f8:	df 93       	push	r29
    48fa:	cd b7       	in	r28, 0x3d	; 61
    48fc:	de b7       	in	r29, 0x3e	; 62
    48fe:	69 97       	sbiw	r28, 0x19	; 25
    4900:	0f b6       	in	r0, 0x3f	; 63
    4902:	f8 94       	cli
    4904:	de bf       	out	0x3e, r29	; 62
    4906:	0f be       	out	0x3f, r0	; 63
    4908:	cd bf       	out	0x3d, r28	; 61
    490a:	5c 01       	movw	r10, r24
    490c:	94 2e       	mov	r9, r20
    490e:	69 01       	movw	r12, r18
	unsigned char PACKET_TEMP[14];
	unsigned char i,RX_LENGTH;
	unsigned char HASH_VALUE[2];
	volatile unsigned long COUNT_TIMER=0;
    4910:	1a 8a       	std	Y+18, r1	; 0x12
    4912:	1b 8a       	std	Y+19, r1	; 0x13
    4914:	1c 8a       	std	Y+20, r1	; 0x14
    4916:	1d 8a       	std	Y+21, r1	; 0x15
	
	
	
	/*********READ DATA**********/
	PACKET_TEMP[0]=12|0B00000000;
    4918:	8c e0       	ldi	r24, 0x0C	; 12
    491a:	89 83       	std	Y+1, r24	; 0x01
	PACKET_TEMP[1]=SENSOR_VERSION;
    491c:	6a 83       	std	Y+2, r22	; 0x02
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    491e:	44 23       	and	r20, r20
    4920:	59 f0       	breq	.+22     	; 0x4938 <PROTOCOL_DATA_READ+0x62>
    4922:	8a e0       	ldi	r24, 0x0A	; 10
    4924:	91 e0       	ldi	r25, 0x01	; 1
    4926:	de 01       	movw	r26, r28
    4928:	13 96       	adiw	r26, 0x03	; 3
    492a:	fc 01       	movw	r30, r24
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
    492c:	21 91       	ld	r18, Z+
    492e:	2d 93       	st	X+, r18
    4930:	2e 2f       	mov	r18, r30
    4932:	28 1b       	sub	r18, r24
	
	
	/*********READ DATA**********/
	PACKET_TEMP[0]=12|0B00000000;
	PACKET_TEMP[1]=SENSOR_VERSION;
	for (i=0;i<SENSOR_ADDRESS_LENGTH;i++)
    4934:	29 15       	cp	r18, r9
    4936:	d0 f3       	brcs	.-12     	; 0x492c <PROTOCOL_DATA_READ+0x56>
	{
		PACKET_TEMP[2+i]=MY_ADDRESS[i];
	}
	PACKET_TEMP[7]=MASTER_NEEDS_DATA_CODE;
    4938:	82 e1       	ldi	r24, 0x12	; 18
    493a:	88 87       	std	Y+8, r24	; 0x08
	unsigned char PLAIN_TEXT[2],CIPHER_TEXT[2];
	PLAIN_TEXT[0]=REGISTER_ADDRESS[0];
    493c:	f8 01       	movw	r30, r16
    493e:	80 81       	ld	r24, Z
    4940:	8e 8b       	std	Y+22, r24	; 0x16
	PLAIN_TEXT[1]=REGISTER_ADDRESS[1];
    4942:	81 81       	ldd	r24, Z+1	; 0x01
    4944:	8f 8b       	std	Y+23, r24	; 0x17
	ENCRYPT_ALGORISM_1_V1(PLAIN_TEXT,CIPHER_TEXT,2,SESSION_KEY);
    4946:	96 01       	movw	r18, r12
    4948:	42 e0       	ldi	r20, 0x02	; 2
    494a:	be 01       	movw	r22, r28
    494c:	68 5e       	subi	r22, 0xE8	; 232
    494e:	7f 4f       	sbci	r23, 0xFF	; 255
    4950:	ce 01       	movw	r24, r28
    4952:	46 96       	adiw	r24, 0x16	; 22
    4954:	84 d0       	rcall	.+264    	; 0x4a5e <ENCRYPT_ALGORISM_1_V1>
	PACKET_TEMP[8]=CIPHER_TEXT[0];
    4956:	88 8d       	ldd	r24, Y+24	; 0x18
    4958:	89 87       	std	Y+9, r24	; 0x09
	PACKET_TEMP[9]=CIPHER_TEXT[1];
    495a:	89 8d       	ldd	r24, Y+25	; 0x19
    495c:	8a 87       	std	Y+10, r24	; 0x0a
	HASH_SESSION_KEY(PACKET_TEMP,HASH_VALUE,10,SESSION_KEY);
    495e:	96 01       	movw	r18, r12
    4960:	4a e0       	ldi	r20, 0x0A	; 10
    4962:	be 01       	movw	r22, r28
    4964:	60 5f       	subi	r22, 0xF0	; 240
    4966:	7f 4f       	sbci	r23, 0xFF	; 255
    4968:	ce 01       	movw	r24, r28
    496a:	01 96       	adiw	r24, 0x01	; 1
    496c:	ea d0       	rcall	.+468    	; 0x4b42 <HASH_SESSION_KEY>
	PACKET_TEMP[10]=HASH_VALUE[0];
    496e:	88 89       	ldd	r24, Y+16	; 0x10
    4970:	8b 87       	std	Y+11, r24	; 0x0b
	PACKET_TEMP[11]=HASH_VALUE[1];
    4972:	89 89       	ldd	r24, Y+17	; 0x11
    4974:	8c 87       	std	Y+12, r24	; 0x0c
	if (!NRF_SEND_DATA_WITH_ACK(SENSOR_ADDRESS,SENSOR_ADDRESS_LENGTH,PACKET_TEMP,12))
    4976:	2c e0       	ldi	r18, 0x0C	; 12
    4978:	ae 01       	movw	r20, r28
    497a:	4f 5f       	subi	r20, 0xFF	; 255
    497c:	5f 4f       	sbci	r21, 0xFF	; 255
    497e:	69 2d       	mov	r22, r9
    4980:	c5 01       	movw	r24, r10
    4982:	0e 94 5b 11 	call	0x22b6	; 0x22b6 <NRF_SEND_DATA_WITH_ACK>
    4986:	88 23       	and	r24, r24
    4988:	09 f4       	brne	.+2      	; 0x498c <PROTOCOL_DATA_READ+0xb6>
    498a:	50 c0       	rjmp	.+160    	; 0x4a2c <PROTOCOL_DATA_READ+0x156>
	}
	/*****************************************************************************************/
	
	
	/******************************DATA READ*******************************************/
	NRF_START_RX_MODE();
    498c:	0e 94 ad 11 	call	0x235a	; 0x235a <NRF_START_RX_MODE>
	if(pdPASS!=xSemaphoreTake(NRF_IRQ_SEMAPHORE,pdMS_TO_TICKS(3000)))
    4990:	4c e2       	ldi	r20, 0x2C	; 44
    4992:	51 e0       	ldi	r21, 0x01	; 1
    4994:	60 e0       	ldi	r22, 0x00	; 0
    4996:	70 e0       	ldi	r23, 0x00	; 0
    4998:	80 91 de 0c 	lds	r24, 0x0CDE
    499c:	90 91 df 0c 	lds	r25, 0x0CDF
    49a0:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    49a4:	81 30       	cpi	r24, 0x01	; 1
    49a6:	41 f0       	breq	.+16     	; 0x49b8 <PROTOCOL_DATA_READ+0xe2>
	{
		TEST_UART_SEND_str("BEACON FAIL\n");
    49a8:	82 ec       	ldi	r24, 0xC2	; 194
    49aa:	92 e0       	ldi	r25, 0x02	; 2
    49ac:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
		NRF_STOP_RX_MODE();
    49b0:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
		return 0;
    49b4:	80 e0       	ldi	r24, 0x00	; 0
    49b6:	3a c0       	rjmp	.+116    	; 0x4a2c <PROTOCOL_DATA_READ+0x156>
	}
	
	NRF_CHECK_RX_PL(PACKET_TEMP,&RX_LENGTH);
    49b8:	be 01       	movw	r22, r28
    49ba:	61 5f       	subi	r22, 0xF1	; 241
    49bc:	7f 4f       	sbci	r23, 0xFF	; 255
    49be:	ce 01       	movw	r24, r28
    49c0:	01 96       	adiw	r24, 0x01	; 1
    49c2:	0e 94 c5 11 	call	0x238a	; 0x238a <NRF_CHECK_RX_PL>
	
	TEST_UART_SEND_str("counter=");
    49c6:	87 ea       	ldi	r24, 0xA7	; 167
    49c8:	92 e0       	ldi	r25, 0x02	; 2
    49ca:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	TEST_UART_SEND_VALUE(COUNT_TIMER);
    49ce:	8a 89       	ldd	r24, Y+18	; 0x12
    49d0:	9b 89       	ldd	r25, Y+19	; 0x13
    49d2:	ac 89       	ldd	r26, Y+20	; 0x14
    49d4:	bd 89       	ldd	r27, Y+21	; 0x15
    49d6:	1c 01       	movw	r2, r24
    49d8:	2d 01       	movw	r4, r26
    49da:	28 2f       	mov	r18, r24
    49dc:	33 2d       	mov	r19, r3
    49de:	44 2d       	mov	r20, r4
    49e0:	55 2d       	mov	r21, r5
    49e2:	60 e0       	ldi	r22, 0x00	; 0
    49e4:	70 e0       	ldi	r23, 0x00	; 0
    49e6:	80 e0       	ldi	r24, 0x00	; 0
    49e8:	90 e0       	ldi	r25, 0x00	; 0
    49ea:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
	TEST_UART_SEND_str("\n");
    49ee:	84 e9       	ldi	r24, 0x94	; 148
    49f0:	91 e0       	ldi	r25, 0x01	; 1
    49f2:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
	NRF_STOP_RX_MODE();
    49f6:	0e 94 ba 11 	call	0x2374	; 0x2374 <NRF_STOP_RX_MODE>
	if (!PROTOCOL_CHECK_RECIVED_PACKET(PACKET_TEMP, SENSOR_ADDRESS,RX_LENGTH,SESSION_KEY))
    49fa:	96 01       	movw	r18, r12
    49fc:	4f 85       	ldd	r20, Y+15	; 0x0f
    49fe:	b5 01       	movw	r22, r10
    4a00:	ce 01       	movw	r24, r28
    4a02:	01 96       	adiw	r24, 0x01	; 1
    4a04:	06 db       	rcall	.-2548   	; 0x4012 <PROTOCOL_CHECK_RECIVED_PACKET>
    4a06:	88 23       	and	r24, r24
    4a08:	89 f0       	breq	.+34     	; 0x4a2c <PROTOCOL_DATA_READ+0x156>
	{
		return 0;
	}
	if(PACKET_TEMP[7]!=DATA_READ_CODE)
    4a0a:	88 85       	ldd	r24, Y+8	; 0x08
    4a0c:	83 31       	cpi	r24, 0x13	; 19
    4a0e:	69 f4       	brne	.+26     	; 0x4a2a <PROTOCOL_DATA_READ+0x154>
	{
		return 0;
	}
	CIPHER_TEXT[0]=PACKET_TEMP[8];
    4a10:	89 85       	ldd	r24, Y+9	; 0x09
    4a12:	88 8f       	std	Y+24, r24	; 0x18
	CIPHER_TEXT[1]=PACKET_TEMP[9];
    4a14:	8a 85       	ldd	r24, Y+10	; 0x0a
    4a16:	89 8f       	std	Y+25, r24	; 0x19
	DECRYPT_ALGORISM_1_V1(DATA_READ_BUFFER,CIPHER_TEXT,2,SESSION_KEY);
    4a18:	96 01       	movw	r18, r12
    4a1a:	42 e0       	ldi	r20, 0x02	; 2
    4a1c:	be 01       	movw	r22, r28
    4a1e:	68 5e       	subi	r22, 0xE8	; 232
    4a20:	7f 4f       	sbci	r23, 0xFF	; 255
    4a22:	c7 01       	movw	r24, r14
    4a24:	3a d0       	rcall	.+116    	; 0x4a9a <DECRYPT_ALGORISM_1_V1>
	return 1;
    4a26:	81 e0       	ldi	r24, 0x01	; 1
    4a28:	01 c0       	rjmp	.+2      	; 0x4a2c <PROTOCOL_DATA_READ+0x156>
	{
		return 0;
	}
	if(PACKET_TEMP[7]!=DATA_READ_CODE)
	{
		return 0;
    4a2a:	80 e0       	ldi	r24, 0x00	; 0
	}
	CIPHER_TEXT[0]=PACKET_TEMP[8];
	CIPHER_TEXT[1]=PACKET_TEMP[9];
	DECRYPT_ALGORISM_1_V1(DATA_READ_BUFFER,CIPHER_TEXT,2,SESSION_KEY);
	return 1;
}
    4a2c:	69 96       	adiw	r28, 0x19	; 25
    4a2e:	0f b6       	in	r0, 0x3f	; 63
    4a30:	f8 94       	cli
    4a32:	de bf       	out	0x3e, r29	; 62
    4a34:	0f be       	out	0x3f, r0	; 63
    4a36:	cd bf       	out	0x3d, r28	; 61
    4a38:	df 91       	pop	r29
    4a3a:	cf 91       	pop	r28
    4a3c:	1f 91       	pop	r17
    4a3e:	0f 91       	pop	r16
    4a40:	ff 90       	pop	r15
    4a42:	ef 90       	pop	r14
    4a44:	df 90       	pop	r13
    4a46:	cf 90       	pop	r12
    4a48:	bf 90       	pop	r11
    4a4a:	af 90       	pop	r10
    4a4c:	9f 90       	pop	r9
    4a4e:	8f 90       	pop	r8
    4a50:	7f 90       	pop	r7
    4a52:	6f 90       	pop	r6
    4a54:	5f 90       	pop	r5
    4a56:	4f 90       	pop	r4
    4a58:	3f 90       	pop	r3
    4a5a:	2f 90       	pop	r2
    4a5c:	08 95       	ret

00004a5e <ENCRYPT_ALGORISM_1_V1>:
 */ 
#include "SECURITY_DRIVER.h"


void ENCRYPT_ALGORISM_1_V1(unsigned char *PLAIN_TEXT,unsigned char *CIPHER_TEXT,unsigned char LENGTH,unsigned char*SESSION_KEY)
{
    4a5e:	0f 93       	push	r16
    4a60:	1f 93       	push	r17
    4a62:	cf 93       	push	r28
    4a64:	df 93       	push	r29
	unsigned char i;
	for (i=0;i<LENGTH;i++)
    4a66:	44 23       	and	r20, r20
    4a68:	99 f0       	breq	.+38     	; 0x4a90 <ENCRYPT_ALGORISM_1_V1+0x32>
    4a6a:	c8 2f       	mov	r28, r24
    4a6c:	d9 2f       	mov	r29, r25
    4a6e:	a6 2f       	mov	r26, r22
    4a70:	b7 2f       	mov	r27, r23
    4a72:	50 e0       	ldi	r21, 0x00	; 0
	{
		CIPHER_TEXT[i]=PLAIN_TEXT[i]^(SESSION_KEY[i%SESSION_KEY_SIZE_V1]);
    4a74:	69 91       	ld	r22, Y+
    4a76:	05 2f       	mov	r16, r21
    4a78:	01 70       	andi	r16, 0x01	; 1
    4a7a:	10 e0       	ldi	r17, 0x00	; 0
    4a7c:	c9 01       	movw	r24, r18
    4a7e:	80 0f       	add	r24, r16
    4a80:	91 1f       	adc	r25, r17
    4a82:	fc 01       	movw	r30, r24
    4a84:	80 81       	ld	r24, Z
    4a86:	86 27       	eor	r24, r22
    4a88:	8d 93       	st	X+, r24


void ENCRYPT_ALGORISM_1_V1(unsigned char *PLAIN_TEXT,unsigned char *CIPHER_TEXT,unsigned char LENGTH,unsigned char*SESSION_KEY)
{
	unsigned char i;
	for (i=0;i<LENGTH;i++)
    4a8a:	5f 5f       	subi	r21, 0xFF	; 255
    4a8c:	54 13       	cpse	r21, r20
    4a8e:	f2 cf       	rjmp	.-28     	; 0x4a74 <ENCRYPT_ALGORISM_1_V1+0x16>
	{
		CIPHER_TEXT[i]=PLAIN_TEXT[i]^(SESSION_KEY[i%SESSION_KEY_SIZE_V1]);
	}
}
    4a90:	df 91       	pop	r29
    4a92:	cf 91       	pop	r28
    4a94:	1f 91       	pop	r17
    4a96:	0f 91       	pop	r16
    4a98:	08 95       	ret

00004a9a <DECRYPT_ALGORISM_1_V1>:

void DECRYPT_ALGORISM_1_V1(unsigned char *PLAIN_TEXT,unsigned char *CIPHER_TEXT,unsigned char LENGTH,unsigned char*SESSION_KEY)
{
    4a9a:	0f 93       	push	r16
    4a9c:	1f 93       	push	r17
    4a9e:	cf 93       	push	r28
    4aa0:	df 93       	push	r29
	unsigned char i;
	for (i=0;i<LENGTH;i++)
    4aa2:	44 23       	and	r20, r20
    4aa4:	99 f0       	breq	.+38     	; 0x4acc <DECRYPT_ALGORISM_1_V1+0x32>
    4aa6:	c6 2f       	mov	r28, r22
    4aa8:	d7 2f       	mov	r29, r23
    4aaa:	a8 2f       	mov	r26, r24
    4aac:	b9 2f       	mov	r27, r25
    4aae:	50 e0       	ldi	r21, 0x00	; 0
	{
		PLAIN_TEXT[i]=CIPHER_TEXT[i]^(SESSION_KEY[i%SESSION_KEY_SIZE_V1]);
    4ab0:	69 91       	ld	r22, Y+
    4ab2:	05 2f       	mov	r16, r21
    4ab4:	01 70       	andi	r16, 0x01	; 1
    4ab6:	10 e0       	ldi	r17, 0x00	; 0
    4ab8:	c9 01       	movw	r24, r18
    4aba:	80 0f       	add	r24, r16
    4abc:	91 1f       	adc	r25, r17
    4abe:	fc 01       	movw	r30, r24
    4ac0:	80 81       	ld	r24, Z
    4ac2:	86 27       	eor	r24, r22
    4ac4:	8d 93       	st	X+, r24
}

void DECRYPT_ALGORISM_1_V1(unsigned char *PLAIN_TEXT,unsigned char *CIPHER_TEXT,unsigned char LENGTH,unsigned char*SESSION_KEY)
{
	unsigned char i;
	for (i=0;i<LENGTH;i++)
    4ac6:	5f 5f       	subi	r21, 0xFF	; 255
    4ac8:	54 13       	cpse	r21, r20
    4aca:	f2 cf       	rjmp	.-28     	; 0x4ab0 <DECRYPT_ALGORISM_1_V1+0x16>
	{
		PLAIN_TEXT[i]=CIPHER_TEXT[i]^(SESSION_KEY[i%SESSION_KEY_SIZE_V1]);
	}
}
    4acc:	df 91       	pop	r29
    4ace:	cf 91       	pop	r28
    4ad0:	1f 91       	pop	r17
    4ad2:	0f 91       	pop	r16
    4ad4:	08 95       	ret

00004ad6 <ENCRYPT_ALGORISM_2_V1>:

void ENCRYPT_ALGORISM_2_V1(unsigned char *PLAIN_TEXT,unsigned char *CIPHER_TEXT,unsigned char LENGTH,unsigned char*PASSWORD_KEY)
{
    4ad6:	cf 93       	push	r28
    4ad8:	df 93       	push	r29
    4ada:	f9 01       	movw	r30, r18
		unsigned char i;
		for (i=0;i<LENGTH;i++)
    4adc:	44 23       	and	r20, r20
    4ade:	99 f0       	breq	.+38     	; 0x4b06 <ENCRYPT_ALGORISM_2_V1+0x30>
    4ae0:	38 2f       	mov	r19, r24
    4ae2:	c6 2f       	mov	r28, r22
    4ae4:	d7 2f       	mov	r29, r23
    4ae6:	a8 2f       	mov	r26, r24
    4ae8:	b9 2f       	mov	r27, r25
		{
			CIPHER_TEXT[i]=PLAIN_TEXT[i]^(PASSWORD_KEY[0]^PASSWORD_KEY[1]^PASSWORD_KEY[2]^PASSWORD_KEY[3]);/*PASSWORD SIZE 4*/
    4aea:	9d 91       	ld	r25, X+
    4aec:	21 81       	ldd	r18, Z+1	; 0x01
    4aee:	80 81       	ld	r24, Z
    4af0:	82 27       	eor	r24, r18
    4af2:	22 81       	ldd	r18, Z+2	; 0x02
    4af4:	82 27       	eor	r24, r18
    4af6:	23 81       	ldd	r18, Z+3	; 0x03
    4af8:	82 27       	eor	r24, r18
    4afa:	89 27       	eor	r24, r25
    4afc:	89 93       	st	Y+, r24
    4afe:	8a 2f       	mov	r24, r26
    4b00:	83 1b       	sub	r24, r19
}

void ENCRYPT_ALGORISM_2_V1(unsigned char *PLAIN_TEXT,unsigned char *CIPHER_TEXT,unsigned char LENGTH,unsigned char*PASSWORD_KEY)
{
		unsigned char i;
		for (i=0;i<LENGTH;i++)
    4b02:	84 17       	cp	r24, r20
    4b04:	90 f3       	brcs	.-28     	; 0x4aea <ENCRYPT_ALGORISM_2_V1+0x14>
		{
			CIPHER_TEXT[i]=PLAIN_TEXT[i]^(PASSWORD_KEY[0]^PASSWORD_KEY[1]^PASSWORD_KEY[2]^PASSWORD_KEY[3]);/*PASSWORD SIZE 4*/
		}
}
    4b06:	df 91       	pop	r29
    4b08:	cf 91       	pop	r28
    4b0a:	08 95       	ret

00004b0c <DECRYPT_ALGORISM_2_V1>:

void DECRYPT_ALGORISM_2_V1(unsigned char *PLAIN_TEXT,unsigned char *CIPHER_TEXT,unsigned char LENGTH,unsigned char*PASSWORD_KEY)
{
    4b0c:	cf 93       	push	r28
    4b0e:	df 93       	push	r29
    4b10:	f9 01       	movw	r30, r18
	unsigned char i;
	for (i=0;i<LENGTH;i++)
    4b12:	44 23       	and	r20, r20
    4b14:	99 f0       	breq	.+38     	; 0x4b3c <DECRYPT_ALGORISM_2_V1+0x30>
    4b16:	36 2f       	mov	r19, r22
    4b18:	c8 2f       	mov	r28, r24
    4b1a:	d9 2f       	mov	r29, r25
    4b1c:	a6 2f       	mov	r26, r22
    4b1e:	b7 2f       	mov	r27, r23
	{
		PLAIN_TEXT[i]=CIPHER_TEXT[i]^(PASSWORD_KEY[0]^PASSWORD_KEY[1]^PASSWORD_KEY[2]^PASSWORD_KEY[3]);/*PASSWORD SIZE 4*/
    4b20:	9d 91       	ld	r25, X+
    4b22:	21 81       	ldd	r18, Z+1	; 0x01
    4b24:	80 81       	ld	r24, Z
    4b26:	82 27       	eor	r24, r18
    4b28:	22 81       	ldd	r18, Z+2	; 0x02
    4b2a:	82 27       	eor	r24, r18
    4b2c:	23 81       	ldd	r18, Z+3	; 0x03
    4b2e:	82 27       	eor	r24, r18
    4b30:	89 27       	eor	r24, r25
    4b32:	89 93       	st	Y+, r24
    4b34:	8a 2f       	mov	r24, r26
    4b36:	83 1b       	sub	r24, r19
}

void DECRYPT_ALGORISM_2_V1(unsigned char *PLAIN_TEXT,unsigned char *CIPHER_TEXT,unsigned char LENGTH,unsigned char*PASSWORD_KEY)
{
	unsigned char i;
	for (i=0;i<LENGTH;i++)
    4b38:	84 17       	cp	r24, r20
    4b3a:	90 f3       	brcs	.-28     	; 0x4b20 <DECRYPT_ALGORISM_2_V1+0x14>
	{
		PLAIN_TEXT[i]=CIPHER_TEXT[i]^(PASSWORD_KEY[0]^PASSWORD_KEY[1]^PASSWORD_KEY[2]^PASSWORD_KEY[3]);/*PASSWORD SIZE 4*/
	}
}
    4b3c:	df 91       	pop	r29
    4b3e:	cf 91       	pop	r28
    4b40:	08 95       	ret

00004b42 <HASH_SESSION_KEY>:

void HASH_SESSION_KEY(unsigned char *DATA_TO_BE_HASHED,unsigned char *HASH_VALUE,unsigned char LENGTH,unsigned char*SESSION_KEY)
{
    4b42:	3f 92       	push	r3
    4b44:	4f 92       	push	r4
    4b46:	5f 92       	push	r5
    4b48:	6f 92       	push	r6
    4b4a:	7f 92       	push	r7
    4b4c:	8f 92       	push	r8
    4b4e:	9f 92       	push	r9
    4b50:	af 92       	push	r10
    4b52:	bf 92       	push	r11
    4b54:	cf 92       	push	r12
    4b56:	df 92       	push	r13
    4b58:	ef 92       	push	r14
    4b5a:	ff 92       	push	r15
    4b5c:	0f 93       	push	r16
    4b5e:	1f 93       	push	r17
    4b60:	cf 93       	push	r28
    4b62:	df 93       	push	r29
    4b64:	8c 01       	movw	r16, r24
    4b66:	7b 01       	movw	r14, r22
    4b68:	34 2e       	mov	r3, r20
    4b6a:	69 01       	movw	r12, r18
			unsigned short TEMP_HASH_VALUE;
			unsigned long HASH_ODD=1;
			unsigned long HASH_EVEN=1;
			unsigned char i;
			for (i=0;i<LENGTH;i=i+2)
    4b6c:	44 23       	and	r20, r20
    4b6e:	09 f4       	brne	.+2      	; 0x4b72 <HASH_SESSION_KEY+0x30>
    4b70:	44 c0       	rjmp	.+136    	; 0x4bfa <HASH_SESSION_KEY+0xb8>
    4b72:	c0 e0       	ldi	r28, 0x00	; 0
}

void HASH_SESSION_KEY(unsigned char *DATA_TO_BE_HASHED,unsigned char *HASH_VALUE,unsigned char LENGTH,unsigned char*SESSION_KEY)
{
			unsigned short TEMP_HASH_VALUE;
			unsigned long HASH_ODD=1;
    4b74:	81 2c       	mov	r8, r1
    4b76:	91 2c       	mov	r9, r1
    4b78:	54 01       	movw	r10, r8
    4b7a:	83 94       	inc	r8
			unsigned long HASH_EVEN=1;
			unsigned char i;
			for (i=0;i<LENGTH;i=i+2)
			{
				HASH_ODD=(HASH_ODD*DATA_TO_BE_HASHED[i])%0xffff;
    4b7c:	44 24       	eor	r4, r4
    4b7e:	4a 94       	dec	r4
    4b80:	54 2c       	mov	r5, r4
    4b82:	61 2c       	mov	r6, r1
    4b84:	71 2c       	mov	r7, r1
    4b86:	f8 01       	movw	r30, r16
    4b88:	ec 0f       	add	r30, r28
    4b8a:	f1 1d       	adc	r31, r1
    4b8c:	a0 81       	ld	r26, Z
    4b8e:	b0 e0       	ldi	r27, 0x00	; 0
    4b90:	a5 01       	movw	r20, r10
    4b92:	94 01       	movw	r18, r8
    4b94:	0e 94 41 42 	call	0x8482	; 0x8482 <__muluhisi3>
    4b98:	a3 01       	movw	r20, r6
    4b9a:	92 01       	movw	r18, r4
    4b9c:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
    4ba0:	4b 01       	movw	r8, r22
    4ba2:	5c 01       	movw	r10, r24
{
			unsigned short TEMP_HASH_VALUE;
			unsigned long HASH_ODD=1;
			unsigned long HASH_EVEN=1;
			unsigned char i;
			for (i=0;i<LENGTH;i=i+2)
    4ba4:	ce 5f       	subi	r28, 0xFE	; 254
    4ba6:	c3 15       	cp	r28, r3
    4ba8:	70 f3       	brcs	.-36     	; 0x4b86 <HASH_SESSION_KEY+0x44>
			{
				HASH_ODD=(HASH_ODD*DATA_TO_BE_HASHED[i])%0xffff;
			}
			for (i=1;i<LENGTH;i=i+2)
    4baa:	81 e0       	ldi	r24, 0x01	; 1
    4bac:	83 15       	cp	r24, r3
    4bae:	70 f5       	brcc	.+92     	; 0x4c0c <HASH_SESSION_KEY+0xca>
    4bb0:	e8 01       	movw	r28, r16
    4bb2:	21 96       	adiw	r28, 0x01	; 1
    4bb4:	0d 5f       	subi	r16, 0xFD	; 253
    4bb6:	1f 4f       	sbci	r17, 0xFF	; 255
    4bb8:	3a 94       	dec	r3
    4bba:	3a 94       	dec	r3
    4bbc:	36 94       	lsr	r3
    4bbe:	83 2d       	mov	r24, r3
    4bc0:	90 e0       	ldi	r25, 0x00	; 0
    4bc2:	88 0f       	add	r24, r24
    4bc4:	99 1f       	adc	r25, r25
    4bc6:	08 0f       	add	r16, r24
    4bc8:	19 1f       	adc	r17, r25
    4bca:	61 e0       	ldi	r22, 0x01	; 1
    4bcc:	70 e0       	ldi	r23, 0x00	; 0
    4bce:	80 e0       	ldi	r24, 0x00	; 0
    4bd0:	90 e0       	ldi	r25, 0x00	; 0
			{
				HASH_EVEN=(HASH_EVEN*DATA_TO_BE_HASHED[i])%0xffff;
    4bd2:	44 24       	eor	r4, r4
    4bd4:	4a 94       	dec	r4
    4bd6:	54 2c       	mov	r5, r4
    4bd8:	61 2c       	mov	r6, r1
    4bda:	71 2c       	mov	r7, r1
    4bdc:	a8 81       	ld	r26, Y
    4bde:	b0 e0       	ldi	r27, 0x00	; 0
    4be0:	9b 01       	movw	r18, r22
    4be2:	ac 01       	movw	r20, r24
    4be4:	0e 94 41 42 	call	0x8482	; 0x8482 <__muluhisi3>
    4be8:	a3 01       	movw	r20, r6
    4bea:	92 01       	movw	r18, r4
    4bec:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
    4bf0:	22 96       	adiw	r28, 0x02	; 2
			unsigned char i;
			for (i=0;i<LENGTH;i=i+2)
			{
				HASH_ODD=(HASH_ODD*DATA_TO_BE_HASHED[i])%0xffff;
			}
			for (i=1;i<LENGTH;i=i+2)
    4bf2:	c0 17       	cp	r28, r16
    4bf4:	d1 07       	cpc	r29, r17
    4bf6:	91 f7       	brne	.-28     	; 0x4bdc <HASH_SESSION_KEY+0x9a>
    4bf8:	0d c0       	rjmp	.+26     	; 0x4c14 <HASH_SESSION_KEY+0xd2>
}

void HASH_SESSION_KEY(unsigned char *DATA_TO_BE_HASHED,unsigned char *HASH_VALUE,unsigned char LENGTH,unsigned char*SESSION_KEY)
{
			unsigned short TEMP_HASH_VALUE;
			unsigned long HASH_ODD=1;
    4bfa:	81 2c       	mov	r8, r1
    4bfc:	91 2c       	mov	r9, r1
    4bfe:	54 01       	movw	r10, r8
    4c00:	83 94       	inc	r8
			unsigned long HASH_EVEN=1;
			unsigned char i;
			for (i=0;i<LENGTH;i=i+2)
    4c02:	61 e0       	ldi	r22, 0x01	; 1
    4c04:	70 e0       	ldi	r23, 0x00	; 0
    4c06:	80 e0       	ldi	r24, 0x00	; 0
    4c08:	90 e0       	ldi	r25, 0x00	; 0
    4c0a:	04 c0       	rjmp	.+8      	; 0x4c14 <HASH_SESSION_KEY+0xd2>
			{
				HASH_ODD=(HASH_ODD*DATA_TO_BE_HASHED[i])%0xffff;
			}
			for (i=1;i<LENGTH;i=i+2)
    4c0c:	61 e0       	ldi	r22, 0x01	; 1
    4c0e:	70 e0       	ldi	r23, 0x00	; 0
    4c10:	80 e0       	ldi	r24, 0x00	; 0
    4c12:	90 e0       	ldi	r25, 0x00	; 0
			{
				HASH_EVEN=(HASH_EVEN*DATA_TO_BE_HASHED[i])%0xffff;
			}
			TEMP_HASH_VALUE=(HASH_ODD^HASH_EVEN)%0xffff;
    4c14:	68 25       	eor	r22, r8
    4c16:	79 25       	eor	r23, r9
    4c18:	8a 25       	eor	r24, r10
    4c1a:	9b 25       	eor	r25, r11
    4c1c:	2f ef       	ldi	r18, 0xFF	; 255
    4c1e:	3f ef       	ldi	r19, 0xFF	; 255
    4c20:	40 e0       	ldi	r20, 0x00	; 0
    4c22:	50 e0       	ldi	r21, 0x00	; 0
    4c24:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
			HASH_VALUE[0]=(TEMP_HASH_VALUE>>8)^SESSION_KEY[0];
    4c28:	f6 01       	movw	r30, r12
    4c2a:	80 81       	ld	r24, Z
    4c2c:	78 27       	eor	r23, r24
    4c2e:	f7 01       	movw	r30, r14
    4c30:	70 83       	st	Z, r23
			HASH_VALUE[1]=(TEMP_HASH_VALUE&0x00ff)^SESSION_KEY[1];
    4c32:	f6 01       	movw	r30, r12
    4c34:	81 81       	ldd	r24, Z+1	; 0x01
    4c36:	68 27       	eor	r22, r24
    4c38:	f7 01       	movw	r30, r14
    4c3a:	61 83       	std	Z+1, r22	; 0x01
				
}
    4c3c:	df 91       	pop	r29
    4c3e:	cf 91       	pop	r28
    4c40:	1f 91       	pop	r17
    4c42:	0f 91       	pop	r16
    4c44:	ff 90       	pop	r15
    4c46:	ef 90       	pop	r14
    4c48:	df 90       	pop	r13
    4c4a:	cf 90       	pop	r12
    4c4c:	bf 90       	pop	r11
    4c4e:	af 90       	pop	r10
    4c50:	9f 90       	pop	r9
    4c52:	8f 90       	pop	r8
    4c54:	7f 90       	pop	r7
    4c56:	6f 90       	pop	r6
    4c58:	5f 90       	pop	r5
    4c5a:	4f 90       	pop	r4
    4c5c:	3f 90       	pop	r3
    4c5e:	08 95       	ret

00004c60 <HASH_PASWORD_KEY>:

void HASH_PASWORD_KEY(unsigned char *DATA_TO_BE_HASHED,unsigned char *HASH_VALUE,unsigned char LENGTH,unsigned char*PASSWORD_KEY)
{
    4c60:	3f 92       	push	r3
    4c62:	4f 92       	push	r4
    4c64:	5f 92       	push	r5
    4c66:	6f 92       	push	r6
    4c68:	7f 92       	push	r7
    4c6a:	8f 92       	push	r8
    4c6c:	9f 92       	push	r9
    4c6e:	af 92       	push	r10
    4c70:	bf 92       	push	r11
    4c72:	cf 92       	push	r12
    4c74:	df 92       	push	r13
    4c76:	ef 92       	push	r14
    4c78:	ff 92       	push	r15
    4c7a:	0f 93       	push	r16
    4c7c:	1f 93       	push	r17
    4c7e:	cf 93       	push	r28
    4c80:	df 93       	push	r29
    4c82:	8c 01       	movw	r16, r24
    4c84:	6b 01       	movw	r12, r22
    4c86:	34 2e       	mov	r3, r20
    4c88:	79 01       	movw	r14, r18
			unsigned short TEMP_HASH_VALUE;
			unsigned long HASH_ODD=1;
			unsigned long HASH_EVEN=1;
			unsigned char i;
			for (i=0;i<LENGTH;i=i+2)
    4c8a:	44 23       	and	r20, r20
    4c8c:	09 f4       	brne	.+2      	; 0x4c90 <HASH_PASWORD_KEY+0x30>
    4c8e:	44 c0       	rjmp	.+136    	; 0x4d18 <HASH_PASWORD_KEY+0xb8>
    4c90:	c0 e0       	ldi	r28, 0x00	; 0
}

void HASH_PASWORD_KEY(unsigned char *DATA_TO_BE_HASHED,unsigned char *HASH_VALUE,unsigned char LENGTH,unsigned char*PASSWORD_KEY)
{
			unsigned short TEMP_HASH_VALUE;
			unsigned long HASH_ODD=1;
    4c92:	81 2c       	mov	r8, r1
    4c94:	91 2c       	mov	r9, r1
    4c96:	54 01       	movw	r10, r8
    4c98:	83 94       	inc	r8
			unsigned long HASH_EVEN=1;
			unsigned char i;
			for (i=0;i<LENGTH;i=i+2)
			{
				HASH_ODD=(HASH_ODD*DATA_TO_BE_HASHED[i])%0xffff;
    4c9a:	44 24       	eor	r4, r4
    4c9c:	4a 94       	dec	r4
    4c9e:	54 2c       	mov	r5, r4
    4ca0:	61 2c       	mov	r6, r1
    4ca2:	71 2c       	mov	r7, r1
    4ca4:	f8 01       	movw	r30, r16
    4ca6:	ec 0f       	add	r30, r28
    4ca8:	f1 1d       	adc	r31, r1
    4caa:	a0 81       	ld	r26, Z
    4cac:	b0 e0       	ldi	r27, 0x00	; 0
    4cae:	a5 01       	movw	r20, r10
    4cb0:	94 01       	movw	r18, r8
    4cb2:	0e 94 41 42 	call	0x8482	; 0x8482 <__muluhisi3>
    4cb6:	a3 01       	movw	r20, r6
    4cb8:	92 01       	movw	r18, r4
    4cba:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
    4cbe:	4b 01       	movw	r8, r22
    4cc0:	5c 01       	movw	r10, r24
{
			unsigned short TEMP_HASH_VALUE;
			unsigned long HASH_ODD=1;
			unsigned long HASH_EVEN=1;
			unsigned char i;
			for (i=0;i<LENGTH;i=i+2)
    4cc2:	ce 5f       	subi	r28, 0xFE	; 254
    4cc4:	c3 15       	cp	r28, r3
    4cc6:	70 f3       	brcs	.-36     	; 0x4ca4 <HASH_PASWORD_KEY+0x44>
			{
				HASH_ODD=(HASH_ODD*DATA_TO_BE_HASHED[i])%0xffff;
			}
			for (i=1;i<LENGTH;i=i+2)
    4cc8:	81 e0       	ldi	r24, 0x01	; 1
    4cca:	83 15       	cp	r24, r3
    4ccc:	70 f5       	brcc	.+92     	; 0x4d2a <HASH_PASWORD_KEY+0xca>
    4cce:	e8 01       	movw	r28, r16
    4cd0:	21 96       	adiw	r28, 0x01	; 1
    4cd2:	0d 5f       	subi	r16, 0xFD	; 253
    4cd4:	1f 4f       	sbci	r17, 0xFF	; 255
    4cd6:	3a 94       	dec	r3
    4cd8:	3a 94       	dec	r3
    4cda:	36 94       	lsr	r3
    4cdc:	83 2d       	mov	r24, r3
    4cde:	90 e0       	ldi	r25, 0x00	; 0
    4ce0:	88 0f       	add	r24, r24
    4ce2:	99 1f       	adc	r25, r25
    4ce4:	08 0f       	add	r16, r24
    4ce6:	19 1f       	adc	r17, r25
    4ce8:	61 e0       	ldi	r22, 0x01	; 1
    4cea:	70 e0       	ldi	r23, 0x00	; 0
    4cec:	80 e0       	ldi	r24, 0x00	; 0
    4cee:	90 e0       	ldi	r25, 0x00	; 0
			{
				HASH_EVEN=(HASH_EVEN*DATA_TO_BE_HASHED[i])%0xffff;
    4cf0:	44 24       	eor	r4, r4
    4cf2:	4a 94       	dec	r4
    4cf4:	54 2c       	mov	r5, r4
    4cf6:	61 2c       	mov	r6, r1
    4cf8:	71 2c       	mov	r7, r1
    4cfa:	a8 81       	ld	r26, Y
    4cfc:	b0 e0       	ldi	r27, 0x00	; 0
    4cfe:	9b 01       	movw	r18, r22
    4d00:	ac 01       	movw	r20, r24
    4d02:	0e 94 41 42 	call	0x8482	; 0x8482 <__muluhisi3>
    4d06:	a3 01       	movw	r20, r6
    4d08:	92 01       	movw	r18, r4
    4d0a:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
    4d0e:	22 96       	adiw	r28, 0x02	; 2
			unsigned char i;
			for (i=0;i<LENGTH;i=i+2)
			{
				HASH_ODD=(HASH_ODD*DATA_TO_BE_HASHED[i])%0xffff;
			}
			for (i=1;i<LENGTH;i=i+2)
    4d10:	c0 17       	cp	r28, r16
    4d12:	d1 07       	cpc	r29, r17
    4d14:	91 f7       	brne	.-28     	; 0x4cfa <HASH_PASWORD_KEY+0x9a>
    4d16:	0d c0       	rjmp	.+26     	; 0x4d32 <HASH_PASWORD_KEY+0xd2>
}

void HASH_PASWORD_KEY(unsigned char *DATA_TO_BE_HASHED,unsigned char *HASH_VALUE,unsigned char LENGTH,unsigned char*PASSWORD_KEY)
{
			unsigned short TEMP_HASH_VALUE;
			unsigned long HASH_ODD=1;
    4d18:	81 2c       	mov	r8, r1
    4d1a:	91 2c       	mov	r9, r1
    4d1c:	54 01       	movw	r10, r8
    4d1e:	83 94       	inc	r8
			unsigned long HASH_EVEN=1;
			unsigned char i;
			for (i=0;i<LENGTH;i=i+2)
    4d20:	61 e0       	ldi	r22, 0x01	; 1
    4d22:	70 e0       	ldi	r23, 0x00	; 0
    4d24:	80 e0       	ldi	r24, 0x00	; 0
    4d26:	90 e0       	ldi	r25, 0x00	; 0
    4d28:	04 c0       	rjmp	.+8      	; 0x4d32 <HASH_PASWORD_KEY+0xd2>
			{
				HASH_ODD=(HASH_ODD*DATA_TO_BE_HASHED[i])%0xffff;
			}
			for (i=1;i<LENGTH;i=i+2)
    4d2a:	61 e0       	ldi	r22, 0x01	; 1
    4d2c:	70 e0       	ldi	r23, 0x00	; 0
    4d2e:	80 e0       	ldi	r24, 0x00	; 0
    4d30:	90 e0       	ldi	r25, 0x00	; 0
			{
				HASH_EVEN=(HASH_EVEN*DATA_TO_BE_HASHED[i])%0xffff;
			}
			TEMP_HASH_VALUE=(HASH_ODD^HASH_EVEN)%0xffff;
    4d32:	68 25       	eor	r22, r8
    4d34:	79 25       	eor	r23, r9
    4d36:	8a 25       	eor	r24, r10
    4d38:	9b 25       	eor	r25, r11
    4d3a:	2f ef       	ldi	r18, 0xFF	; 255
    4d3c:	3f ef       	ldi	r19, 0xFF	; 255
    4d3e:	40 e0       	ldi	r20, 0x00	; 0
    4d40:	50 e0       	ldi	r21, 0x00	; 0
    4d42:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
			HASH_VALUE[0]=(TEMP_HASH_VALUE>>8)^PASSWORD_KEY[0]^PASSWORD_KEY[1];
    4d46:	f7 01       	movw	r30, r14
    4d48:	91 81       	ldd	r25, Z+1	; 0x01
    4d4a:	80 81       	ld	r24, Z
    4d4c:	89 27       	eor	r24, r25
    4d4e:	78 27       	eor	r23, r24
    4d50:	f6 01       	movw	r30, r12
    4d52:	70 83       	st	Z, r23
			HASH_VALUE[1]=(TEMP_HASH_VALUE&0x00ff)^PASSWORD_KEY[2]^PASSWORD_KEY[3];
    4d54:	f7 01       	movw	r30, r14
    4d56:	93 81       	ldd	r25, Z+3	; 0x03
    4d58:	82 81       	ldd	r24, Z+2	; 0x02
    4d5a:	89 27       	eor	r24, r25
    4d5c:	68 27       	eor	r22, r24
    4d5e:	f6 01       	movw	r30, r12
    4d60:	61 83       	std	Z+1, r22	; 0x01
	
}
    4d62:	df 91       	pop	r29
    4d64:	cf 91       	pop	r28
    4d66:	1f 91       	pop	r17
    4d68:	0f 91       	pop	r16
    4d6a:	ff 90       	pop	r15
    4d6c:	ef 90       	pop	r14
    4d6e:	df 90       	pop	r13
    4d70:	cf 90       	pop	r12
    4d72:	bf 90       	pop	r11
    4d74:	af 90       	pop	r10
    4d76:	9f 90       	pop	r9
    4d78:	8f 90       	pop	r8
    4d7a:	7f 90       	pop	r7
    4d7c:	6f 90       	pop	r6
    4d7e:	5f 90       	pop	r5
    4d80:	4f 90       	pop	r4
    4d82:	3f 90       	pop	r3
    4d84:	08 95       	ret

00004d86 <GENNERATE_RANDOM_NUMBER>:
 *  Author: Mina Medhat
 */ 
#include "RANDOM_NUM_GEN.h"
volatile unsigned long RANDOM_NUMBER=1; 
unsigned short GENNERATE_RANDOM_NUMBER()
{
    4d86:	cf 92       	push	r12
    4d88:	df 92       	push	r13
    4d8a:	ef 92       	push	r14
    4d8c:	ff 92       	push	r15
	   RANDOM_NUMBER=(RANDOM_NUMBER+0x44444*((unsigned short)TIMER0_READ_COUNTER()+1))%(0xffff);
    4d8e:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <TIMER0_READ_COUNTER>
    4d92:	c0 90 0f 01 	lds	r12, 0x010F
    4d96:	d0 90 10 01 	lds	r13, 0x0110
    4d9a:	e0 90 11 01 	lds	r14, 0x0111
    4d9e:	f0 90 12 01 	lds	r15, 0x0112
    4da2:	a8 2f       	mov	r26, r24
    4da4:	b0 e0       	ldi	r27, 0x00	; 0
    4da6:	11 96       	adiw	r26, 0x01	; 1
    4da8:	24 e4       	ldi	r18, 0x44	; 68
    4daa:	34 e4       	ldi	r19, 0x44	; 68
    4dac:	44 e0       	ldi	r20, 0x04	; 4
    4dae:	50 e0       	ldi	r21, 0x00	; 0
    4db0:	0e 94 41 42 	call	0x8482	; 0x8482 <__muluhisi3>
    4db4:	6c 0d       	add	r22, r12
    4db6:	7d 1d       	adc	r23, r13
    4db8:	8e 1d       	adc	r24, r14
    4dba:	9f 1d       	adc	r25, r15
    4dbc:	2f ef       	ldi	r18, 0xFF	; 255
    4dbe:	3f ef       	ldi	r19, 0xFF	; 255
    4dc0:	40 e0       	ldi	r20, 0x00	; 0
    4dc2:	50 e0       	ldi	r21, 0x00	; 0
    4dc4:	0e 94 0a 42 	call	0x8414	; 0x8414 <__udivmodsi4>
    4dc8:	60 93 0f 01 	sts	0x010F, r22
    4dcc:	70 93 10 01 	sts	0x0110, r23
    4dd0:	80 93 11 01 	sts	0x0111, r24
    4dd4:	90 93 12 01 	sts	0x0112, r25
	   return (unsigned short)RANDOM_NUMBER;
    4dd8:	80 91 0f 01 	lds	r24, 0x010F
    4ddc:	90 91 10 01 	lds	r25, 0x0110
    4de0:	a0 91 11 01 	lds	r26, 0x0111
    4de4:	b0 91 12 01 	lds	r27, 0x0112
}
    4de8:	ff 90       	pop	r15
    4dea:	ef 90       	pop	r14
    4dec:	df 90       	pop	r13
    4dee:	cf 90       	pop	r12
    4df0:	08 95       	ret

00004df2 <SENSORS_CONNECT>:
		writeeeprom(MY_EEPROM_START_OF_SENSOR_ARRAY+index*SIZE_OF_SENSOR_DATA_EEPROM+10,MY_SENSORS[index].SENSOR_VERSION);
		writeeeprom(MY_EEPROM_START_OF_SENSOR_ARRAY+index*SIZE_OF_SENSOR_DATA_EEPROM+11,MY_SENSORS[index].SENSOR_TYPE);
		writeeeprom(MY_EEPROM_START_OF_SENSOR_ARRAY+index*SIZE_OF_SENSOR_DATA_EEPROM+12,MY_SENSORS[index].SENSOR_STATE);
		writeeeprom(MY_EEPROM_START_OF_SENSOR_ARRAY+index*SIZE_OF_SENSOR_DATA_EEPROM+13,MY_SENSORS[index].SENSOR_OCCUBIED);
	}
}
    4df2:	2f 92       	push	r2
    4df4:	3f 92       	push	r3
    4df6:	4f 92       	push	r4
    4df8:	5f 92       	push	r5
    4dfa:	6f 92       	push	r6
    4dfc:	7f 92       	push	r7
    4dfe:	8f 92       	push	r8
    4e00:	9f 92       	push	r9
    4e02:	af 92       	push	r10
    4e04:	bf 92       	push	r11
    4e06:	cf 92       	push	r12
    4e08:	df 92       	push	r13
    4e0a:	ef 92       	push	r14
    4e0c:	ff 92       	push	r15
    4e0e:	0f 93       	push	r16
    4e10:	1f 93       	push	r17
    4e12:	cf 93       	push	r28
    4e14:	df 93       	push	r29
    4e16:	00 d0       	rcall	.+0      	; 0x4e18 <SENSORS_CONNECT+0x26>
    4e18:	00 d0       	rcall	.+0      	; 0x4e1a <SENSORS_CONNECT+0x28>
    4e1a:	cd b7       	in	r28, 0x3d	; 61
    4e1c:	de b7       	in	r29, 0x3e	; 62
    4e1e:	24 e1       	ldi	r18, 0x14	; 20
    4e20:	3d e0       	ldi	r19, 0x0D	; 13
    4e22:	3c 83       	std	Y+4, r19	; 0x04
    4e24:	2b 83       	std	Y+3, r18	; 0x03
    4e26:	0f 2e       	mov	r0, r31
    4e28:	fe e0       	ldi	r31, 0x0E	; 14
    4e2a:	ef 2e       	mov	r14, r31
    4e2c:	fe e0       	ldi	r31, 0x0E	; 14
    4e2e:	ff 2e       	mov	r15, r31
    4e30:	f0 2d       	mov	r31, r0
    4e32:	a1 2c       	mov	r10, r1
    4e34:	b1 2c       	mov	r11, r1
    4e36:	41 2c       	mov	r4, r1
    4e38:	51 2c       	mov	r5, r1
    4e3a:	61 2c       	mov	r6, r1
    4e3c:	71 2c       	mov	r7, r1
    4e3e:	81 2c       	mov	r8, r1
    4e40:	91 2c       	mov	r9, r1
    4e42:	0f 2e       	mov	r0, r31
    4e44:	f9 e1       	ldi	r31, 0x19	; 25
    4e46:	3f 2e       	mov	r3, r31
    4e48:	f0 2d       	mov	r31, r0
    4e4a:	0f 2e       	mov	r0, r31
    4e4c:	f4 e1       	ldi	r31, 0x14	; 20
    4e4e:	cf 2e       	mov	r12, r31
    4e50:	f1 e0       	ldi	r31, 0x01	; 1
    4e52:	df 2e       	mov	r13, r31
    4e54:	f0 2d       	mov	r31, r0
    4e56:	22 24       	eor	r2, r2
    4e58:	23 94       	inc	r2
    4e5a:	8a 2d       	mov	r24, r10
    4e5c:	9b 2d       	mov	r25, r11
    4e5e:	8c 01       	movw	r16, r24
    4e60:	38 9e       	mul	r3, r24
    4e62:	f0 01       	movw	r30, r0
    4e64:	39 9e       	mul	r3, r25
    4e66:	f0 0d       	add	r31, r0
    4e68:	11 24       	eor	r1, r1
    4e6a:	ed 5e       	subi	r30, 0xED	; 237
    4e6c:	f2 4f       	sbci	r31, 0xF2	; 242
    4e6e:	25 85       	ldd	r18, Z+13	; 0x0d
    4e70:	21 30       	cpi	r18, 0x01	; 1
    4e72:	09 f0       	breq	.+2      	; 0x4e76 <SENSORS_CONNECT+0x84>
    4e74:	05 c1       	rjmp	.+522    	; 0x5080 <SENSORS_CONNECT+0x28e>
    4e76:	38 9e       	mul	r3, r24
    4e78:	f0 01       	movw	r30, r0
    4e7a:	39 9e       	mul	r3, r25
    4e7c:	f0 0d       	add	r31, r0
    4e7e:	11 24       	eor	r1, r1
    4e80:	ed 5e       	subi	r30, 0xED	; 237
    4e82:	f2 4f       	sbci	r31, 0xF2	; 242
    4e84:	84 85       	ldd	r24, Z+12	; 0x0c
    4e86:	81 30       	cpi	r24, 0x01	; 1
    4e88:	09 f0       	breq	.+2      	; 0x4e8c <SENSORS_CONNECT+0x9a>
    4e8a:	fa c0       	rjmp	.+500    	; 0x5080 <SENSORS_CONNECT+0x28e>
    4e8c:	30 9e       	mul	r3, r16
    4e8e:	f0 01       	movw	r30, r0
    4e90:	31 9e       	mul	r3, r17
    4e92:	f0 0d       	add	r31, r0
    4e94:	11 24       	eor	r1, r1
    4e96:	ed 5e       	subi	r30, 0xED	; 237
    4e98:	f2 4f       	sbci	r31, 0xF2	; 242
    4e9a:	86 85       	ldd	r24, Z+14	; 0x0e
    4e9c:	81 30       	cpi	r24, 0x01	; 1
    4e9e:	09 f4       	brne	.+2      	; 0x4ea2 <SENSORS_CONNECT+0xb0>
    4ea0:	ef c0       	rjmp	.+478    	; 0x5080 <SENSORS_CONNECT+0x28e>
    4ea2:	30 9e       	mul	r3, r16
    4ea4:	f0 01       	movw	r30, r0
    4ea6:	31 9e       	mul	r3, r17
    4ea8:	f0 0d       	add	r31, r0
    4eaa:	11 24       	eor	r1, r1
    4eac:	ed 5e       	subi	r30, 0xED	; 237
    4eae:	f2 4f       	sbci	r31, 0xF2	; 242
    4eb0:	87 85       	ldd	r24, Z+15	; 0x0f
    4eb2:	84 31       	cpi	r24, 0x14	; 20
    4eb4:	09 f0       	breq	.+2      	; 0x4eb8 <SENSORS_CONNECT+0xc6>
    4eb6:	e4 c0       	rjmp	.+456    	; 0x5080 <SENSORS_CONNECT+0x28e>
    4eb8:	8f b7       	in	r24, 0x3f	; 63
    4eba:	8f 77       	andi	r24, 0x7F	; 127
    4ebc:	8f bf       	out	0x3f, r24	; 63
    4ebe:	30 9e       	mul	r3, r16
    4ec0:	c0 01       	movw	r24, r0
    4ec2:	31 9e       	mul	r3, r17
    4ec4:	90 0d       	add	r25, r0
    4ec6:	11 24       	eor	r1, r1
    4ec8:	fc 01       	movw	r30, r24
    4eca:	ed 5e       	subi	r30, 0xED	; 237
    4ecc:	f2 4f       	sbci	r31, 0xF2	; 242
    4ece:	fa 83       	std	Y+2, r31	; 0x02
    4ed0:	e9 83       	std	Y+1, r30	; 0x01
    4ed2:	17 86       	std	Z+15, r1	; 0x0f
    4ed4:	8f b7       	in	r24, 0x3f	; 63
    4ed6:	80 68       	ori	r24, 0x80	; 128
    4ed8:	8f bf       	out	0x3f, r24	; 63
    4eda:	f6 01       	movw	r30, r12
    4edc:	80 81       	ld	r24, Z
    4ede:	0e 94 c0 10 	call	0x2180	; 0x2180 <NRF_UPDATE_USED_CHANNEL>
    4ee2:	86 ef       	ldi	r24, 0xF6	; 246
    4ee4:	92 e0       	ldi	r25, 0x02	; 2
    4ee6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    4eea:	83 e0       	ldi	r24, 0x03	; 3
    4eec:	93 e0       	ldi	r25, 0x03	; 3
    4eee:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    4ef2:	e9 81       	ldd	r30, Y+1	; 0x01
    4ef4:	fa 81       	ldd	r31, Y+2	; 0x02
    4ef6:	21 81       	ldd	r18, Z+1	; 0x01
    4ef8:	30 e0       	ldi	r19, 0x00	; 0
    4efa:	40 e0       	ldi	r20, 0x00	; 0
    4efc:	50 e0       	ldi	r21, 0x00	; 0
    4efe:	60 e0       	ldi	r22, 0x00	; 0
    4f00:	70 e0       	ldi	r23, 0x00	; 0
    4f02:	80 e0       	ldi	r24, 0x00	; 0
    4f04:	90 e0       	ldi	r25, 0x00	; 0
    4f06:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    4f0a:	80 e2       	ldi	r24, 0x20	; 32
    4f0c:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    4f10:	e9 81       	ldd	r30, Y+1	; 0x01
    4f12:	fa 81       	ldd	r31, Y+2	; 0x02
    4f14:	22 81       	ldd	r18, Z+2	; 0x02
    4f16:	30 e0       	ldi	r19, 0x00	; 0
    4f18:	40 e0       	ldi	r20, 0x00	; 0
    4f1a:	50 e0       	ldi	r21, 0x00	; 0
    4f1c:	60 e0       	ldi	r22, 0x00	; 0
    4f1e:	70 e0       	ldi	r23, 0x00	; 0
    4f20:	80 e0       	ldi	r24, 0x00	; 0
    4f22:	90 e0       	ldi	r25, 0x00	; 0
    4f24:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    4f28:	80 e2       	ldi	r24, 0x20	; 32
    4f2a:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    4f2e:	e9 81       	ldd	r30, Y+1	; 0x01
    4f30:	fa 81       	ldd	r31, Y+2	; 0x02
    4f32:	23 81       	ldd	r18, Z+3	; 0x03
    4f34:	30 e0       	ldi	r19, 0x00	; 0
    4f36:	40 e0       	ldi	r20, 0x00	; 0
    4f38:	50 e0       	ldi	r21, 0x00	; 0
    4f3a:	60 e0       	ldi	r22, 0x00	; 0
    4f3c:	70 e0       	ldi	r23, 0x00	; 0
    4f3e:	80 e0       	ldi	r24, 0x00	; 0
    4f40:	90 e0       	ldi	r25, 0x00	; 0
    4f42:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    4f46:	80 e2       	ldi	r24, 0x20	; 32
    4f48:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    4f4c:	e9 81       	ldd	r30, Y+1	; 0x01
    4f4e:	fa 81       	ldd	r31, Y+2	; 0x02
    4f50:	24 81       	ldd	r18, Z+4	; 0x04
    4f52:	30 e0       	ldi	r19, 0x00	; 0
    4f54:	40 e0       	ldi	r20, 0x00	; 0
    4f56:	50 e0       	ldi	r21, 0x00	; 0
    4f58:	60 e0       	ldi	r22, 0x00	; 0
    4f5a:	70 e0       	ldi	r23, 0x00	; 0
    4f5c:	80 e0       	ldi	r24, 0x00	; 0
    4f5e:	90 e0       	ldi	r25, 0x00	; 0
    4f60:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    4f64:	80 e2       	ldi	r24, 0x20	; 32
    4f66:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    4f6a:	e9 81       	ldd	r30, Y+1	; 0x01
    4f6c:	fa 81       	ldd	r31, Y+2	; 0x02
    4f6e:	25 81       	ldd	r18, Z+5	; 0x05
    4f70:	30 e0       	ldi	r19, 0x00	; 0
    4f72:	40 e0       	ldi	r20, 0x00	; 0
    4f74:	50 e0       	ldi	r21, 0x00	; 0
    4f76:	60 e0       	ldi	r22, 0x00	; 0
    4f78:	70 e0       	ldi	r23, 0x00	; 0
    4f7a:	80 e0       	ldi	r24, 0x00	; 0
    4f7c:	90 e0       	ldi	r25, 0x00	; 0
    4f7e:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    4f82:	84 e9       	ldi	r24, 0x94	; 148
    4f84:	91 e0       	ldi	r25, 0x01	; 1
    4f86:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    4f8a:	8d e0       	ldi	r24, 0x0D	; 13
    4f8c:	93 e0       	ldi	r25, 0x03	; 3
    4f8e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    4f92:	e9 81       	ldd	r30, Y+1	; 0x01
    4f94:	fa 81       	ldd	r31, Y+2	; 0x02
    4f96:	26 81       	ldd	r18, Z+6	; 0x06
    4f98:	30 e0       	ldi	r19, 0x00	; 0
    4f9a:	40 e0       	ldi	r20, 0x00	; 0
    4f9c:	50 e0       	ldi	r21, 0x00	; 0
    4f9e:	60 e0       	ldi	r22, 0x00	; 0
    4fa0:	70 e0       	ldi	r23, 0x00	; 0
    4fa2:	80 e0       	ldi	r24, 0x00	; 0
    4fa4:	90 e0       	ldi	r25, 0x00	; 0
    4fa6:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    4faa:	80 e2       	ldi	r24, 0x20	; 32
    4fac:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    4fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    4fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    4fb4:	27 81       	ldd	r18, Z+7	; 0x07
    4fb6:	30 e0       	ldi	r19, 0x00	; 0
    4fb8:	40 e0       	ldi	r20, 0x00	; 0
    4fba:	50 e0       	ldi	r21, 0x00	; 0
    4fbc:	60 e0       	ldi	r22, 0x00	; 0
    4fbe:	70 e0       	ldi	r23, 0x00	; 0
    4fc0:	80 e0       	ldi	r24, 0x00	; 0
    4fc2:	90 e0       	ldi	r25, 0x00	; 0
    4fc4:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    4fc8:	80 e2       	ldi	r24, 0x20	; 32
    4fca:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    4fce:	e9 81       	ldd	r30, Y+1	; 0x01
    4fd0:	fa 81       	ldd	r31, Y+2	; 0x02
    4fd2:	20 85       	ldd	r18, Z+8	; 0x08
    4fd4:	30 e0       	ldi	r19, 0x00	; 0
    4fd6:	40 e0       	ldi	r20, 0x00	; 0
    4fd8:	50 e0       	ldi	r21, 0x00	; 0
    4fda:	60 e0       	ldi	r22, 0x00	; 0
    4fdc:	70 e0       	ldi	r23, 0x00	; 0
    4fde:	80 e0       	ldi	r24, 0x00	; 0
    4fe0:	90 e0       	ldi	r25, 0x00	; 0
    4fe2:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    4fe6:	80 e2       	ldi	r24, 0x20	; 32
    4fe8:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    4fec:	e9 81       	ldd	r30, Y+1	; 0x01
    4fee:	fa 81       	ldd	r31, Y+2	; 0x02
    4ff0:	21 85       	ldd	r18, Z+9	; 0x09
    4ff2:	30 e0       	ldi	r19, 0x00	; 0
    4ff4:	40 e0       	ldi	r20, 0x00	; 0
    4ff6:	50 e0       	ldi	r21, 0x00	; 0
    4ff8:	60 e0       	ldi	r22, 0x00	; 0
    4ffa:	70 e0       	ldi	r23, 0x00	; 0
    4ffc:	80 e0       	ldi	r24, 0x00	; 0
    4ffe:	90 e0       	ldi	r25, 0x00	; 0
    5000:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    5004:	84 e1       	ldi	r24, 0x14	; 20
    5006:	93 e0       	ldi	r25, 0x03	; 3
    5008:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    500c:	2a 2d       	mov	r18, r10
    500e:	3b 2d       	mov	r19, r11
    5010:	44 2d       	mov	r20, r4
    5012:	55 2d       	mov	r21, r5
    5014:	66 2d       	mov	r22, r6
    5016:	77 2d       	mov	r23, r7
    5018:	88 2d       	mov	r24, r8
    501a:	99 2d       	mov	r25, r9
    501c:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    5020:	8a e0       	ldi	r24, 0x0A	; 10
    5022:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    5026:	e9 81       	ldd	r30, Y+1	; 0x01
    5028:	fa 81       	ldd	r31, Y+2	; 0x02
    502a:	40 81       	ld	r20, Z
    502c:	62 85       	ldd	r22, Z+10	; 0x0a
    502e:	2b 81       	ldd	r18, Y+3	; 0x03
    5030:	3c 81       	ldd	r19, Y+4	; 0x04
    5032:	2b 5f       	subi	r18, 0xFB	; 251
    5034:	3f 4f       	sbci	r19, 0xFF	; 255
    5036:	8b 81       	ldd	r24, Y+3	; 0x03
    5038:	9c 81       	ldd	r25, Y+4	; 0x04
    503a:	49 d8       	rcall	.-3950   	; 0x40ce <PROTOCOL_MASTER_CONNECT_TO_SENSOR>
    503c:	88 23       	and	r24, r24
    503e:	01 f1       	breq	.+64     	; 0x5080 <SENSORS_CONNECT+0x28e>
    5040:	85 e3       	ldi	r24, 0x35	; 53
    5042:	93 e0       	ldi	r25, 0x03	; 3
    5044:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5048:	2a 2d       	mov	r18, r10
    504a:	3b 2d       	mov	r19, r11
    504c:	44 2d       	mov	r20, r4
    504e:	55 2d       	mov	r21, r5
    5050:	66 2d       	mov	r22, r6
    5052:	77 2d       	mov	r23, r7
    5054:	88 2d       	mov	r24, r8
    5056:	99 2d       	mov	r25, r9
    5058:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    505c:	8a e0       	ldi	r24, 0x0A	; 10
    505e:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    5062:	30 9e       	mul	r3, r16
    5064:	f0 01       	movw	r30, r0
    5066:	31 9e       	mul	r3, r17
    5068:	f0 0d       	add	r31, r0
    506a:	11 24       	eor	r1, r1
    506c:	ed 5e       	subi	r30, 0xED	; 237
    506e:	f2 4f       	sbci	r31, 0xF2	; 242
    5070:	10 8e       	std	Z+24, r1	; 0x18
    5072:	17 8a       	std	Z+23, r1	; 0x17
    5074:	26 86       	std	Z+14, r2	; 0x0e
    5076:	13 8a       	std	Z+19, r1	; 0x13
    5078:	10 8a       	std	Z+16, r1	; 0x10
    507a:	14 8a       	std	Z+20, r1	; 0x14
    507c:	11 8a       	std	Z+17, r1	; 0x11
    507e:	12 8a       	std	Z+18, r1	; 0x12
    5080:	2a 2d       	mov	r18, r10
    5082:	3b 2d       	mov	r19, r11
    5084:	44 2d       	mov	r20, r4
    5086:	55 2d       	mov	r21, r5
    5088:	66 2d       	mov	r22, r6
    508a:	77 2d       	mov	r23, r7
    508c:	88 2d       	mov	r24, r8
    508e:	99 2d       	mov	r25, r9
    5090:	a2 2d       	mov	r26, r2
    5092:	0e 94 f9 42 	call	0x85f2	; 0x85f2 <__adddi3_s8>
    5096:	a2 2e       	mov	r10, r18
    5098:	b3 2e       	mov	r11, r19
    509a:	44 2e       	mov	r4, r20
    509c:	55 2e       	mov	r5, r21
    509e:	66 2e       	mov	r6, r22
    50a0:	77 2e       	mov	r7, r23
    50a2:	88 2e       	mov	r8, r24
    50a4:	99 2e       	mov	r9, r25
    50a6:	2b 81       	ldd	r18, Y+3	; 0x03
    50a8:	3c 81       	ldd	r19, Y+4	; 0x04
    50aa:	27 5e       	subi	r18, 0xE7	; 231
    50ac:	3f 4f       	sbci	r19, 0xFF	; 255
    50ae:	3c 83       	std	Y+4, r19	; 0x04
    50b0:	2b 83       	std	Y+3, r18	; 0x03
    50b2:	2e 15       	cp	r18, r14
    50b4:	3f 05       	cpc	r19, r15
    50b6:	09 f0       	breq	.+2      	; 0x50ba <SENSORS_CONNECT+0x2c8>
    50b8:	d0 ce       	rjmp	.-608    	; 0x4e5a <SENSORS_CONNECT+0x68>
    50ba:	0f 90       	pop	r0
    50bc:	0f 90       	pop	r0
    50be:	0f 90       	pop	r0
    50c0:	0f 90       	pop	r0
    50c2:	df 91       	pop	r29
    50c4:	cf 91       	pop	r28
    50c6:	1f 91       	pop	r17
    50c8:	0f 91       	pop	r16
    50ca:	ff 90       	pop	r15
    50cc:	ef 90       	pop	r14
    50ce:	df 90       	pop	r13
    50d0:	cf 90       	pop	r12
    50d2:	bf 90       	pop	r11
    50d4:	af 90       	pop	r10
    50d6:	9f 90       	pop	r9
    50d8:	8f 90       	pop	r8
    50da:	7f 90       	pop	r7
    50dc:	6f 90       	pop	r6
    50de:	5f 90       	pop	r5
    50e0:	4f 90       	pop	r4
    50e2:	3f 90       	pop	r3
    50e4:	2f 90       	pop	r2
    50e6:	08 95       	ret

000050e8 <SENSORS_BEACON>:
    50e8:	3f 92       	push	r3
    50ea:	4f 92       	push	r4
    50ec:	5f 92       	push	r5
    50ee:	6f 92       	push	r6
    50f0:	7f 92       	push	r7
    50f2:	8f 92       	push	r8
    50f4:	9f 92       	push	r9
    50f6:	af 92       	push	r10
    50f8:	bf 92       	push	r11
    50fa:	cf 92       	push	r12
    50fc:	df 92       	push	r13
    50fe:	ef 92       	push	r14
    5100:	ff 92       	push	r15
    5102:	0f 93       	push	r16
    5104:	1f 93       	push	r17
    5106:	cf 93       	push	r28
    5108:	df 93       	push	r29
    510a:	c4 e1       	ldi	r28, 0x14	; 20
    510c:	dd e0       	ldi	r29, 0x0D	; 13
    510e:	0f 2e       	mov	r0, r31
    5110:	fe e0       	ldi	r31, 0x0E	; 14
    5112:	ef 2e       	mov	r14, r31
    5114:	fe e0       	ldi	r31, 0x0E	; 14
    5116:	ff 2e       	mov	r15, r31
    5118:	f0 2d       	mov	r31, r0
    511a:	a1 2c       	mov	r10, r1
    511c:	b1 2c       	mov	r11, r1
    511e:	41 2c       	mov	r4, r1
    5120:	51 2c       	mov	r5, r1
    5122:	61 2c       	mov	r6, r1
    5124:	71 2c       	mov	r7, r1
    5126:	81 2c       	mov	r8, r1
    5128:	91 2c       	mov	r9, r1
    512a:	0f 2e       	mov	r0, r31
    512c:	f9 e1       	ldi	r31, 0x19	; 25
    512e:	3f 2e       	mov	r3, r31
    5130:	f0 2d       	mov	r31, r0
    5132:	8a 2d       	mov	r24, r10
    5134:	9b 2d       	mov	r25, r11
    5136:	8c 01       	movw	r16, r24
    5138:	38 9e       	mul	r3, r24
    513a:	f0 01       	movw	r30, r0
    513c:	39 9e       	mul	r3, r25
    513e:	f0 0d       	add	r31, r0
    5140:	11 24       	eor	r1, r1
    5142:	ed 5e       	subi	r30, 0xED	; 237
    5144:	f2 4f       	sbci	r31, 0xF2	; 242
    5146:	25 85       	ldd	r18, Z+13	; 0x0d
    5148:	21 30       	cpi	r18, 0x01	; 1
    514a:	09 f0       	breq	.+2      	; 0x514e <SENSORS_BEACON+0x66>
    514c:	a8 c0       	rjmp	.+336    	; 0x529e <SENSORS_BEACON+0x1b6>
    514e:	38 9e       	mul	r3, r24
    5150:	f0 01       	movw	r30, r0
    5152:	39 9e       	mul	r3, r25
    5154:	f0 0d       	add	r31, r0
    5156:	11 24       	eor	r1, r1
    5158:	ed 5e       	subi	r30, 0xED	; 237
    515a:	f2 4f       	sbci	r31, 0xF2	; 242
    515c:	84 85       	ldd	r24, Z+12	; 0x0c
    515e:	81 30       	cpi	r24, 0x01	; 1
    5160:	09 f0       	breq	.+2      	; 0x5164 <SENSORS_BEACON+0x7c>
    5162:	9d c0       	rjmp	.+314    	; 0x529e <SENSORS_BEACON+0x1b6>
    5164:	30 9e       	mul	r3, r16
    5166:	f0 01       	movw	r30, r0
    5168:	31 9e       	mul	r3, r17
    516a:	f0 0d       	add	r31, r0
    516c:	11 24       	eor	r1, r1
    516e:	ed 5e       	subi	r30, 0xED	; 237
    5170:	f2 4f       	sbci	r31, 0xF2	; 242
    5172:	86 85       	ldd	r24, Z+14	; 0x0e
    5174:	81 30       	cpi	r24, 0x01	; 1
    5176:	09 f0       	breq	.+2      	; 0x517a <SENSORS_BEACON+0x92>
    5178:	92 c0       	rjmp	.+292    	; 0x529e <SENSORS_BEACON+0x1b6>
    517a:	30 9e       	mul	r3, r16
    517c:	f0 01       	movw	r30, r0
    517e:	31 9e       	mul	r3, r17
    5180:	f0 0d       	add	r31, r0
    5182:	11 24       	eor	r1, r1
    5184:	ed 5e       	subi	r30, 0xED	; 237
    5186:	f2 4f       	sbci	r31, 0xF2	; 242
    5188:	80 89       	ldd	r24, Z+16	; 0x10
    518a:	88 30       	cpi	r24, 0x08	; 8
    518c:	09 f0       	breq	.+2      	; 0x5190 <SENSORS_BEACON+0xa8>
    518e:	87 c0       	rjmp	.+270    	; 0x529e <SENSORS_BEACON+0x1b6>
    5190:	8f b7       	in	r24, 0x3f	; 63
    5192:	8f 77       	andi	r24, 0x7F	; 127
    5194:	8f bf       	out	0x3f, r24	; 63
    5196:	30 9e       	mul	r3, r16
    5198:	f0 01       	movw	r30, r0
    519a:	31 9e       	mul	r3, r17
    519c:	f0 0d       	add	r31, r0
    519e:	11 24       	eor	r1, r1
    51a0:	ed 5e       	subi	r30, 0xED	; 237
    51a2:	f2 4f       	sbci	r31, 0xF2	; 242
    51a4:	10 8a       	std	Z+16, r1	; 0x10
    51a6:	8f b7       	in	r24, 0x3f	; 63
    51a8:	80 68       	ori	r24, 0x80	; 128
    51aa:	8f bf       	out	0x3f, r24	; 63
    51ac:	84 89       	ldd	r24, Z+20	; 0x14
    51ae:	81 30       	cpi	r24, 0x01	; 1
    51b0:	09 f0       	breq	.+2      	; 0x51b4 <SENSORS_BEACON+0xcc>
    51b2:	42 c0       	rjmp	.+132    	; 0x5238 <SENSORS_BEACON+0x150>
    51b4:	6f 01       	movw	r12, r30
    51b6:	e3 89       	ldd	r30, Z+19	; 0x13
    51b8:	f0 e0       	ldi	r31, 0x00	; 0
    51ba:	ec 5e       	subi	r30, 0xEC	; 236
    51bc:	fe 4f       	sbci	r31, 0xFE	; 254
    51be:	80 81       	ld	r24, Z
    51c0:	0e 94 c0 10 	call	0x2180	; 0x2180 <NRF_UPDATE_USED_CHANNEL>
    51c4:	8e e1       	ldi	r24, 0x1E	; 30
    51c6:	93 e0       	ldi	r25, 0x03	; 3
    51c8:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    51cc:	2a 2d       	mov	r18, r10
    51ce:	3b 2d       	mov	r19, r11
    51d0:	44 2d       	mov	r20, r4
    51d2:	55 2d       	mov	r21, r5
    51d4:	66 2d       	mov	r22, r6
    51d6:	77 2d       	mov	r23, r7
    51d8:	88 2d       	mov	r24, r8
    51da:	99 2d       	mov	r25, r9
    51dc:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    51e0:	8a e0       	ldi	r24, 0x0A	; 10
    51e2:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    51e6:	f6 01       	movw	r30, r12
    51e8:	40 81       	ld	r20, Z
    51ea:	62 85       	ldd	r22, Z+10	; 0x0a
    51ec:	9e 01       	movw	r18, r28
    51ee:	2c 5e       	subi	r18, 0xEC	; 236
    51f0:	3f 4f       	sbci	r19, 0xFF	; 255
    51f2:	ce 01       	movw	r24, r28
    51f4:	9a d8       	rcall	.-3788   	; 0x432a <PROTOCOL_SEND_BEACON>
    51f6:	88 23       	and	r24, r24
    51f8:	a1 f0       	breq	.+40     	; 0x5222 <SENSORS_BEACON+0x13a>
    51fa:	82 e2       	ldi	r24, 0x22	; 34
    51fc:	93 e0       	ldi	r25, 0x03	; 3
    51fe:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5202:	2a 2d       	mov	r18, r10
    5204:	3b 2d       	mov	r19, r11
    5206:	44 2d       	mov	r20, r4
    5208:	55 2d       	mov	r21, r5
    520a:	66 2d       	mov	r22, r6
    520c:	77 2d       	mov	r23, r7
    520e:	88 2d       	mov	r24, r8
    5210:	99 2d       	mov	r25, r9
    5212:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    5216:	8a e0       	ldi	r24, 0x0A	; 10
    5218:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    521c:	f6 01       	movw	r30, r12
    521e:	11 8a       	std	Z+17, r1	; 0x11
    5220:	15 c0       	rjmp	.+42     	; 0x524c <SENSORS_BEACON+0x164>
    5222:	30 9e       	mul	r3, r16
    5224:	f0 01       	movw	r30, r0
    5226:	31 9e       	mul	r3, r17
    5228:	f0 0d       	add	r31, r0
    522a:	11 24       	eor	r1, r1
    522c:	ed 5e       	subi	r30, 0xED	; 237
    522e:	f2 4f       	sbci	r31, 0xF2	; 242
    5230:	81 89       	ldd	r24, Z+17	; 0x11
    5232:	8f 5f       	subi	r24, 0xFF	; 255
    5234:	81 8b       	std	Z+17, r24	; 0x11
    5236:	0a c0       	rjmp	.+20     	; 0x524c <SENSORS_BEACON+0x164>
    5238:	30 9e       	mul	r3, r16
    523a:	f0 01       	movw	r30, r0
    523c:	31 9e       	mul	r3, r17
    523e:	f0 0d       	add	r31, r0
    5240:	11 24       	eor	r1, r1
    5242:	ed 5e       	subi	r30, 0xED	; 237
    5244:	f2 4f       	sbci	r31, 0xF2	; 242
    5246:	81 89       	ldd	r24, Z+17	; 0x11
    5248:	8f 5f       	subi	r24, 0xFF	; 255
    524a:	81 8b       	std	Z+17, r24	; 0x11
    524c:	30 9e       	mul	r3, r16
    524e:	f0 01       	movw	r30, r0
    5250:	31 9e       	mul	r3, r17
    5252:	f0 0d       	add	r31, r0
    5254:	11 24       	eor	r1, r1
    5256:	ed 5e       	subi	r30, 0xED	; 237
    5258:	f2 4f       	sbci	r31, 0xF2	; 242
    525a:	81 89       	ldd	r24, Z+17	; 0x11
    525c:	85 30       	cpi	r24, 0x05	; 5
    525e:	f9 f4       	brne	.+62     	; 0x529e <SENSORS_BEACON+0x1b6>
    5260:	30 9e       	mul	r3, r16
    5262:	f0 01       	movw	r30, r0
    5264:	31 9e       	mul	r3, r17
    5266:	f0 0d       	add	r31, r0
    5268:	11 24       	eor	r1, r1
    526a:	ed 5e       	subi	r30, 0xED	; 237
    526c:	f2 4f       	sbci	r31, 0xF2	; 242
    526e:	11 8a       	std	Z+17, r1	; 0x11
    5270:	16 86       	std	Z+14, r1	; 0x0e
    5272:	13 8a       	std	Z+19, r1	; 0x13
    5274:	10 8a       	std	Z+16, r1	; 0x10
    5276:	17 86       	std	Z+15, r1	; 0x0f
    5278:	12 8a       	std	Z+18, r1	; 0x12
    527a:	14 8a       	std	Z+20, r1	; 0x14
    527c:	8b e2       	ldi	r24, 0x2B	; 43
    527e:	93 e0       	ldi	r25, 0x03	; 3
    5280:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5284:	2a 2d       	mov	r18, r10
    5286:	3b 2d       	mov	r19, r11
    5288:	44 2d       	mov	r20, r4
    528a:	55 2d       	mov	r21, r5
    528c:	66 2d       	mov	r22, r6
    528e:	77 2d       	mov	r23, r7
    5290:	88 2d       	mov	r24, r8
    5292:	99 2d       	mov	r25, r9
    5294:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    5298:	8a e0       	ldi	r24, 0x0A	; 10
    529a:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    529e:	2a 2d       	mov	r18, r10
    52a0:	3b 2d       	mov	r19, r11
    52a2:	44 2d       	mov	r20, r4
    52a4:	55 2d       	mov	r21, r5
    52a6:	66 2d       	mov	r22, r6
    52a8:	77 2d       	mov	r23, r7
    52aa:	88 2d       	mov	r24, r8
    52ac:	99 2d       	mov	r25, r9
    52ae:	a1 e0       	ldi	r26, 0x01	; 1
    52b0:	0e 94 f9 42 	call	0x85f2	; 0x85f2 <__adddi3_s8>
    52b4:	a2 2e       	mov	r10, r18
    52b6:	b3 2e       	mov	r11, r19
    52b8:	44 2e       	mov	r4, r20
    52ba:	55 2e       	mov	r5, r21
    52bc:	66 2e       	mov	r6, r22
    52be:	77 2e       	mov	r7, r23
    52c0:	88 2e       	mov	r8, r24
    52c2:	99 2e       	mov	r9, r25
    52c4:	69 96       	adiw	r28, 0x19	; 25
    52c6:	ce 15       	cp	r28, r14
    52c8:	df 05       	cpc	r29, r15
    52ca:	09 f0       	breq	.+2      	; 0x52ce <SENSORS_BEACON+0x1e6>
    52cc:	32 cf       	rjmp	.-412    	; 0x5132 <SENSORS_BEACON+0x4a>
    52ce:	df 91       	pop	r29
    52d0:	cf 91       	pop	r28
    52d2:	1f 91       	pop	r17
    52d4:	0f 91       	pop	r16
    52d6:	ff 90       	pop	r15
    52d8:	ef 90       	pop	r14
    52da:	df 90       	pop	r13
    52dc:	cf 90       	pop	r12
    52de:	bf 90       	pop	r11
    52e0:	af 90       	pop	r10
    52e2:	9f 90       	pop	r9
    52e4:	8f 90       	pop	r8
    52e6:	7f 90       	pop	r7
    52e8:	6f 90       	pop	r6
    52ea:	5f 90       	pop	r5
    52ec:	4f 90       	pop	r4
    52ee:	3f 90       	pop	r3
    52f0:	08 95       	ret

000052f2 <SENSORS_NEW_SESSIONS>:
    52f2:	2f 92       	push	r2
    52f4:	3f 92       	push	r3
    52f6:	4f 92       	push	r4
    52f8:	5f 92       	push	r5
    52fa:	6f 92       	push	r6
    52fc:	7f 92       	push	r7
    52fe:	8f 92       	push	r8
    5300:	9f 92       	push	r9
    5302:	af 92       	push	r10
    5304:	bf 92       	push	r11
    5306:	cf 92       	push	r12
    5308:	df 92       	push	r13
    530a:	ef 92       	push	r14
    530c:	ff 92       	push	r15
    530e:	0f 93       	push	r16
    5310:	1f 93       	push	r17
    5312:	cf 93       	push	r28
    5314:	df 93       	push	r29
    5316:	00 d0       	rcall	.+0      	; 0x5318 <SENSORS_NEW_SESSIONS+0x26>
    5318:	00 d0       	rcall	.+0      	; 0x531a <SENSORS_NEW_SESSIONS+0x28>
    531a:	cd b7       	in	r28, 0x3d	; 61
    531c:	de b7       	in	r29, 0x3e	; 62
    531e:	0f 2e       	mov	r0, r31
    5320:	f4 e1       	ldi	r31, 0x14	; 20
    5322:	ef 2e       	mov	r14, r31
    5324:	fd e0       	ldi	r31, 0x0D	; 13
    5326:	ff 2e       	mov	r15, r31
    5328:	f0 2d       	mov	r31, r0
    532a:	0f 2e       	mov	r0, r31
    532c:	fe e0       	ldi	r31, 0x0E	; 14
    532e:	af 2e       	mov	r10, r31
    5330:	fe e0       	ldi	r31, 0x0E	; 14
    5332:	bf 2e       	mov	r11, r31
    5334:	f0 2d       	mov	r31, r0
    5336:	81 2c       	mov	r8, r1
    5338:	91 2c       	mov	r9, r1
    533a:	21 2c       	mov	r2, r1
    533c:	31 2c       	mov	r3, r1
    533e:	41 2c       	mov	r4, r1
    5340:	51 2c       	mov	r5, r1
    5342:	61 2c       	mov	r6, r1
    5344:	71 2c       	mov	r7, r1
    5346:	88 2d       	mov	r24, r8
    5348:	99 2d       	mov	r25, r9
    534a:	6c 01       	movw	r12, r24
    534c:	29 e1       	ldi	r18, 0x19	; 25
    534e:	28 9f       	mul	r18, r24
    5350:	f0 01       	movw	r30, r0
    5352:	29 9f       	mul	r18, r25
    5354:	f0 0d       	add	r31, r0
    5356:	11 24       	eor	r1, r1
    5358:	ed 5e       	subi	r30, 0xED	; 237
    535a:	f2 4f       	sbci	r31, 0xF2	; 242
    535c:	25 85       	ldd	r18, Z+13	; 0x0d
    535e:	21 30       	cpi	r18, 0x01	; 1
    5360:	09 f0       	breq	.+2      	; 0x5364 <SENSORS_NEW_SESSIONS+0x72>
    5362:	a6 c0       	rjmp	.+332    	; 0x54b0 <SENSORS_NEW_SESSIONS+0x1be>
    5364:	a9 e1       	ldi	r26, 0x19	; 25
    5366:	a8 9f       	mul	r26, r24
    5368:	f0 01       	movw	r30, r0
    536a:	a9 9f       	mul	r26, r25
    536c:	f0 0d       	add	r31, r0
    536e:	11 24       	eor	r1, r1
    5370:	ed 5e       	subi	r30, 0xED	; 237
    5372:	f2 4f       	sbci	r31, 0xF2	; 242
    5374:	84 85       	ldd	r24, Z+12	; 0x0c
    5376:	81 30       	cpi	r24, 0x01	; 1
    5378:	09 f0       	breq	.+2      	; 0x537c <SENSORS_NEW_SESSIONS+0x8a>
    537a:	9a c0       	rjmp	.+308    	; 0x54b0 <SENSORS_NEW_SESSIONS+0x1be>
    537c:	ac 9d       	mul	r26, r12
    537e:	f0 01       	movw	r30, r0
    5380:	ad 9d       	mul	r26, r13
    5382:	f0 0d       	add	r31, r0
    5384:	11 24       	eor	r1, r1
    5386:	ed 5e       	subi	r30, 0xED	; 237
    5388:	f2 4f       	sbci	r31, 0xF2	; 242
    538a:	86 85       	ldd	r24, Z+14	; 0x0e
    538c:	81 30       	cpi	r24, 0x01	; 1
    538e:	09 f0       	breq	.+2      	; 0x5392 <SENSORS_NEW_SESSIONS+0xa0>
    5390:	8f c0       	rjmp	.+286    	; 0x54b0 <SENSORS_NEW_SESSIONS+0x1be>
    5392:	ac 9d       	mul	r26, r12
    5394:	f0 01       	movw	r30, r0
    5396:	ad 9d       	mul	r26, r13
    5398:	f0 0d       	add	r31, r0
    539a:	11 24       	eor	r1, r1
    539c:	ed 5e       	subi	r30, 0xED	; 237
    539e:	f2 4f       	sbci	r31, 0xF2	; 242
    53a0:	84 89       	ldd	r24, Z+20	; 0x14
    53a2:	88 23       	and	r24, r24
    53a4:	59 f0       	breq	.+22     	; 0x53bc <SENSORS_NEW_SESSIONS+0xca>
    53a6:	ac 9d       	mul	r26, r12
    53a8:	f0 01       	movw	r30, r0
    53aa:	ad 9d       	mul	r26, r13
    53ac:	f0 0d       	add	r31, r0
    53ae:	11 24       	eor	r1, r1
    53b0:	ed 5e       	subi	r30, 0xED	; 237
    53b2:	f2 4f       	sbci	r31, 0xF2	; 242
    53b4:	82 89       	ldd	r24, Z+18	; 0x12
    53b6:	88 32       	cpi	r24, 0x28	; 40
    53b8:	09 f0       	breq	.+2      	; 0x53bc <SENSORS_NEW_SESSIONS+0xca>
    53ba:	7a c0       	rjmp	.+244    	; 0x54b0 <SENSORS_NEW_SESSIONS+0x1be>
    53bc:	b9 e1       	ldi	r27, 0x19	; 25
    53be:	bc 9d       	mul	r27, r12
    53c0:	80 01       	movw	r16, r0
    53c2:	bd 9d       	mul	r27, r13
    53c4:	10 0d       	add	r17, r0
    53c6:	11 24       	eor	r1, r1
    53c8:	0d 5e       	subi	r16, 0xED	; 237
    53ca:	12 4f       	sbci	r17, 0xF2	; 242
    53cc:	d8 01       	movw	r26, r16
    53ce:	53 96       	adiw	r26, 0x13	; 19
    53d0:	ec 91       	ld	r30, X
    53d2:	f0 e0       	ldi	r31, 0x00	; 0
    53d4:	ec 5e       	subi	r30, 0xEC	; 236
    53d6:	fe 4f       	sbci	r31, 0xFE	; 254
    53d8:	80 81       	ld	r24, Z
    53da:	0e 94 c0 10 	call	0x2180	; 0x2180 <NRF_UPDATE_USED_CHANNEL>
    53de:	d3 dc       	rcall	.-1626   	; 0x4d86 <GENNERATE_RANDOM_NUMBER>
    53e0:	9c 83       	std	Y+4, r25	; 0x04
    53e2:	8b 83       	std	Y+3, r24	; 0x03
    53e4:	8b 81       	ldd	r24, Y+3	; 0x03
    53e6:	9c 81       	ldd	r25, Y+4	; 0x04
    53e8:	99 83       	std	Y+1, r25	; 0x01
    53ea:	8b 81       	ldd	r24, Y+3	; 0x03
    53ec:	9c 81       	ldd	r25, Y+4	; 0x04
    53ee:	8a 83       	std	Y+2, r24	; 0x02
    53f0:	80 e4       	ldi	r24, 0x40	; 64
    53f2:	93 e0       	ldi	r25, 0x03	; 3
    53f4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    53f8:	28 2d       	mov	r18, r8
    53fa:	39 2d       	mov	r19, r9
    53fc:	42 2d       	mov	r20, r2
    53fe:	53 2d       	mov	r21, r3
    5400:	64 2d       	mov	r22, r4
    5402:	75 2d       	mov	r23, r5
    5404:	86 2d       	mov	r24, r6
    5406:	97 2d       	mov	r25, r7
    5408:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    540c:	8a e0       	ldi	r24, 0x0A	; 10
    540e:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    5412:	f8 01       	movw	r30, r16
    5414:	40 81       	ld	r20, Z
    5416:	62 85       	ldd	r22, Z+10	; 0x0a
    5418:	87 01       	movw	r16, r14
    541a:	0b 5f       	subi	r16, 0xFB	; 251
    541c:	1f 4f       	sbci	r17, 0xFF	; 255
    541e:	9e 01       	movw	r18, r28
    5420:	2f 5f       	subi	r18, 0xFF	; 255
    5422:	3f 4f       	sbci	r19, 0xFF	; 255
    5424:	c7 01       	movw	r24, r14
    5426:	20 d8       	rcall	.-4032   	; 0x4468 <PROTOCOL_SEND_SESSION_KEY>
    5428:	88 23       	and	r24, r24
    542a:	09 f4       	brne	.+2      	; 0x542e <SENSORS_NEW_SESSIONS+0x13c>
    542c:	41 c0       	rjmp	.+130    	; 0x54b0 <SENSORS_NEW_SESSIONS+0x1be>
    542e:	f9 e1       	ldi	r31, 0x19	; 25
    5430:	fc 9d       	mul	r31, r12
    5432:	80 01       	movw	r16, r0
    5434:	fd 9d       	mul	r31, r13
    5436:	10 0d       	add	r17, r0
    5438:	11 24       	eor	r1, r1
    543a:	0d 5e       	subi	r16, 0xED	; 237
    543c:	12 4f       	sbci	r17, 0xF2	; 242
    543e:	e1 e0       	ldi	r30, 0x01	; 1
    5440:	d8 01       	movw	r26, r16
    5442:	54 96       	adiw	r26, 0x14	; 20
    5444:	ec 93       	st	X, r30
    5446:	54 97       	sbiw	r26, 0x14	; 20
    5448:	52 96       	adiw	r26, 0x12	; 18
    544a:	1c 92       	st	X, r1
    544c:	52 97       	sbiw	r26, 0x12	; 18
    544e:	89 81       	ldd	r24, Y+1	; 0x01
    5450:	55 96       	adiw	r26, 0x15	; 21
    5452:	8c 93       	st	X, r24
    5454:	55 97       	sbiw	r26, 0x15	; 21
    5456:	8a 81       	ldd	r24, Y+2	; 0x02
    5458:	56 96       	adiw	r26, 0x16	; 22
    545a:	8c 93       	st	X, r24
    545c:	56 97       	sbiw	r26, 0x16	; 22
    545e:	51 96       	adiw	r26, 0x11	; 17
    5460:	1c 92       	st	X, r1
    5462:	82 e5       	ldi	r24, 0x52	; 82
    5464:	93 e0       	ldi	r25, 0x03	; 3
    5466:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    546a:	d8 01       	movw	r26, r16
    546c:	55 96       	adiw	r26, 0x15	; 21
    546e:	8c 91       	ld	r24, X
    5470:	55 97       	sbiw	r26, 0x15	; 21
    5472:	56 96       	adiw	r26, 0x16	; 22
    5474:	4c 91       	ld	r20, X
    5476:	50 e0       	ldi	r21, 0x00	; 0
    5478:	58 2b       	or	r21, r24
    547a:	24 2f       	mov	r18, r20
    547c:	35 2f       	mov	r19, r21
    547e:	40 e0       	ldi	r20, 0x00	; 0
    5480:	50 e0       	ldi	r21, 0x00	; 0
    5482:	60 e0       	ldi	r22, 0x00	; 0
    5484:	70 e0       	ldi	r23, 0x00	; 0
    5486:	80 e0       	ldi	r24, 0x00	; 0
    5488:	90 e0       	ldi	r25, 0x00	; 0
    548a:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    548e:	8c e5       	ldi	r24, 0x5C	; 92
    5490:	93 e0       	ldi	r25, 0x03	; 3
    5492:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5496:	28 2d       	mov	r18, r8
    5498:	39 2d       	mov	r19, r9
    549a:	42 2d       	mov	r20, r2
    549c:	53 2d       	mov	r21, r3
    549e:	64 2d       	mov	r22, r4
    54a0:	75 2d       	mov	r23, r5
    54a2:	86 2d       	mov	r24, r6
    54a4:	97 2d       	mov	r25, r7
    54a6:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    54aa:	8a e0       	ldi	r24, 0x0A	; 10
    54ac:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    54b0:	28 2d       	mov	r18, r8
    54b2:	39 2d       	mov	r19, r9
    54b4:	42 2d       	mov	r20, r2
    54b6:	53 2d       	mov	r21, r3
    54b8:	64 2d       	mov	r22, r4
    54ba:	75 2d       	mov	r23, r5
    54bc:	86 2d       	mov	r24, r6
    54be:	97 2d       	mov	r25, r7
    54c0:	a1 e0       	ldi	r26, 0x01	; 1
    54c2:	0e 94 f9 42 	call	0x85f2	; 0x85f2 <__adddi3_s8>
    54c6:	82 2e       	mov	r8, r18
    54c8:	93 2e       	mov	r9, r19
    54ca:	24 2e       	mov	r2, r20
    54cc:	35 2e       	mov	r3, r21
    54ce:	46 2e       	mov	r4, r22
    54d0:	57 2e       	mov	r5, r23
    54d2:	68 2e       	mov	r6, r24
    54d4:	79 2e       	mov	r7, r25
    54d6:	b9 e1       	ldi	r27, 0x19	; 25
    54d8:	eb 0e       	add	r14, r27
    54da:	f1 1c       	adc	r15, r1
    54dc:	ea 14       	cp	r14, r10
    54de:	fb 04       	cpc	r15, r11
    54e0:	09 f0       	breq	.+2      	; 0x54e4 <SENSORS_NEW_SESSIONS+0x1f2>
    54e2:	31 cf       	rjmp	.-414    	; 0x5346 <SENSORS_NEW_SESSIONS+0x54>
    54e4:	0f 90       	pop	r0
    54e6:	0f 90       	pop	r0
    54e8:	0f 90       	pop	r0
    54ea:	0f 90       	pop	r0
    54ec:	df 91       	pop	r29
    54ee:	cf 91       	pop	r28
    54f0:	1f 91       	pop	r17
    54f2:	0f 91       	pop	r16
    54f4:	ff 90       	pop	r15
    54f6:	ef 90       	pop	r14
    54f8:	df 90       	pop	r13
    54fa:	cf 90       	pop	r12
    54fc:	bf 90       	pop	r11
    54fe:	af 90       	pop	r10
    5500:	9f 90       	pop	r9
    5502:	8f 90       	pop	r8
    5504:	7f 90       	pop	r7
    5506:	6f 90       	pop	r6
    5508:	5f 90       	pop	r5
    550a:	4f 90       	pop	r4
    550c:	3f 90       	pop	r3
    550e:	2f 90       	pop	r2
    5510:	08 95       	ret

00005512 <SENSORS_CHANGE_CHANNEL>:
    5512:	2f 92       	push	r2
    5514:	3f 92       	push	r3
    5516:	4f 92       	push	r4
    5518:	5f 92       	push	r5
    551a:	6f 92       	push	r6
    551c:	7f 92       	push	r7
    551e:	8f 92       	push	r8
    5520:	9f 92       	push	r9
    5522:	af 92       	push	r10
    5524:	bf 92       	push	r11
    5526:	cf 92       	push	r12
    5528:	df 92       	push	r13
    552a:	ef 92       	push	r14
    552c:	ff 92       	push	r15
    552e:	0f 93       	push	r16
    5530:	1f 93       	push	r17
    5532:	cf 93       	push	r28
    5534:	df 93       	push	r29
    5536:	00 d0       	rcall	.+0      	; 0x5538 <SENSORS_CHANGE_CHANNEL+0x26>
    5538:	00 d0       	rcall	.+0      	; 0x553a <SENSORS_CHANGE_CHANNEL+0x28>
    553a:	cd b7       	in	r28, 0x3d	; 61
    553c:	de b7       	in	r29, 0x3e	; 62
    553e:	24 e1       	ldi	r18, 0x14	; 20
    5540:	3d e0       	ldi	r19, 0x0D	; 13
    5542:	3c 83       	std	Y+4, r19	; 0x04
    5544:	2b 83       	std	Y+3, r18	; 0x03
    5546:	0f 2e       	mov	r0, r31
    5548:	fe e0       	ldi	r31, 0x0E	; 14
    554a:	cf 2e       	mov	r12, r31
    554c:	fe e0       	ldi	r31, 0x0E	; 14
    554e:	df 2e       	mov	r13, r31
    5550:	f0 2d       	mov	r31, r0
    5552:	91 2c       	mov	r9, r1
    5554:	10 e0       	ldi	r17, 0x00	; 0
    5556:	31 2c       	mov	r3, r1
    5558:	41 2c       	mov	r4, r1
    555a:	51 2c       	mov	r5, r1
    555c:	61 2c       	mov	r6, r1
    555e:	71 2c       	mov	r7, r1
    5560:	81 2c       	mov	r8, r1
    5562:	0f 2e       	mov	r0, r31
    5564:	f9 e1       	ldi	r31, 0x19	; 25
    5566:	2f 2e       	mov	r2, r31
    5568:	f0 2d       	mov	r31, r0
    556a:	0f 2e       	mov	r0, r31
    556c:	f4 e1       	ldi	r31, 0x14	; 20
    556e:	af 2e       	mov	r10, r31
    5570:	f1 e0       	ldi	r31, 0x01	; 1
    5572:	bf 2e       	mov	r11, r31
    5574:	f0 2d       	mov	r31, r0
    5576:	89 2d       	mov	r24, r9
    5578:	91 2f       	mov	r25, r17
    557a:	7c 01       	movw	r14, r24
    557c:	28 9e       	mul	r2, r24
    557e:	f0 01       	movw	r30, r0
    5580:	29 9e       	mul	r2, r25
    5582:	f0 0d       	add	r31, r0
    5584:	11 24       	eor	r1, r1
    5586:	ed 5e       	subi	r30, 0xED	; 237
    5588:	f2 4f       	sbci	r31, 0xF2	; 242
    558a:	25 85       	ldd	r18, Z+13	; 0x0d
    558c:	21 30       	cpi	r18, 0x01	; 1
    558e:	09 f0       	breq	.+2      	; 0x5592 <SENSORS_CHANGE_CHANNEL+0x80>
    5590:	a2 c0       	rjmp	.+324    	; 0x56d6 <SENSORS_CHANGE_CHANNEL+0x1c4>
    5592:	28 9e       	mul	r2, r24
    5594:	f0 01       	movw	r30, r0
    5596:	29 9e       	mul	r2, r25
    5598:	f0 0d       	add	r31, r0
    559a:	11 24       	eor	r1, r1
    559c:	ed 5e       	subi	r30, 0xED	; 237
    559e:	f2 4f       	sbci	r31, 0xF2	; 242
    55a0:	84 85       	ldd	r24, Z+12	; 0x0c
    55a2:	81 30       	cpi	r24, 0x01	; 1
    55a4:	09 f0       	breq	.+2      	; 0x55a8 <SENSORS_CHANGE_CHANNEL+0x96>
    55a6:	97 c0       	rjmp	.+302    	; 0x56d6 <SENSORS_CHANGE_CHANNEL+0x1c4>
    55a8:	2e 9c       	mul	r2, r14
    55aa:	f0 01       	movw	r30, r0
    55ac:	2f 9c       	mul	r2, r15
    55ae:	f0 0d       	add	r31, r0
    55b0:	11 24       	eor	r1, r1
    55b2:	ed 5e       	subi	r30, 0xED	; 237
    55b4:	f2 4f       	sbci	r31, 0xF2	; 242
    55b6:	86 85       	ldd	r24, Z+14	; 0x0e
    55b8:	81 30       	cpi	r24, 0x01	; 1
    55ba:	09 f0       	breq	.+2      	; 0x55be <SENSORS_CHANGE_CHANNEL+0xac>
    55bc:	8c c0       	rjmp	.+280    	; 0x56d6 <SENSORS_CHANGE_CHANNEL+0x1c4>
    55be:	2e 9c       	mul	r2, r14
    55c0:	f0 01       	movw	r30, r0
    55c2:	2f 9c       	mul	r2, r15
    55c4:	f0 0d       	add	r31, r0
    55c6:	11 24       	eor	r1, r1
    55c8:	ed 5e       	subi	r30, 0xED	; 237
    55ca:	f2 4f       	sbci	r31, 0xF2	; 242
    55cc:	84 89       	ldd	r24, Z+20	; 0x14
    55ce:	81 30       	cpi	r24, 0x01	; 1
    55d0:	09 f0       	breq	.+2      	; 0x55d4 <SENSORS_CHANGE_CHANNEL+0xc2>
    55d2:	81 c0       	rjmp	.+258    	; 0x56d6 <SENSORS_CHANGE_CHANNEL+0x1c4>
    55d4:	2e 9c       	mul	r2, r14
    55d6:	f0 01       	movw	r30, r0
    55d8:	2f 9c       	mul	r2, r15
    55da:	f0 0d       	add	r31, r0
    55dc:	11 24       	eor	r1, r1
    55de:	ed 5e       	subi	r30, 0xED	; 237
    55e0:	f2 4f       	sbci	r31, 0xF2	; 242
    55e2:	83 89       	ldd	r24, Z+19	; 0x13
    55e4:	81 11       	cpse	r24, r1
    55e6:	77 c0       	rjmp	.+238    	; 0x56d6 <SENSORS_CHANGE_CHANNEL+0x1c4>
    55e8:	d5 01       	movw	r26, r10
    55ea:	8c 91       	ld	r24, X
    55ec:	0e 94 c0 10 	call	0x2180	; 0x2180 <NRF_UPDATE_USED_CHANNEL>
    55f0:	ca db       	rcall	.-2156   	; 0x4d86 <GENNERATE_RANDOM_NUMBER>
    55f2:	fc 01       	movw	r30, r24
    55f4:	9c 01       	movw	r18, r24
    55f6:	a3 e9       	ldi	r26, 0x93	; 147
    55f8:	b4 e2       	ldi	r27, 0x24	; 36
    55fa:	0e 94 32 42 	call	0x8464	; 0x8464 <__umulhisi3>
    55fe:	28 1b       	sub	r18, r24
    5600:	39 0b       	sbc	r19, r25
    5602:	36 95       	lsr	r19
    5604:	27 95       	ror	r18
    5606:	82 0f       	add	r24, r18
    5608:	93 1f       	adc	r25, r19
    560a:	ac 01       	movw	r20, r24
    560c:	56 95       	lsr	r21
    560e:	47 95       	ror	r20
    5610:	56 95       	lsr	r21
    5612:	47 95       	ror	r20
    5614:	ca 01       	movw	r24, r20
    5616:	88 0f       	add	r24, r24
    5618:	99 1f       	adc	r25, r25
    561a:	88 0f       	add	r24, r24
    561c:	99 1f       	adc	r25, r25
    561e:	88 0f       	add	r24, r24
    5620:	99 1f       	adc	r25, r25
    5622:	84 1b       	sub	r24, r20
    5624:	95 0b       	sbc	r25, r21
    5626:	af 01       	movw	r20, r30
    5628:	48 1b       	sub	r20, r24
    562a:	59 0b       	sbc	r21, r25
    562c:	fa 01       	movw	r30, r20
    562e:	31 96       	adiw	r30, 0x01	; 1
    5630:	fa 83       	std	Y+2, r31	; 0x02
    5632:	e9 83       	std	Y+1, r30	; 0x01
    5634:	83 e6       	ldi	r24, 0x63	; 99
    5636:	93 e0       	ldi	r25, 0x03	; 3
    5638:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    563c:	29 2d       	mov	r18, r9
    563e:	31 2f       	mov	r19, r17
    5640:	43 2d       	mov	r20, r3
    5642:	54 2d       	mov	r21, r4
    5644:	65 2d       	mov	r22, r5
    5646:	76 2d       	mov	r23, r6
    5648:	87 2d       	mov	r24, r7
    564a:	98 2d       	mov	r25, r8
    564c:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    5650:	8a e0       	ldi	r24, 0x0A	; 10
    5652:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    5656:	2e 9c       	mul	r2, r14
    5658:	f0 01       	movw	r30, r0
    565a:	2f 9c       	mul	r2, r15
    565c:	f0 0d       	add	r31, r0
    565e:	11 24       	eor	r1, r1
    5660:	ed 5e       	subi	r30, 0xED	; 237
    5662:	f2 4f       	sbci	r31, 0xF2	; 242
    5664:	40 81       	ld	r20, Z
    5666:	62 85       	ldd	r22, Z+10	; 0x0a
    5668:	09 81       	ldd	r16, Y+1	; 0x01
    566a:	2b 81       	ldd	r18, Y+3	; 0x03
    566c:	3c 81       	ldd	r19, Y+4	; 0x04
    566e:	2c 5e       	subi	r18, 0xEC	; 236
    5670:	3f 4f       	sbci	r19, 0xFF	; 255
    5672:	8b 81       	ldd	r24, Y+3	; 0x03
    5674:	9c 81       	ldd	r25, Y+4	; 0x04
    5676:	0e 94 eb 22 	call	0x45d6	; 0x45d6 <PROTOCOL_CHANGE_CHANNEL>
    567a:	88 23       	and	r24, r24
    567c:	61 f1       	breq	.+88     	; 0x56d6 <SENSORS_CHANGE_CHANNEL+0x1c4>
    567e:	2e 9c       	mul	r2, r14
    5680:	f0 01       	movw	r30, r0
    5682:	2f 9c       	mul	r2, r15
    5684:	f0 0d       	add	r31, r0
    5686:	11 24       	eor	r1, r1
    5688:	ed 5e       	subi	r30, 0xED	; 237
    568a:	f2 4f       	sbci	r31, 0xF2	; 242
    568c:	29 81       	ldd	r18, Y+1	; 0x01
    568e:	23 8b       	std	Z+19, r18	; 0x13
    5690:	11 8a       	std	Z+17, r1	; 0x11
    5692:	81 e7       	ldi	r24, 0x71	; 113
    5694:	93 e0       	ldi	r25, 0x03	; 3
    5696:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    569a:	e9 81       	ldd	r30, Y+1	; 0x01
    569c:	fa 81       	ldd	r31, Y+2	; 0x02
    569e:	af 01       	movw	r20, r30
    56a0:	2e 2f       	mov	r18, r30
    56a2:	35 2f       	mov	r19, r21
    56a4:	40 e0       	ldi	r20, 0x00	; 0
    56a6:	50 e0       	ldi	r21, 0x00	; 0
    56a8:	60 e0       	ldi	r22, 0x00	; 0
    56aa:	70 e0       	ldi	r23, 0x00	; 0
    56ac:	80 e0       	ldi	r24, 0x00	; 0
    56ae:	90 e0       	ldi	r25, 0x00	; 0
    56b0:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    56b4:	8c e5       	ldi	r24, 0x5C	; 92
    56b6:	93 e0       	ldi	r25, 0x03	; 3
    56b8:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    56bc:	29 2d       	mov	r18, r9
    56be:	31 2f       	mov	r19, r17
    56c0:	43 2d       	mov	r20, r3
    56c2:	54 2d       	mov	r21, r4
    56c4:	65 2d       	mov	r22, r5
    56c6:	76 2d       	mov	r23, r6
    56c8:	87 2d       	mov	r24, r7
    56ca:	98 2d       	mov	r25, r8
    56cc:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    56d0:	8a e0       	ldi	r24, 0x0A	; 10
    56d2:	0e 94 10 3d 	call	0x7a20	; 0x7a20 <TEST_UART_SEND_byte>
    56d6:	29 2d       	mov	r18, r9
    56d8:	31 2f       	mov	r19, r17
    56da:	43 2d       	mov	r20, r3
    56dc:	54 2d       	mov	r21, r4
    56de:	65 2d       	mov	r22, r5
    56e0:	76 2d       	mov	r23, r6
    56e2:	87 2d       	mov	r24, r7
    56e4:	98 2d       	mov	r25, r8
    56e6:	a1 e0       	ldi	r26, 0x01	; 1
    56e8:	0e 94 f9 42 	call	0x85f2	; 0x85f2 <__adddi3_s8>
    56ec:	92 2e       	mov	r9, r18
    56ee:	13 2f       	mov	r17, r19
    56f0:	34 2e       	mov	r3, r20
    56f2:	45 2e       	mov	r4, r21
    56f4:	56 2e       	mov	r5, r22
    56f6:	67 2e       	mov	r6, r23
    56f8:	78 2e       	mov	r7, r24
    56fa:	89 2e       	mov	r8, r25
    56fc:	2b 81       	ldd	r18, Y+3	; 0x03
    56fe:	3c 81       	ldd	r19, Y+4	; 0x04
    5700:	27 5e       	subi	r18, 0xE7	; 231
    5702:	3f 4f       	sbci	r19, 0xFF	; 255
    5704:	3c 83       	std	Y+4, r19	; 0x04
    5706:	2b 83       	std	Y+3, r18	; 0x03
    5708:	2c 15       	cp	r18, r12
    570a:	3d 05       	cpc	r19, r13
    570c:	09 f0       	breq	.+2      	; 0x5710 <SENSORS_CHANGE_CHANNEL+0x1fe>
    570e:	33 cf       	rjmp	.-410    	; 0x5576 <SENSORS_CHANGE_CHANNEL+0x64>
    5710:	0f 90       	pop	r0
    5712:	0f 90       	pop	r0
    5714:	0f 90       	pop	r0
    5716:	0f 90       	pop	r0
    5718:	df 91       	pop	r29
    571a:	cf 91       	pop	r28
    571c:	1f 91       	pop	r17
    571e:	0f 91       	pop	r16
    5720:	ff 90       	pop	r15
    5722:	ef 90       	pop	r14
    5724:	df 90       	pop	r13
    5726:	cf 90       	pop	r12
    5728:	bf 90       	pop	r11
    572a:	af 90       	pop	r10
    572c:	9f 90       	pop	r9
    572e:	8f 90       	pop	r8
    5730:	7f 90       	pop	r7
    5732:	6f 90       	pop	r6
    5734:	5f 90       	pop	r5
    5736:	4f 90       	pop	r4
    5738:	3f 90       	pop	r3
    573a:	2f 90       	pop	r2
    573c:	08 95       	ret

0000573e <SENSORS_APPLY_SEND_BUFFER>:
    573e:	5f 92       	push	r5
    5740:	6f 92       	push	r6
    5742:	7f 92       	push	r7
    5744:	8f 92       	push	r8
    5746:	9f 92       	push	r9
    5748:	af 92       	push	r10
    574a:	bf 92       	push	r11
    574c:	cf 92       	push	r12
    574e:	df 92       	push	r13
    5750:	ef 92       	push	r14
    5752:	ff 92       	push	r15
    5754:	0f 93       	push	r16
    5756:	1f 93       	push	r17
    5758:	cf 93       	push	r28
    575a:	df 93       	push	r29
    575c:	cd b7       	in	r28, 0x3d	; 61
    575e:	de b7       	in	r29, 0x3e	; 62
    5760:	c3 54       	subi	r28, 0x43	; 67
    5762:	d1 09       	sbc	r29, r1
    5764:	0f b6       	in	r0, 0x3f	; 63
    5766:	f8 94       	cli
    5768:	de bf       	out	0x3e, r29	; 62
    576a:	0f be       	out	0x3f, r0	; 63
    576c:	cd bf       	out	0x3d, r28	; 61
    576e:	80 91 51 0c 	lds	r24, 0x0C51
    5772:	88 23       	and	r24, r24
    5774:	09 f4       	brne	.+2      	; 0x5778 <SENSORS_APPLY_SEND_BUFFER+0x3a>
    5776:	6d c5       	rjmp	.+2778   	; 0x6252 <SENSORS_APPLY_SEND_BUFFER+0xb14>
    5778:	23 96       	adiw	r28, 0x03	; 3
    577a:	1f ae       	std	Y+63, r1	; 0x3f
    577c:	23 97       	sbiw	r28, 0x03	; 3
    577e:	21 96       	adiw	r28, 0x01	; 1
    5780:	1f ae       	std	Y+63, r1	; 0x3f
    5782:	21 97       	sbiw	r28, 0x01	; 1
    5784:	1b aa       	std	Y+51, r1	; 0x33
    5786:	1c aa       	std	Y+52, r1	; 0x34
    5788:	1d aa       	std	Y+53, r1	; 0x35
    578a:	1e aa       	std	Y+54, r1	; 0x36
    578c:	1f aa       	std	Y+55, r1	; 0x37
    578e:	18 ae       	std	Y+56, r1	; 0x38
    5790:	19 ae       	std	Y+57, r1	; 0x39
    5792:	1a ae       	std	Y+58, r1	; 0x3a
    5794:	23 96       	adiw	r28, 0x03	; 3
    5796:	1f ae       	std	Y+63, r1	; 0x3f
    5798:	23 97       	sbiw	r28, 0x03	; 3
    579a:	23 96       	adiw	r28, 0x03	; 3
    579c:	9f ad       	ldd	r25, Y+63	; 0x3f
    579e:	23 97       	sbiw	r28, 0x03	; 3
    57a0:	80 91 51 0c 	lds	r24, 0x0C51
    57a4:	98 17       	cp	r25, r24
    57a6:	08 f0       	brcs	.+2      	; 0x57aa <SENSORS_APPLY_SEND_BUFFER+0x6c>
    57a8:	52 c5       	rjmp	.+2724   	; 0x624e <SENSORS_APPLY_SEND_BUFFER+0xb10>
    57aa:	0f 2e       	mov	r0, r31
    57ac:	f9 e1       	ldi	r31, 0x19	; 25
    57ae:	7f 2e       	mov	r7, r31
    57b0:	f0 2d       	mov	r31, r0
    57b2:	55 24       	eor	r5, r5
    57b4:	53 94       	inc	r5
    57b6:	0f 2e       	mov	r0, r31
    57b8:	f1 e4       	ldi	r31, 0x41	; 65
    57ba:	6f 2e       	mov	r6, r31
    57bc:	f0 2d       	mov	r31, r0
    57be:	23 96       	adiw	r28, 0x03	; 3
    57c0:	8f ad       	ldd	r24, Y+63	; 0x3f
    57c2:	23 97       	sbiw	r28, 0x03	; 3
    57c4:	90 e0       	ldi	r25, 0x00	; 0
    57c6:	fc 01       	movw	r30, r24
    57c8:	ee 0f       	add	r30, r30
    57ca:	ff 1f       	adc	r31, r31
    57cc:	ee 0f       	add	r30, r30
    57ce:	ff 1f       	adc	r31, r31
    57d0:	8e 0f       	add	r24, r30
    57d2:	9f 1f       	adc	r25, r31
    57d4:	fc 01       	movw	r30, r24
    57d6:	e0 52       	subi	r30, 0x20	; 32
    57d8:	f3 4f       	sbci	r31, 0xF3	; 243
    57da:	80 81       	ld	r24, Z
    57dc:	22 96       	adiw	r28, 0x02	; 2
    57de:	8f af       	std	Y+63, r24	; 0x3f
    57e0:	22 97       	sbiw	r28, 0x02	; 2
    57e2:	22 96       	adiw	r28, 0x02	; 2
    57e4:	ef ad       	ldd	r30, Y+63	; 0x3f
    57e6:	22 97       	sbiw	r28, 0x02	; 2
    57e8:	7e 9e       	mul	r7, r30
    57ea:	f0 01       	movw	r30, r0
    57ec:	11 24       	eor	r1, r1
    57ee:	ed 5e       	subi	r30, 0xED	; 237
    57f0:	f2 4f       	sbci	r31, 0xF2	; 242
    57f2:	84 85       	ldd	r24, Z+12	; 0x0c
    57f4:	88 23       	and	r24, r24
    57f6:	09 f4       	brne	.+2      	; 0x57fa <SENSORS_APPLY_SEND_BUFFER+0xbc>
    57f8:	e2 c2       	rjmp	.+1476   	; 0x5dbe <SENSORS_APPLY_SEND_BUFFER+0x680>
    57fa:	22 96       	adiw	r28, 0x02	; 2
    57fc:	ef ad       	ldd	r30, Y+63	; 0x3f
    57fe:	22 97       	sbiw	r28, 0x02	; 2
    5800:	7e 9e       	mul	r7, r30
    5802:	f0 01       	movw	r30, r0
    5804:	11 24       	eor	r1, r1
    5806:	ed 5e       	subi	r30, 0xED	; 237
    5808:	f2 4f       	sbci	r31, 0xF2	; 242
    580a:	86 85       	ldd	r24, Z+14	; 0x0e
    580c:	88 23       	and	r24, r24
    580e:	09 f4       	brne	.+2      	; 0x5812 <SENSORS_APPLY_SEND_BUFFER+0xd4>
    5810:	d6 c2       	rjmp	.+1452   	; 0x5dbe <SENSORS_APPLY_SEND_BUFFER+0x680>
    5812:	22 96       	adiw	r28, 0x02	; 2
    5814:	ef ad       	ldd	r30, Y+63	; 0x3f
    5816:	22 97       	sbiw	r28, 0x02	; 2
    5818:	7e 9e       	mul	r7, r30
    581a:	f0 01       	movw	r30, r0
    581c:	11 24       	eor	r1, r1
    581e:	ed 5e       	subi	r30, 0xED	; 237
    5820:	f2 4f       	sbci	r31, 0xF2	; 242
    5822:	84 89       	ldd	r24, Z+20	; 0x14
    5824:	88 23       	and	r24, r24
    5826:	09 f4       	brne	.+2      	; 0x582a <SENSORS_APPLY_SEND_BUFFER+0xec>
    5828:	ca c2       	rjmp	.+1428   	; 0x5dbe <SENSORS_APPLY_SEND_BUFFER+0x680>
    582a:	23 96       	adiw	r28, 0x03	; 3
    582c:	8f ad       	ldd	r24, Y+63	; 0x3f
    582e:	23 97       	sbiw	r28, 0x03	; 3
    5830:	90 e0       	ldi	r25, 0x00	; 0
    5832:	fc 01       	movw	r30, r24
    5834:	ee 0f       	add	r30, r30
    5836:	ff 1f       	adc	r31, r31
    5838:	ee 0f       	add	r30, r30
    583a:	ff 1f       	adc	r31, r31
    583c:	8e 0f       	add	r24, r30
    583e:	9f 1f       	adc	r25, r31
    5840:	fc 01       	movw	r30, r24
    5842:	e0 52       	subi	r30, 0x20	; 32
    5844:	f3 4f       	sbci	r31, 0xF3	; 243
    5846:	21 81       	ldd	r18, Z+1	; 0x01
    5848:	23 96       	adiw	r28, 0x03	; 3
    584a:	8f ad       	ldd	r24, Y+63	; 0x3f
    584c:	23 97       	sbiw	r28, 0x03	; 3
    584e:	90 e0       	ldi	r25, 0x00	; 0
    5850:	fc 01       	movw	r30, r24
    5852:	ee 0f       	add	r30, r30
    5854:	ff 1f       	adc	r31, r31
    5856:	ee 0f       	add	r30, r30
    5858:	ff 1f       	adc	r31, r31
    585a:	8e 0f       	add	r24, r30
    585c:	9f 1f       	adc	r25, r31
    585e:	fc 01       	movw	r30, r24
    5860:	e0 52       	subi	r30, 0x20	; 32
    5862:	f3 4f       	sbci	r31, 0xF3	; 243
    5864:	82 81       	ldd	r24, Z+2	; 0x02
    5866:	90 e0       	ldi	r25, 0x00	; 0
    5868:	92 2b       	or	r25, r18
    586a:	9e af       	std	Y+62, r25	; 0x3e
    586c:	8d af       	std	Y+61, r24	; 0x3d
    586e:	23 96       	adiw	r28, 0x03	; 3
    5870:	8f ad       	ldd	r24, Y+63	; 0x3f
    5872:	23 97       	sbiw	r28, 0x03	; 3
    5874:	90 e0       	ldi	r25, 0x00	; 0
    5876:	fc 01       	movw	r30, r24
    5878:	ee 0f       	add	r30, r30
    587a:	ff 1f       	adc	r31, r31
    587c:	ee 0f       	add	r30, r30
    587e:	ff 1f       	adc	r31, r31
    5880:	8e 0f       	add	r24, r30
    5882:	9f 1f       	adc	r25, r31
    5884:	fc 01       	movw	r30, r24
    5886:	e0 52       	subi	r30, 0x20	; 32
    5888:	f3 4f       	sbci	r31, 0xF3	; 243
    588a:	23 81       	ldd	r18, Z+3	; 0x03
    588c:	23 96       	adiw	r28, 0x03	; 3
    588e:	8f ad       	ldd	r24, Y+63	; 0x3f
    5890:	23 97       	sbiw	r28, 0x03	; 3
    5892:	90 e0       	ldi	r25, 0x00	; 0
    5894:	fc 01       	movw	r30, r24
    5896:	ee 0f       	add	r30, r30
    5898:	ff 1f       	adc	r31, r31
    589a:	ee 0f       	add	r30, r30
    589c:	ff 1f       	adc	r31, r31
    589e:	8e 0f       	add	r24, r30
    58a0:	9f 1f       	adc	r25, r31
    58a2:	fc 01       	movw	r30, r24
    58a4:	e0 52       	subi	r30, 0x20	; 32
    58a6:	f3 4f       	sbci	r31, 0xF3	; 243
    58a8:	84 81       	ldd	r24, Z+4	; 0x04
    58aa:	90 e0       	ldi	r25, 0x00	; 0
    58ac:	92 2b       	or	r25, r18
    58ae:	9c af       	std	Y+60, r25	; 0x3c
    58b0:	8b af       	std	Y+59, r24	; 0x3b
    58b2:	8b e7       	ldi	r24, 0x7B	; 123
    58b4:	93 e0       	ldi	r25, 0x03	; 3
    58b6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    58ba:	8d ac       	ldd	r8, Y+61	; 0x3d
    58bc:	9e ac       	ldd	r9, Y+62	; 0x3e
    58be:	28 2d       	mov	r18, r8
    58c0:	39 2d       	mov	r19, r9
    58c2:	40 e0       	ldi	r20, 0x00	; 0
    58c4:	50 e0       	ldi	r21, 0x00	; 0
    58c6:	60 e0       	ldi	r22, 0x00	; 0
    58c8:	70 e0       	ldi	r23, 0x00	; 0
    58ca:	80 e0       	ldi	r24, 0x00	; 0
    58cc:	90 e0       	ldi	r25, 0x00	; 0
    58ce:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    58d2:	81 e9       	ldi	r24, 0x91	; 145
    58d4:	93 e0       	ldi	r25, 0x03	; 3
    58d6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    58da:	8b ac       	ldd	r8, Y+59	; 0x3b
    58dc:	9c ac       	ldd	r9, Y+60	; 0x3c
    58de:	28 2d       	mov	r18, r8
    58e0:	39 2d       	mov	r19, r9
    58e2:	40 e0       	ldi	r20, 0x00	; 0
    58e4:	50 e0       	ldi	r21, 0x00	; 0
    58e6:	60 e0       	ldi	r22, 0x00	; 0
    58e8:	70 e0       	ldi	r23, 0x00	; 0
    58ea:	80 e0       	ldi	r24, 0x00	; 0
    58ec:	90 e0       	ldi	r25, 0x00	; 0
    58ee:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    58f2:	84 e9       	ldi	r24, 0x94	; 148
    58f4:	91 e0       	ldi	r25, 0x01	; 1
    58f6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    58fa:	22 96       	adiw	r28, 0x02	; 2
    58fc:	ef ad       	ldd	r30, Y+63	; 0x3f
    58fe:	22 97       	sbiw	r28, 0x02	; 2
    5900:	7e 9e       	mul	r7, r30
    5902:	f0 01       	movw	r30, r0
    5904:	11 24       	eor	r1, r1
    5906:	ed 5e       	subi	r30, 0xED	; 237
    5908:	f2 4f       	sbci	r31, 0xF2	; 242
    590a:	e3 89       	ldd	r30, Z+19	; 0x13
    590c:	f0 e0       	ldi	r31, 0x00	; 0
    590e:	ec 5e       	subi	r30, 0xEC	; 236
    5910:	fe 4f       	sbci	r31, 0xFE	; 254
    5912:	80 81       	ld	r24, Z
    5914:	0e 94 c0 10 	call	0x2180	; 0x2180 <NRF_UPDATE_USED_CHANNEL>
    5918:	23 96       	adiw	r28, 0x03	; 3
    591a:	af ad       	ldd	r26, Y+63	; 0x3f
    591c:	23 97       	sbiw	r28, 0x03	; 3
    591e:	23 96       	adiw	r28, 0x03	; 3
    5920:	9f ad       	ldd	r25, Y+63	; 0x3f
    5922:	23 97       	sbiw	r28, 0x03	; 3
    5924:	22 96       	adiw	r28, 0x02	; 2
    5926:	2f ad       	ldd	r18, Y+63	; 0x3f
    5928:	22 97       	sbiw	r28, 0x02	; 2
    592a:	22 96       	adiw	r28, 0x02	; 2
    592c:	ef ad       	ldd	r30, Y+63	; 0x3f
    592e:	22 97       	sbiw	r28, 0x02	; 2
    5930:	7e 9e       	mul	r7, r30
    5932:	f0 01       	movw	r30, r0
    5934:	11 24       	eor	r1, r1
    5936:	ed 5e       	subi	r30, 0xED	; 237
    5938:	f2 4f       	sbci	r31, 0xF2	; 242
    593a:	40 81       	ld	r20, Z
    593c:	22 96       	adiw	r28, 0x02	; 2
    593e:	ef ad       	ldd	r30, Y+63	; 0x3f
    5940:	22 97       	sbiw	r28, 0x02	; 2
    5942:	7e 9e       	mul	r7, r30
    5944:	f0 01       	movw	r30, r0
    5946:	11 24       	eor	r1, r1
    5948:	ed 5e       	subi	r30, 0xED	; 237
    594a:	f2 4f       	sbci	r31, 0xF2	; 242
    594c:	62 85       	ldd	r22, Z+10	; 0x0a
    594e:	22 96       	adiw	r28, 0x02	; 2
    5950:	8f ad       	ldd	r24, Y+63	; 0x3f
    5952:	22 97       	sbiw	r28, 0x02	; 2
    5954:	b0 e0       	ldi	r27, 0x00	; 0
    5956:	7d 01       	movw	r14, r26
    5958:	ee 0c       	add	r14, r14
    595a:	ff 1c       	adc	r15, r15
    595c:	ee 0c       	add	r14, r14
    595e:	ff 1c       	adc	r15, r15
    5960:	ae 0d       	add	r26, r14
    5962:	bf 1d       	adc	r27, r15
    5964:	fd 01       	movw	r30, r26
    5966:	ed 51       	subi	r30, 0x1D	; 29
    5968:	f3 4f       	sbci	r31, 0xF3	; 243
    596a:	7f 01       	movw	r14, r30
    596c:	e9 2f       	mov	r30, r25
    596e:	f0 e0       	ldi	r31, 0x00	; 0
    5970:	8f 01       	movw	r16, r30
    5972:	00 0f       	add	r16, r16
    5974:	11 1f       	adc	r17, r17
    5976:	00 0f       	add	r16, r16
    5978:	11 1f       	adc	r17, r17
    597a:	e0 0f       	add	r30, r16
    597c:	f1 1f       	adc	r31, r17
    597e:	8f 01       	movw	r16, r30
    5980:	0f 51       	subi	r16, 0x1F	; 31
    5982:	13 4f       	sbci	r17, 0xF3	; 243
    5984:	72 9e       	mul	r7, r18
    5986:	90 01       	movw	r18, r0
    5988:	11 24       	eor	r1, r1
    598a:	28 5d       	subi	r18, 0xD8	; 216
    598c:	32 4f       	sbci	r19, 0xF2	; 242
    598e:	78 9e       	mul	r7, r24
    5990:	c0 01       	movw	r24, r0
    5992:	11 24       	eor	r1, r1
    5994:	8c 5e       	subi	r24, 0xEC	; 236
    5996:	92 4f       	sbci	r25, 0xF2	; 242
    5998:	0e 94 aa 23 	call	0x4754	; 0x4754 <PROTOCOL_DATA_SEND>
    599c:	88 23       	and	r24, r24
    599e:	09 f4       	brne	.+2      	; 0x59a2 <SENSORS_APPLY_SEND_BUFFER+0x264>
    59a0:	0e c2       	rjmp	.+1052   	; 0x5dbe <SENSORS_APPLY_SEND_BUFFER+0x680>
    59a2:	84 e9       	ldi	r24, 0x94	; 148
    59a4:	91 e0       	ldi	r25, 0x01	; 1
    59a6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    59aa:	84 e9       	ldi	r24, 0x94	; 148
    59ac:	91 e0       	ldi	r25, 0x01	; 1
    59ae:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    59b2:	84 e9       	ldi	r24, 0x94	; 148
    59b4:	91 e0       	ldi	r25, 0x01	; 1
    59b6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    59ba:	84 e9       	ldi	r24, 0x94	; 148
    59bc:	91 e0       	ldi	r25, 0x01	; 1
    59be:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    59c2:	84 e9       	ldi	r24, 0x94	; 148
    59c4:	91 e0       	ldi	r25, 0x01	; 1
    59c6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    59ca:	84 e9       	ldi	r24, 0x94	; 148
    59cc:	91 e0       	ldi	r25, 0x01	; 1
    59ce:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    59d2:	84 e9       	ldi	r24, 0x94	; 148
    59d4:	91 e0       	ldi	r25, 0x01	; 1
    59d6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    59da:	84 e9       	ldi	r24, 0x94	; 148
    59dc:	91 e0       	ldi	r25, 0x01	; 1
    59de:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    59e2:	86 ea       	ldi	r24, 0xA6	; 166
    59e4:	93 e0       	ldi	r25, 0x03	; 3
    59e6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    59ea:	22 96       	adiw	r28, 0x02	; 2
    59ec:	2f ad       	ldd	r18, Y+63	; 0x3f
    59ee:	22 97       	sbiw	r28, 0x02	; 2
    59f0:	30 e0       	ldi	r19, 0x00	; 0
    59f2:	40 e0       	ldi	r20, 0x00	; 0
    59f4:	50 e0       	ldi	r21, 0x00	; 0
    59f6:	60 e0       	ldi	r22, 0x00	; 0
    59f8:	70 e0       	ldi	r23, 0x00	; 0
    59fa:	80 e0       	ldi	r24, 0x00	; 0
    59fc:	90 e0       	ldi	r25, 0x00	; 0
    59fe:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    5a02:	84 e9       	ldi	r24, 0x94	; 148
    5a04:	91 e0       	ldi	r25, 0x01	; 1
    5a06:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5a0a:	84 e9       	ldi	r24, 0x94	; 148
    5a0c:	91 e0       	ldi	r25, 0x01	; 1
    5a0e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5a12:	84 e9       	ldi	r24, 0x94	; 148
    5a14:	91 e0       	ldi	r25, 0x01	; 1
    5a16:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5a1a:	84 e9       	ldi	r24, 0x94	; 148
    5a1c:	91 e0       	ldi	r25, 0x01	; 1
    5a1e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5a22:	84 e9       	ldi	r24, 0x94	; 148
    5a24:	91 e0       	ldi	r25, 0x01	; 1
    5a26:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5a2a:	84 e9       	ldi	r24, 0x94	; 148
    5a2c:	91 e0       	ldi	r25, 0x01	; 1
    5a2e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5a32:	84 e9       	ldi	r24, 0x94	; 148
    5a34:	91 e0       	ldi	r25, 0x01	; 1
    5a36:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5a3a:	84 e9       	ldi	r24, 0x94	; 148
    5a3c:	91 e0       	ldi	r25, 0x01	; 1
    5a3e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5a42:	22 96       	adiw	r28, 0x02	; 2
    5a44:	ef ad       	ldd	r30, Y+63	; 0x3f
    5a46:	22 97       	sbiw	r28, 0x02	; 2
    5a48:	7e 9e       	mul	r7, r30
    5a4a:	f0 01       	movw	r30, r0
    5a4c:	11 24       	eor	r1, r1
    5a4e:	ed 5e       	subi	r30, 0xED	; 237
    5a50:	f2 4f       	sbci	r31, 0xF2	; 242
    5a52:	11 8a       	std	Z+17, r1	; 0x11
    5a54:	22 96       	adiw	r28, 0x02	; 2
    5a56:	ef ad       	ldd	r30, Y+63	; 0x3f
    5a58:	22 97       	sbiw	r28, 0x02	; 2
    5a5a:	7e 9e       	mul	r7, r30
    5a5c:	f0 01       	movw	r30, r0
    5a5e:	11 24       	eor	r1, r1
    5a60:	ed 5e       	subi	r30, 0xED	; 237
    5a62:	f2 4f       	sbci	r31, 0xF2	; 242
    5a64:	17 8a       	std	Z+23, r1	; 0x17
    5a66:	21 96       	adiw	r28, 0x01	; 1
    5a68:	5f ae       	std	Y+63, r5	; 0x3f
    5a6a:	21 97       	sbiw	r28, 0x01	; 1
    5a6c:	69 82       	std	Y+1, r6	; 0x01
    5a6e:	8a e3       	ldi	r24, 0x3A	; 58
    5a70:	8a 83       	std	Y+2, r24	; 0x02
    5a72:	22 96       	adiw	r28, 0x02	; 2
    5a74:	ef ad       	ldd	r30, Y+63	; 0x3f
    5a76:	22 97       	sbiw	r28, 0x02	; 2
    5a78:	7e 9e       	mul	r7, r30
    5a7a:	f0 01       	movw	r30, r0
    5a7c:	11 24       	eor	r1, r1
    5a7e:	ed 5e       	subi	r30, 0xED	; 237
    5a80:	f2 4f       	sbci	r31, 0xF2	; 242
    5a82:	80 81       	ld	r24, Z
    5a84:	8f af       	std	Y+63, r24	; 0x3f
    5a86:	8f ad       	ldd	r24, Y+63	; 0x3f
    5a88:	88 23       	and	r24, r24
    5a8a:	31 f1       	breq	.+76     	; 0x5ad8 <SENSORS_APPLY_SEND_BUFFER+0x39a>
    5a8c:	2b a9       	ldd	r18, Y+51	; 0x33
    5a8e:	3c a9       	ldd	r19, Y+52	; 0x34
    5a90:	4d a9       	ldd	r20, Y+53	; 0x35
    5a92:	5e a9       	ldd	r21, Y+54	; 0x36
    5a94:	6f a9       	ldd	r22, Y+55	; 0x37
    5a96:	78 ad       	ldd	r23, Y+56	; 0x38
    5a98:	89 ad       	ldd	r24, Y+57	; 0x39
    5a9a:	9a ad       	ldd	r25, Y+58	; 0x3a
    5a9c:	22 96       	adiw	r28, 0x02	; 2
    5a9e:	af ad       	ldd	r26, Y+63	; 0x3f
    5aa0:	22 97       	sbiw	r28, 0x02	; 2
    5aa2:	ef ad       	ldd	r30, Y+63	; 0x3f
    5aa4:	f0 e0       	ldi	r31, 0x00	; 0
    5aa6:	7a 9e       	mul	r7, r26
    5aa8:	e0 0d       	add	r30, r0
    5aaa:	f1 1d       	adc	r31, r1
    5aac:	11 24       	eor	r1, r1
    5aae:	ee 5e       	subi	r30, 0xEE	; 238
    5ab0:	f2 4f       	sbci	r31, 0xF2	; 242
    5ab2:	e1 81       	ldd	r30, Z+1	; 0x01
    5ab4:	08 e0       	ldi	r16, 0x08	; 8
    5ab6:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    5aba:	e2 2b       	or	r30, r18
    5abc:	eb ab       	std	Y+51, r30	; 0x33
    5abe:	3c ab       	std	Y+52, r19	; 0x34
    5ac0:	4d ab       	std	Y+53, r20	; 0x35
    5ac2:	5e ab       	std	Y+54, r21	; 0x36
    5ac4:	6f ab       	std	Y+55, r22	; 0x37
    5ac6:	78 af       	std	Y+56, r23	; 0x38
    5ac8:	89 af       	std	Y+57, r24	; 0x39
    5aca:	9a af       	std	Y+58, r25	; 0x3a
    5acc:	8f ad       	ldd	r24, Y+63	; 0x3f
    5ace:	81 50       	subi	r24, 0x01	; 1
    5ad0:	8f af       	std	Y+63, r24	; 0x3f
    5ad2:	8f ad       	ldd	r24, Y+63	; 0x3f
    5ad4:	81 11       	cpse	r24, r1
    5ad6:	da cf       	rjmp	.-76     	; 0x5a8c <SENSORS_APPLY_SEND_BUFFER+0x34e>
    5ad8:	0b a9       	ldd	r16, Y+51	; 0x33
    5ada:	1c a9       	ldd	r17, Y+52	; 0x34
    5adc:	2d a9       	ldd	r18, Y+53	; 0x35
    5ade:	3e a9       	ldd	r19, Y+54	; 0x36
    5ae0:	4f a9       	ldd	r20, Y+55	; 0x37
    5ae2:	58 ad       	ldd	r21, Y+56	; 0x38
    5ae4:	69 ad       	ldd	r22, Y+57	; 0x39
    5ae6:	7a ad       	ldd	r23, Y+58	; 0x3a
    5ae8:	ce 01       	movw	r24, r28
    5aea:	4f 96       	adiw	r24, 0x1f	; 31
    5aec:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    5af0:	1f ae       	std	Y+63, r1	; 0x3f
    5af2:	9f ad       	ldd	r25, Y+63	; 0x3f
    5af4:	98 17       	cp	r25, r24
    5af6:	c0 f4       	brcc	.+48     	; 0x5b28 <SENSORS_APPLY_SEND_BUFFER+0x3ea>
    5af8:	ef ad       	ldd	r30, Y+63	; 0x3f
    5afa:	f0 e0       	ldi	r31, 0x00	; 0
    5afc:	32 96       	adiw	r30, 0x02	; 2
    5afe:	9f ad       	ldd	r25, Y+63	; 0x3f
    5b00:	af e1       	ldi	r26, 0x1F	; 31
    5b02:	b0 e0       	ldi	r27, 0x00	; 0
    5b04:	ac 0f       	add	r26, r28
    5b06:	bd 1f       	adc	r27, r29
    5b08:	a9 0f       	add	r26, r25
    5b0a:	b1 1d       	adc	r27, r1
    5b0c:	9c 91       	ld	r25, X
    5b0e:	21 e0       	ldi	r18, 0x01	; 1
    5b10:	30 e0       	ldi	r19, 0x00	; 0
    5b12:	2c 0f       	add	r18, r28
    5b14:	3d 1f       	adc	r19, r29
    5b16:	e2 0f       	add	r30, r18
    5b18:	f3 1f       	adc	r31, r19
    5b1a:	90 83       	st	Z, r25
    5b1c:	9f ad       	ldd	r25, Y+63	; 0x3f
    5b1e:	9f 5f       	subi	r25, 0xFF	; 255
    5b20:	9f af       	std	Y+63, r25	; 0x3f
    5b22:	9f ad       	ldd	r25, Y+63	; 0x3f
    5b24:	98 17       	cp	r25, r24
    5b26:	40 f3       	brcs	.-48     	; 0x5af8 <SENSORS_APPLY_SEND_BUFFER+0x3ba>
    5b28:	8f ad       	ldd	r24, Y+63	; 0x3f
    5b2a:	8e 5f       	subi	r24, 0xFE	; 254
    5b2c:	24 96       	adiw	r28, 0x04	; 4
    5b2e:	8f af       	std	Y+63, r24	; 0x3f
    5b30:	24 97       	sbiw	r28, 0x04	; 4
    5b32:	24 96       	adiw	r28, 0x04	; 4
    5b34:	8f ad       	ldd	r24, Y+63	; 0x3f
    5b36:	24 97       	sbiw	r28, 0x04	; 4
    5b38:	e1 e0       	ldi	r30, 0x01	; 1
    5b3a:	f0 e0       	ldi	r31, 0x00	; 0
    5b3c:	ec 0f       	add	r30, r28
    5b3e:	fd 1f       	adc	r31, r29
    5b40:	e8 0f       	add	r30, r24
    5b42:	f1 1d       	adc	r31, r1
    5b44:	8a e3       	ldi	r24, 0x3A	; 58
    5b46:	80 83       	st	Z, r24
    5b48:	24 96       	adiw	r28, 0x04	; 4
    5b4a:	ef ad       	ldd	r30, Y+63	; 0x3f
    5b4c:	24 97       	sbiw	r28, 0x04	; 4
    5b4e:	f0 e0       	ldi	r31, 0x00	; 0
    5b50:	31 96       	adiw	r30, 0x01	; 1
    5b52:	41 e0       	ldi	r20, 0x01	; 1
    5b54:	50 e0       	ldi	r21, 0x00	; 0
    5b56:	4c 0f       	add	r20, r28
    5b58:	5d 1f       	adc	r21, r29
    5b5a:	e4 0f       	add	r30, r20
    5b5c:	f5 1f       	adc	r31, r21
    5b5e:	94 e4       	ldi	r25, 0x44	; 68
    5b60:	90 83       	st	Z, r25
    5b62:	24 96       	adiw	r28, 0x04	; 4
    5b64:	ef ad       	ldd	r30, Y+63	; 0x3f
    5b66:	24 97       	sbiw	r28, 0x04	; 4
    5b68:	f0 e0       	ldi	r31, 0x00	; 0
    5b6a:	32 96       	adiw	r30, 0x02	; 2
    5b6c:	e4 0f       	add	r30, r20
    5b6e:	f5 1f       	adc	r31, r21
    5b70:	80 83       	st	Z, r24
    5b72:	24 96       	adiw	r28, 0x04	; 4
    5b74:	8f ad       	ldd	r24, Y+63	; 0x3f
    5b76:	24 97       	sbiw	r28, 0x04	; 4
    5b78:	8d 5f       	subi	r24, 0xFD	; 253
    5b7a:	24 96       	adiw	r28, 0x04	; 4
    5b7c:	8f af       	std	Y+63, r24	; 0x3f
    5b7e:	24 97       	sbiw	r28, 0x04	; 4
    5b80:	1b aa       	std	Y+51, r1	; 0x33
    5b82:	1c aa       	std	Y+52, r1	; 0x34
    5b84:	1d aa       	std	Y+53, r1	; 0x35
    5b86:	1e aa       	std	Y+54, r1	; 0x36
    5b88:	1f aa       	std	Y+55, r1	; 0x37
    5b8a:	18 ae       	std	Y+56, r1	; 0x38
    5b8c:	19 ae       	std	Y+57, r1	; 0x39
    5b8e:	1a ae       	std	Y+58, r1	; 0x3a
    5b90:	1f ae       	std	Y+63, r1	; 0x3f
    5b92:	8f ad       	ldd	r24, Y+63	; 0x3f
    5b94:	82 30       	cpi	r24, 0x02	; 2
    5b96:	58 f5       	brcc	.+86     	; 0x5bee <SENSORS_APPLY_SEND_BUFFER+0x4b0>
    5b98:	2b a9       	ldd	r18, Y+51	; 0x33
    5b9a:	3c a9       	ldd	r19, Y+52	; 0x34
    5b9c:	4d a9       	ldd	r20, Y+53	; 0x35
    5b9e:	5e a9       	ldd	r21, Y+54	; 0x36
    5ba0:	6f a9       	ldd	r22, Y+55	; 0x37
    5ba2:	78 ad       	ldd	r23, Y+56	; 0x38
    5ba4:	89 ad       	ldd	r24, Y+57	; 0x39
    5ba6:	9a ad       	ldd	r25, Y+58	; 0x3a
    5ba8:	23 96       	adiw	r28, 0x03	; 3
    5baa:	ef ad       	ldd	r30, Y+63	; 0x3f
    5bac:	23 97       	sbiw	r28, 0x03	; 3
    5bae:	f0 e0       	ldi	r31, 0x00	; 0
    5bb0:	1f ad       	ldd	r17, Y+63	; 0x3f
    5bb2:	df 01       	movw	r26, r30
    5bb4:	aa 0f       	add	r26, r26
    5bb6:	bb 1f       	adc	r27, r27
    5bb8:	aa 0f       	add	r26, r26
    5bba:	bb 1f       	adc	r27, r27
    5bbc:	ea 0f       	add	r30, r26
    5bbe:	fb 1f       	adc	r31, r27
    5bc0:	e0 52       	subi	r30, 0x20	; 32
    5bc2:	f3 4f       	sbci	r31, 0xF3	; 243
    5bc4:	e1 0f       	add	r30, r17
    5bc6:	f1 1d       	adc	r31, r1
    5bc8:	e1 81       	ldd	r30, Z+1	; 0x01
    5bca:	08 e0       	ldi	r16, 0x08	; 8
    5bcc:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    5bd0:	e2 2b       	or	r30, r18
    5bd2:	eb ab       	std	Y+51, r30	; 0x33
    5bd4:	3c ab       	std	Y+52, r19	; 0x34
    5bd6:	4d ab       	std	Y+53, r20	; 0x35
    5bd8:	5e ab       	std	Y+54, r21	; 0x36
    5bda:	6f ab       	std	Y+55, r22	; 0x37
    5bdc:	78 af       	std	Y+56, r23	; 0x38
    5bde:	89 af       	std	Y+57, r24	; 0x39
    5be0:	9a af       	std	Y+58, r25	; 0x3a
    5be2:	8f ad       	ldd	r24, Y+63	; 0x3f
    5be4:	8f 5f       	subi	r24, 0xFF	; 255
    5be6:	8f af       	std	Y+63, r24	; 0x3f
    5be8:	8f ad       	ldd	r24, Y+63	; 0x3f
    5bea:	82 30       	cpi	r24, 0x02	; 2
    5bec:	a8 f2       	brcs	.-86     	; 0x5b98 <SENSORS_APPLY_SEND_BUFFER+0x45a>
    5bee:	0b a9       	ldd	r16, Y+51	; 0x33
    5bf0:	1c a9       	ldd	r17, Y+52	; 0x34
    5bf2:	2d a9       	ldd	r18, Y+53	; 0x35
    5bf4:	3e a9       	ldd	r19, Y+54	; 0x36
    5bf6:	4f a9       	ldd	r20, Y+55	; 0x37
    5bf8:	58 ad       	ldd	r21, Y+56	; 0x38
    5bfa:	69 ad       	ldd	r22, Y+57	; 0x39
    5bfc:	7a ad       	ldd	r23, Y+58	; 0x3a
    5bfe:	ce 01       	movw	r24, r28
    5c00:	4f 96       	adiw	r24, 0x1f	; 31
    5c02:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    5c06:	1f ae       	std	Y+63, r1	; 0x3f
    5c08:	9f ad       	ldd	r25, Y+63	; 0x3f
    5c0a:	98 17       	cp	r25, r24
    5c0c:	e0 f4       	brcc	.+56     	; 0x5c46 <SENSORS_APPLY_SEND_BUFFER+0x508>
    5c0e:	24 96       	adiw	r28, 0x04	; 4
    5c10:	9f ad       	ldd	r25, Y+63	; 0x3f
    5c12:	24 97       	sbiw	r28, 0x04	; 4
    5c14:	ef ad       	ldd	r30, Y+63	; 0x3f
    5c16:	f0 e0       	ldi	r31, 0x00	; 0
    5c18:	e9 0f       	add	r30, r25
    5c1a:	f1 1d       	adc	r31, r1
    5c1c:	9f ad       	ldd	r25, Y+63	; 0x3f
    5c1e:	af e1       	ldi	r26, 0x1F	; 31
    5c20:	b0 e0       	ldi	r27, 0x00	; 0
    5c22:	ac 0f       	add	r26, r28
    5c24:	bd 1f       	adc	r27, r29
    5c26:	a9 0f       	add	r26, r25
    5c28:	b1 1d       	adc	r27, r1
    5c2a:	9c 91       	ld	r25, X
    5c2c:	21 e0       	ldi	r18, 0x01	; 1
    5c2e:	30 e0       	ldi	r19, 0x00	; 0
    5c30:	2c 0f       	add	r18, r28
    5c32:	3d 1f       	adc	r19, r29
    5c34:	e2 0f       	add	r30, r18
    5c36:	f3 1f       	adc	r31, r19
    5c38:	90 83       	st	Z, r25
    5c3a:	9f ad       	ldd	r25, Y+63	; 0x3f
    5c3c:	9f 5f       	subi	r25, 0xFF	; 255
    5c3e:	9f af       	std	Y+63, r25	; 0x3f
    5c40:	9f ad       	ldd	r25, Y+63	; 0x3f
    5c42:	98 17       	cp	r25, r24
    5c44:	20 f3       	brcs	.-56     	; 0x5c0e <SENSORS_APPLY_SEND_BUFFER+0x4d0>
    5c46:	24 96       	adiw	r28, 0x04	; 4
    5c48:	8f ad       	ldd	r24, Y+63	; 0x3f
    5c4a:	24 97       	sbiw	r28, 0x04	; 4
    5c4c:	9f ad       	ldd	r25, Y+63	; 0x3f
    5c4e:	89 0f       	add	r24, r25
    5c50:	24 96       	adiw	r28, 0x04	; 4
    5c52:	8f af       	std	Y+63, r24	; 0x3f
    5c54:	24 97       	sbiw	r28, 0x04	; 4
    5c56:	24 96       	adiw	r28, 0x04	; 4
    5c58:	8f ad       	ldd	r24, Y+63	; 0x3f
    5c5a:	24 97       	sbiw	r28, 0x04	; 4
    5c5c:	e1 e0       	ldi	r30, 0x01	; 1
    5c5e:	f0 e0       	ldi	r31, 0x00	; 0
    5c60:	ec 0f       	add	r30, r28
    5c62:	fd 1f       	adc	r31, r29
    5c64:	e8 0f       	add	r30, r24
    5c66:	f1 1d       	adc	r31, r1
    5c68:	8a e3       	ldi	r24, 0x3A	; 58
    5c6a:	80 83       	st	Z, r24
    5c6c:	24 96       	adiw	r28, 0x04	; 4
    5c6e:	8f ad       	ldd	r24, Y+63	; 0x3f
    5c70:	24 97       	sbiw	r28, 0x04	; 4
    5c72:	8f 5f       	subi	r24, 0xFF	; 255
    5c74:	24 96       	adiw	r28, 0x04	; 4
    5c76:	8f af       	std	Y+63, r24	; 0x3f
    5c78:	24 97       	sbiw	r28, 0x04	; 4
    5c7a:	1b aa       	std	Y+51, r1	; 0x33
    5c7c:	1c aa       	std	Y+52, r1	; 0x34
    5c7e:	1d aa       	std	Y+53, r1	; 0x35
    5c80:	1e aa       	std	Y+54, r1	; 0x36
    5c82:	1f aa       	std	Y+55, r1	; 0x37
    5c84:	18 ae       	std	Y+56, r1	; 0x38
    5c86:	19 ae       	std	Y+57, r1	; 0x39
    5c88:	1a ae       	std	Y+58, r1	; 0x3a
    5c8a:	1f ae       	std	Y+63, r1	; 0x3f
    5c8c:	8f ad       	ldd	r24, Y+63	; 0x3f
    5c8e:	82 30       	cpi	r24, 0x02	; 2
    5c90:	58 f5       	brcc	.+86     	; 0x5ce8 <SENSORS_APPLY_SEND_BUFFER+0x5aa>
    5c92:	2b a9       	ldd	r18, Y+51	; 0x33
    5c94:	3c a9       	ldd	r19, Y+52	; 0x34
    5c96:	4d a9       	ldd	r20, Y+53	; 0x35
    5c98:	5e a9       	ldd	r21, Y+54	; 0x36
    5c9a:	6f a9       	ldd	r22, Y+55	; 0x37
    5c9c:	78 ad       	ldd	r23, Y+56	; 0x38
    5c9e:	89 ad       	ldd	r24, Y+57	; 0x39
    5ca0:	9a ad       	ldd	r25, Y+58	; 0x3a
    5ca2:	23 96       	adiw	r28, 0x03	; 3
    5ca4:	ef ad       	ldd	r30, Y+63	; 0x3f
    5ca6:	23 97       	sbiw	r28, 0x03	; 3
    5ca8:	f0 e0       	ldi	r31, 0x00	; 0
    5caa:	1f ad       	ldd	r17, Y+63	; 0x3f
    5cac:	df 01       	movw	r26, r30
    5cae:	aa 0f       	add	r26, r26
    5cb0:	bb 1f       	adc	r27, r27
    5cb2:	aa 0f       	add	r26, r26
    5cb4:	bb 1f       	adc	r27, r27
    5cb6:	ea 0f       	add	r30, r26
    5cb8:	fb 1f       	adc	r31, r27
    5cba:	e0 52       	subi	r30, 0x20	; 32
    5cbc:	f3 4f       	sbci	r31, 0xF3	; 243
    5cbe:	e1 0f       	add	r30, r17
    5cc0:	f1 1d       	adc	r31, r1
    5cc2:	e3 81       	ldd	r30, Z+3	; 0x03
    5cc4:	08 e0       	ldi	r16, 0x08	; 8
    5cc6:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    5cca:	e2 2b       	or	r30, r18
    5ccc:	eb ab       	std	Y+51, r30	; 0x33
    5cce:	3c ab       	std	Y+52, r19	; 0x34
    5cd0:	4d ab       	std	Y+53, r20	; 0x35
    5cd2:	5e ab       	std	Y+54, r21	; 0x36
    5cd4:	6f ab       	std	Y+55, r22	; 0x37
    5cd6:	78 af       	std	Y+56, r23	; 0x38
    5cd8:	89 af       	std	Y+57, r24	; 0x39
    5cda:	9a af       	std	Y+58, r25	; 0x3a
    5cdc:	8f ad       	ldd	r24, Y+63	; 0x3f
    5cde:	8f 5f       	subi	r24, 0xFF	; 255
    5ce0:	8f af       	std	Y+63, r24	; 0x3f
    5ce2:	8f ad       	ldd	r24, Y+63	; 0x3f
    5ce4:	82 30       	cpi	r24, 0x02	; 2
    5ce6:	a8 f2       	brcs	.-86     	; 0x5c92 <SENSORS_APPLY_SEND_BUFFER+0x554>
    5ce8:	0b a9       	ldd	r16, Y+51	; 0x33
    5cea:	1c a9       	ldd	r17, Y+52	; 0x34
    5cec:	2d a9       	ldd	r18, Y+53	; 0x35
    5cee:	3e a9       	ldd	r19, Y+54	; 0x36
    5cf0:	4f a9       	ldd	r20, Y+55	; 0x37
    5cf2:	58 ad       	ldd	r21, Y+56	; 0x38
    5cf4:	69 ad       	ldd	r22, Y+57	; 0x39
    5cf6:	7a ad       	ldd	r23, Y+58	; 0x3a
    5cf8:	ce 01       	movw	r24, r28
    5cfa:	4f 96       	adiw	r24, 0x1f	; 31
    5cfc:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    5d00:	1f ae       	std	Y+63, r1	; 0x3f
    5d02:	9f ad       	ldd	r25, Y+63	; 0x3f
    5d04:	98 17       	cp	r25, r24
    5d06:	e0 f4       	brcc	.+56     	; 0x5d40 <SENSORS_APPLY_SEND_BUFFER+0x602>
    5d08:	24 96       	adiw	r28, 0x04	; 4
    5d0a:	9f ad       	ldd	r25, Y+63	; 0x3f
    5d0c:	24 97       	sbiw	r28, 0x04	; 4
    5d0e:	ef ad       	ldd	r30, Y+63	; 0x3f
    5d10:	f0 e0       	ldi	r31, 0x00	; 0
    5d12:	e9 0f       	add	r30, r25
    5d14:	f1 1d       	adc	r31, r1
    5d16:	9f ad       	ldd	r25, Y+63	; 0x3f
    5d18:	af e1       	ldi	r26, 0x1F	; 31
    5d1a:	b0 e0       	ldi	r27, 0x00	; 0
    5d1c:	ac 0f       	add	r26, r28
    5d1e:	bd 1f       	adc	r27, r29
    5d20:	a9 0f       	add	r26, r25
    5d22:	b1 1d       	adc	r27, r1
    5d24:	9c 91       	ld	r25, X
    5d26:	41 e0       	ldi	r20, 0x01	; 1
    5d28:	50 e0       	ldi	r21, 0x00	; 0
    5d2a:	4c 0f       	add	r20, r28
    5d2c:	5d 1f       	adc	r21, r29
    5d2e:	e4 0f       	add	r30, r20
    5d30:	f5 1f       	adc	r31, r21
    5d32:	90 83       	st	Z, r25
    5d34:	9f ad       	ldd	r25, Y+63	; 0x3f
    5d36:	9f 5f       	subi	r25, 0xFF	; 255
    5d38:	9f af       	std	Y+63, r25	; 0x3f
    5d3a:	9f ad       	ldd	r25, Y+63	; 0x3f
    5d3c:	98 17       	cp	r25, r24
    5d3e:	20 f3       	brcs	.-56     	; 0x5d08 <SENSORS_APPLY_SEND_BUFFER+0x5ca>
    5d40:	24 96       	adiw	r28, 0x04	; 4
    5d42:	8f ad       	ldd	r24, Y+63	; 0x3f
    5d44:	24 97       	sbiw	r28, 0x04	; 4
    5d46:	9f ad       	ldd	r25, Y+63	; 0x3f
    5d48:	89 0f       	add	r24, r25
    5d4a:	24 96       	adiw	r28, 0x04	; 4
    5d4c:	8f af       	std	Y+63, r24	; 0x3f
    5d4e:	24 97       	sbiw	r28, 0x04	; 4
    5d50:	24 96       	adiw	r28, 0x04	; 4
    5d52:	8f ad       	ldd	r24, Y+63	; 0x3f
    5d54:	24 97       	sbiw	r28, 0x04	; 4
    5d56:	e1 e0       	ldi	r30, 0x01	; 1
    5d58:	f0 e0       	ldi	r31, 0x00	; 0
    5d5a:	ec 0f       	add	r30, r28
    5d5c:	fd 1f       	adc	r31, r29
    5d5e:	e8 0f       	add	r30, r24
    5d60:	f1 1d       	adc	r31, r1
    5d62:	8a e3       	ldi	r24, 0x3A	; 58
    5d64:	80 83       	st	Z, r24
    5d66:	24 96       	adiw	r28, 0x04	; 4
    5d68:	ef ad       	ldd	r30, Y+63	; 0x3f
    5d6a:	24 97       	sbiw	r28, 0x04	; 4
    5d6c:	f0 e0       	ldi	r31, 0x00	; 0
    5d6e:	31 96       	adiw	r30, 0x01	; 1
    5d70:	81 e0       	ldi	r24, 0x01	; 1
    5d72:	90 e0       	ldi	r25, 0x00	; 0
    5d74:	8c 0f       	add	r24, r28
    5d76:	9d 1f       	adc	r25, r29
    5d78:	e8 0f       	add	r30, r24
    5d7a:	f9 1f       	adc	r31, r25
    5d7c:	10 82       	st	Z, r1
    5d7e:	4f ef       	ldi	r20, 0xFF	; 255
    5d80:	5f ef       	ldi	r21, 0xFF	; 255
    5d82:	ba 01       	movw	r22, r20
    5d84:	80 91 71 0e 	lds	r24, 0x0E71
    5d88:	90 91 72 0e 	lds	r25, 0x0E72
    5d8c:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    5d90:	24 96       	adiw	r28, 0x04	; 4
    5d92:	4f ad       	ldd	r20, Y+63	; 0x3f
    5d94:	24 97       	sbiw	r28, 0x04	; 4
    5d96:	4e 5f       	subi	r20, 0xFE	; 254
    5d98:	be 01       	movw	r22, r28
    5d9a:	6f 5f       	subi	r22, 0xFF	; 255
    5d9c:	7f 4f       	sbci	r23, 0xFF	; 255
    5d9e:	89 e2       	ldi	r24, 0x29	; 41
    5da0:	9f e0       	ldi	r25, 0x0F	; 15
    5da2:	0e 94 4f 05 	call	0xa9e	; 0xa9e <QUEUE_ADD_ARRAY_U8>
    5da6:	00 e0       	ldi	r16, 0x00	; 0
    5da8:	20 e0       	ldi	r18, 0x00	; 0
    5daa:	30 e0       	ldi	r19, 0x00	; 0
    5dac:	a9 01       	movw	r20, r18
    5dae:	60 e0       	ldi	r22, 0x00	; 0
    5db0:	70 e0       	ldi	r23, 0x00	; 0
    5db2:	80 91 71 0e 	lds	r24, 0x0E71
    5db6:	90 91 72 0e 	lds	r25, 0x0E72
    5dba:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <xQueueGenericSend>
    5dbe:	21 96       	adiw	r28, 0x01	; 1
    5dc0:	8f ad       	ldd	r24, Y+63	; 0x3f
    5dc2:	21 97       	sbiw	r28, 0x01	; 1
    5dc4:	81 11       	cpse	r24, r1
    5dc6:	34 c2       	rjmp	.+1128   	; 0x6230 <SENSORS_APPLY_SEND_BUFFER+0xaf2>
    5dc8:	22 96       	adiw	r28, 0x02	; 2
    5dca:	ef ad       	ldd	r30, Y+63	; 0x3f
    5dcc:	22 97       	sbiw	r28, 0x02	; 2
    5dce:	7e 9e       	mul	r7, r30
    5dd0:	f0 01       	movw	r30, r0
    5dd2:	11 24       	eor	r1, r1
    5dd4:	ed 5e       	subi	r30, 0xED	; 237
    5dd6:	f2 4f       	sbci	r31, 0xF2	; 242
    5dd8:	87 89       	ldd	r24, Z+23	; 0x17
    5dda:	8f 5f       	subi	r24, 0xFF	; 255
    5ddc:	87 8b       	std	Z+23, r24	; 0x17
    5dde:	22 96       	adiw	r28, 0x02	; 2
    5de0:	ef ad       	ldd	r30, Y+63	; 0x3f
    5de2:	22 97       	sbiw	r28, 0x02	; 2
    5de4:	7e 9e       	mul	r7, r30
    5de6:	f0 01       	movw	r30, r0
    5de8:	11 24       	eor	r1, r1
    5dea:	ed 5e       	subi	r30, 0xED	; 237
    5dec:	f2 4f       	sbci	r31, 0xF2	; 242
    5dee:	87 89       	ldd	r24, Z+23	; 0x17
    5df0:	83 30       	cpi	r24, 0x03	; 3
    5df2:	09 f0       	breq	.+2      	; 0x5df6 <SENSORS_APPLY_SEND_BUFFER+0x6b8>
    5df4:	1d c2       	rjmp	.+1082   	; 0x6230 <SENSORS_APPLY_SEND_BUFFER+0xaf2>
    5df6:	22 96       	adiw	r28, 0x02	; 2
    5df8:	ef ad       	ldd	r30, Y+63	; 0x3f
    5dfa:	22 97       	sbiw	r28, 0x02	; 2
    5dfc:	7e 9e       	mul	r7, r30
    5dfe:	f0 01       	movw	r30, r0
    5e00:	11 24       	eor	r1, r1
    5e02:	ed 5e       	subi	r30, 0xED	; 237
    5e04:	f2 4f       	sbci	r31, 0xF2	; 242
    5e06:	17 8a       	std	Z+23, r1	; 0x17
    5e08:	84 e9       	ldi	r24, 0x94	; 148
    5e0a:	91 e0       	ldi	r25, 0x01	; 1
    5e0c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e10:	84 e9       	ldi	r24, 0x94	; 148
    5e12:	91 e0       	ldi	r25, 0x01	; 1
    5e14:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e18:	84 e9       	ldi	r24, 0x94	; 148
    5e1a:	91 e0       	ldi	r25, 0x01	; 1
    5e1c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e20:	84 e9       	ldi	r24, 0x94	; 148
    5e22:	91 e0       	ldi	r25, 0x01	; 1
    5e24:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e28:	84 e9       	ldi	r24, 0x94	; 148
    5e2a:	91 e0       	ldi	r25, 0x01	; 1
    5e2c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e30:	84 e9       	ldi	r24, 0x94	; 148
    5e32:	91 e0       	ldi	r25, 0x01	; 1
    5e34:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e38:	84 e9       	ldi	r24, 0x94	; 148
    5e3a:	91 e0       	ldi	r25, 0x01	; 1
    5e3c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e40:	84 e9       	ldi	r24, 0x94	; 148
    5e42:	91 e0       	ldi	r25, 0x01	; 1
    5e44:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e48:	86 eb       	ldi	r24, 0xB6	; 182
    5e4a:	93 e0       	ldi	r25, 0x03	; 3
    5e4c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e50:	22 96       	adiw	r28, 0x02	; 2
    5e52:	2f ad       	ldd	r18, Y+63	; 0x3f
    5e54:	22 97       	sbiw	r28, 0x02	; 2
    5e56:	30 e0       	ldi	r19, 0x00	; 0
    5e58:	40 e0       	ldi	r20, 0x00	; 0
    5e5a:	50 e0       	ldi	r21, 0x00	; 0
    5e5c:	60 e0       	ldi	r22, 0x00	; 0
    5e5e:	70 e0       	ldi	r23, 0x00	; 0
    5e60:	80 e0       	ldi	r24, 0x00	; 0
    5e62:	90 e0       	ldi	r25, 0x00	; 0
    5e64:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    5e68:	84 e9       	ldi	r24, 0x94	; 148
    5e6a:	91 e0       	ldi	r25, 0x01	; 1
    5e6c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e70:	84 e9       	ldi	r24, 0x94	; 148
    5e72:	91 e0       	ldi	r25, 0x01	; 1
    5e74:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e78:	84 e9       	ldi	r24, 0x94	; 148
    5e7a:	91 e0       	ldi	r25, 0x01	; 1
    5e7c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e80:	84 e9       	ldi	r24, 0x94	; 148
    5e82:	91 e0       	ldi	r25, 0x01	; 1
    5e84:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e88:	84 e9       	ldi	r24, 0x94	; 148
    5e8a:	91 e0       	ldi	r25, 0x01	; 1
    5e8c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e90:	84 e9       	ldi	r24, 0x94	; 148
    5e92:	91 e0       	ldi	r25, 0x01	; 1
    5e94:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5e98:	84 e9       	ldi	r24, 0x94	; 148
    5e9a:	91 e0       	ldi	r25, 0x01	; 1
    5e9c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5ea0:	84 e9       	ldi	r24, 0x94	; 148
    5ea2:	91 e0       	ldi	r25, 0x01	; 1
    5ea4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    5ea8:	69 82       	std	Y+1, r6	; 0x01
    5eaa:	8a e3       	ldi	r24, 0x3A	; 58
    5eac:	8a 83       	std	Y+2, r24	; 0x02
    5eae:	1b aa       	std	Y+51, r1	; 0x33
    5eb0:	1c aa       	std	Y+52, r1	; 0x34
    5eb2:	1d aa       	std	Y+53, r1	; 0x35
    5eb4:	1e aa       	std	Y+54, r1	; 0x36
    5eb6:	1f aa       	std	Y+55, r1	; 0x37
    5eb8:	18 ae       	std	Y+56, r1	; 0x38
    5eba:	19 ae       	std	Y+57, r1	; 0x39
    5ebc:	1a ae       	std	Y+58, r1	; 0x3a
    5ebe:	22 96       	adiw	r28, 0x02	; 2
    5ec0:	ef ad       	ldd	r30, Y+63	; 0x3f
    5ec2:	22 97       	sbiw	r28, 0x02	; 2
    5ec4:	7e 9e       	mul	r7, r30
    5ec6:	f0 01       	movw	r30, r0
    5ec8:	11 24       	eor	r1, r1
    5eca:	ed 5e       	subi	r30, 0xED	; 237
    5ecc:	f2 4f       	sbci	r31, 0xF2	; 242
    5ece:	a0 81       	ld	r26, Z
    5ed0:	aa 23       	and	r26, r26
    5ed2:	11 f1       	breq	.+68     	; 0x5f18 <SENSORS_APPLY_SEND_BUFFER+0x7da>
    5ed4:	2b a9       	ldd	r18, Y+51	; 0x33
    5ed6:	3c a9       	ldd	r19, Y+52	; 0x34
    5ed8:	4d a9       	ldd	r20, Y+53	; 0x35
    5eda:	5e a9       	ldd	r21, Y+54	; 0x36
    5edc:	6f a9       	ldd	r22, Y+55	; 0x37
    5ede:	78 ad       	ldd	r23, Y+56	; 0x38
    5ee0:	89 ad       	ldd	r24, Y+57	; 0x39
    5ee2:	9a ad       	ldd	r25, Y+58	; 0x3a
    5ee4:	22 96       	adiw	r28, 0x02	; 2
    5ee6:	bf ad       	ldd	r27, Y+63	; 0x3f
    5ee8:	22 97       	sbiw	r28, 0x02	; 2
    5eea:	ea 2f       	mov	r30, r26
    5eec:	f0 e0       	ldi	r31, 0x00	; 0
    5eee:	7b 9e       	mul	r7, r27
    5ef0:	e0 0d       	add	r30, r0
    5ef2:	f1 1d       	adc	r31, r1
    5ef4:	11 24       	eor	r1, r1
    5ef6:	ee 5e       	subi	r30, 0xEE	; 238
    5ef8:	f2 4f       	sbci	r31, 0xF2	; 242
    5efa:	e1 81       	ldd	r30, Z+1	; 0x01
    5efc:	08 e0       	ldi	r16, 0x08	; 8
    5efe:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    5f02:	e2 2b       	or	r30, r18
    5f04:	eb ab       	std	Y+51, r30	; 0x33
    5f06:	3c ab       	std	Y+52, r19	; 0x34
    5f08:	4d ab       	std	Y+53, r20	; 0x35
    5f0a:	5e ab       	std	Y+54, r21	; 0x36
    5f0c:	6f ab       	std	Y+55, r22	; 0x37
    5f0e:	78 af       	std	Y+56, r23	; 0x38
    5f10:	89 af       	std	Y+57, r24	; 0x39
    5f12:	9a af       	std	Y+58, r25	; 0x3a
    5f14:	a1 50       	subi	r26, 0x01	; 1
    5f16:	f1 f6       	brne	.-68     	; 0x5ed4 <SENSORS_APPLY_SEND_BUFFER+0x796>
    5f18:	0b a9       	ldd	r16, Y+51	; 0x33
    5f1a:	1c a9       	ldd	r17, Y+52	; 0x34
    5f1c:	2d a9       	ldd	r18, Y+53	; 0x35
    5f1e:	3e a9       	ldd	r19, Y+54	; 0x36
    5f20:	4f a9       	ldd	r20, Y+55	; 0x37
    5f22:	58 ad       	ldd	r21, Y+56	; 0x38
    5f24:	69 ad       	ldd	r22, Y+57	; 0x39
    5f26:	7a ad       	ldd	r23, Y+58	; 0x3a
    5f28:	ce 01       	movw	r24, r28
    5f2a:	4f 96       	adiw	r24, 0x1f	; 31
    5f2c:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    5f30:	88 23       	and	r24, r24
    5f32:	b1 f0       	breq	.+44     	; 0x5f60 <SENSORS_APPLY_SEND_BUFFER+0x822>
    5f34:	20 e0       	ldi	r18, 0x00	; 0
    5f36:	30 e0       	ldi	r19, 0x00	; 0
    5f38:	f9 01       	movw	r30, r18
    5f3a:	32 96       	adiw	r30, 0x02	; 2
    5f3c:	af e1       	ldi	r26, 0x1F	; 31
    5f3e:	b0 e0       	ldi	r27, 0x00	; 0
    5f40:	ac 0f       	add	r26, r28
    5f42:	bd 1f       	adc	r27, r29
    5f44:	a2 0f       	add	r26, r18
    5f46:	b3 1f       	adc	r27, r19
    5f48:	9c 91       	ld	r25, X
    5f4a:	41 e0       	ldi	r20, 0x01	; 1
    5f4c:	50 e0       	ldi	r21, 0x00	; 0
    5f4e:	4c 0f       	add	r20, r28
    5f50:	5d 1f       	adc	r21, r29
    5f52:	e4 0f       	add	r30, r20
    5f54:	f5 1f       	adc	r31, r21
    5f56:	90 83       	st	Z, r25
    5f58:	2f 5f       	subi	r18, 0xFF	; 255
    5f5a:	3f 4f       	sbci	r19, 0xFF	; 255
    5f5c:	28 17       	cp	r18, r24
    5f5e:	60 f3       	brcs	.-40     	; 0x5f38 <SENSORS_APPLY_SEND_BUFFER+0x7fa>
    5f60:	8e 5f       	subi	r24, 0xFE	; 254
    5f62:	24 96       	adiw	r28, 0x04	; 4
    5f64:	8f af       	std	Y+63, r24	; 0x3f
    5f66:	24 97       	sbiw	r28, 0x04	; 4
    5f68:	24 96       	adiw	r28, 0x04	; 4
    5f6a:	8f ad       	ldd	r24, Y+63	; 0x3f
    5f6c:	24 97       	sbiw	r28, 0x04	; 4
    5f6e:	e1 e0       	ldi	r30, 0x01	; 1
    5f70:	f0 e0       	ldi	r31, 0x00	; 0
    5f72:	ec 0f       	add	r30, r28
    5f74:	fd 1f       	adc	r31, r29
    5f76:	e8 0f       	add	r30, r24
    5f78:	f1 1d       	adc	r31, r1
    5f7a:	8a e3       	ldi	r24, 0x3A	; 58
    5f7c:	80 83       	st	Z, r24
    5f7e:	24 96       	adiw	r28, 0x04	; 4
    5f80:	ef ad       	ldd	r30, Y+63	; 0x3f
    5f82:	24 97       	sbiw	r28, 0x04	; 4
    5f84:	f0 e0       	ldi	r31, 0x00	; 0
    5f86:	31 96       	adiw	r30, 0x01	; 1
    5f88:	21 e0       	ldi	r18, 0x01	; 1
    5f8a:	30 e0       	ldi	r19, 0x00	; 0
    5f8c:	2c 0f       	add	r18, r28
    5f8e:	3d 1f       	adc	r19, r29
    5f90:	e2 0f       	add	r30, r18
    5f92:	f3 1f       	adc	r31, r19
    5f94:	94 e5       	ldi	r25, 0x54	; 84
    5f96:	90 83       	st	Z, r25
    5f98:	24 96       	adiw	r28, 0x04	; 4
    5f9a:	ef ad       	ldd	r30, Y+63	; 0x3f
    5f9c:	24 97       	sbiw	r28, 0x04	; 4
    5f9e:	f0 e0       	ldi	r31, 0x00	; 0
    5fa0:	32 96       	adiw	r30, 0x02	; 2
    5fa2:	e2 0f       	add	r30, r18
    5fa4:	f3 1f       	adc	r31, r19
    5fa6:	80 83       	st	Z, r24
    5fa8:	24 96       	adiw	r28, 0x04	; 4
    5faa:	8f ad       	ldd	r24, Y+63	; 0x3f
    5fac:	24 97       	sbiw	r28, 0x04	; 4
    5fae:	8d 5f       	subi	r24, 0xFD	; 253
    5fb0:	24 96       	adiw	r28, 0x04	; 4
    5fb2:	8f af       	std	Y+63, r24	; 0x3f
    5fb4:	24 97       	sbiw	r28, 0x04	; 4
    5fb6:	1b aa       	std	Y+51, r1	; 0x33
    5fb8:	1c aa       	std	Y+52, r1	; 0x34
    5fba:	1d aa       	std	Y+53, r1	; 0x35
    5fbc:	1e aa       	std	Y+54, r1	; 0x36
    5fbe:	1f aa       	std	Y+55, r1	; 0x37
    5fc0:	18 ae       	std	Y+56, r1	; 0x38
    5fc2:	19 ae       	std	Y+57, r1	; 0x39
    5fc4:	1a ae       	std	Y+58, r1	; 0x3a
    5fc6:	2b a9       	ldd	r18, Y+51	; 0x33
    5fc8:	3c a9       	ldd	r19, Y+52	; 0x34
    5fca:	4d a9       	ldd	r20, Y+53	; 0x35
    5fcc:	5e a9       	ldd	r21, Y+54	; 0x36
    5fce:	6f a9       	ldd	r22, Y+55	; 0x37
    5fd0:	78 ad       	ldd	r23, Y+56	; 0x38
    5fd2:	89 ad       	ldd	r24, Y+57	; 0x39
    5fd4:	9a ad       	ldd	r25, Y+58	; 0x3a
    5fd6:	23 96       	adiw	r28, 0x03	; 3
    5fd8:	ef ad       	ldd	r30, Y+63	; 0x3f
    5fda:	23 97       	sbiw	r28, 0x03	; 3
    5fdc:	f0 e0       	ldi	r31, 0x00	; 0
    5fde:	df 01       	movw	r26, r30
    5fe0:	aa 0f       	add	r26, r26
    5fe2:	bb 1f       	adc	r27, r27
    5fe4:	aa 0f       	add	r26, r26
    5fe6:	bb 1f       	adc	r27, r27
    5fe8:	ea 0f       	add	r30, r26
    5fea:	fb 1f       	adc	r31, r27
    5fec:	e0 52       	subi	r30, 0x20	; 32
    5fee:	f3 4f       	sbci	r31, 0xF3	; 243
    5ff0:	e1 81       	ldd	r30, Z+1	; 0x01
    5ff2:	08 e0       	ldi	r16, 0x08	; 8
    5ff4:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    5ff8:	e2 2b       	or	r30, r18
    5ffa:	eb ab       	std	Y+51, r30	; 0x33
    5ffc:	3c ab       	std	Y+52, r19	; 0x34
    5ffe:	4d ab       	std	Y+53, r20	; 0x35
    6000:	5e ab       	std	Y+54, r21	; 0x36
    6002:	6f ab       	std	Y+55, r22	; 0x37
    6004:	78 af       	std	Y+56, r23	; 0x38
    6006:	89 af       	std	Y+57, r24	; 0x39
    6008:	9a af       	std	Y+58, r25	; 0x3a
    600a:	2b a9       	ldd	r18, Y+51	; 0x33
    600c:	3c a9       	ldd	r19, Y+52	; 0x34
    600e:	4d a9       	ldd	r20, Y+53	; 0x35
    6010:	5e a9       	ldd	r21, Y+54	; 0x36
    6012:	6f a9       	ldd	r22, Y+55	; 0x37
    6014:	78 ad       	ldd	r23, Y+56	; 0x38
    6016:	89 ad       	ldd	r24, Y+57	; 0x39
    6018:	9a ad       	ldd	r25, Y+58	; 0x3a
    601a:	23 96       	adiw	r28, 0x03	; 3
    601c:	ef ad       	ldd	r30, Y+63	; 0x3f
    601e:	23 97       	sbiw	r28, 0x03	; 3
    6020:	f0 e0       	ldi	r31, 0x00	; 0
    6022:	df 01       	movw	r26, r30
    6024:	aa 0f       	add	r26, r26
    6026:	bb 1f       	adc	r27, r27
    6028:	aa 0f       	add	r26, r26
    602a:	bb 1f       	adc	r27, r27
    602c:	ea 0f       	add	r30, r26
    602e:	fb 1f       	adc	r31, r27
    6030:	e0 52       	subi	r30, 0x20	; 32
    6032:	f3 4f       	sbci	r31, 0xF3	; 243
    6034:	e2 81       	ldd	r30, Z+2	; 0x02
    6036:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    603a:	e2 2b       	or	r30, r18
    603c:	eb ab       	std	Y+51, r30	; 0x33
    603e:	3c ab       	std	Y+52, r19	; 0x34
    6040:	4d ab       	std	Y+53, r20	; 0x35
    6042:	5e ab       	std	Y+54, r21	; 0x36
    6044:	6f ab       	std	Y+55, r22	; 0x37
    6046:	78 af       	std	Y+56, r23	; 0x38
    6048:	89 af       	std	Y+57, r24	; 0x39
    604a:	9a af       	std	Y+58, r25	; 0x3a
    604c:	0b a9       	ldd	r16, Y+51	; 0x33
    604e:	1c a9       	ldd	r17, Y+52	; 0x34
    6050:	2d a9       	ldd	r18, Y+53	; 0x35
    6052:	3e a9       	ldd	r19, Y+54	; 0x36
    6054:	4f a9       	ldd	r20, Y+55	; 0x37
    6056:	58 ad       	ldd	r21, Y+56	; 0x38
    6058:	69 ad       	ldd	r22, Y+57	; 0x39
    605a:	7a ad       	ldd	r23, Y+58	; 0x3a
    605c:	ce 01       	movw	r24, r28
    605e:	4f 96       	adiw	r24, 0x1f	; 31
    6060:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    6064:	88 23       	and	r24, r24
    6066:	d1 f0       	breq	.+52     	; 0x609c <SENSORS_APPLY_SEND_BUFFER+0x95e>
    6068:	20 e0       	ldi	r18, 0x00	; 0
    606a:	30 e0       	ldi	r19, 0x00	; 0
    606c:	24 96       	adiw	r28, 0x04	; 4
    606e:	9f ad       	ldd	r25, Y+63	; 0x3f
    6070:	24 97       	sbiw	r28, 0x04	; 4
    6072:	f9 01       	movw	r30, r18
    6074:	e9 0f       	add	r30, r25
    6076:	f1 1d       	adc	r31, r1
    6078:	af e1       	ldi	r26, 0x1F	; 31
    607a:	b0 e0       	ldi	r27, 0x00	; 0
    607c:	ac 0f       	add	r26, r28
    607e:	bd 1f       	adc	r27, r29
    6080:	a2 0f       	add	r26, r18
    6082:	b3 1f       	adc	r27, r19
    6084:	9c 91       	ld	r25, X
    6086:	41 e0       	ldi	r20, 0x01	; 1
    6088:	50 e0       	ldi	r21, 0x00	; 0
    608a:	4c 0f       	add	r20, r28
    608c:	5d 1f       	adc	r21, r29
    608e:	e4 0f       	add	r30, r20
    6090:	f5 1f       	adc	r31, r21
    6092:	90 83       	st	Z, r25
    6094:	2f 5f       	subi	r18, 0xFF	; 255
    6096:	3f 4f       	sbci	r19, 0xFF	; 255
    6098:	28 17       	cp	r18, r24
    609a:	40 f3       	brcs	.-48     	; 0x606c <SENSORS_APPLY_SEND_BUFFER+0x92e>
    609c:	24 96       	adiw	r28, 0x04	; 4
    609e:	9f ad       	ldd	r25, Y+63	; 0x3f
    60a0:	24 97       	sbiw	r28, 0x04	; 4
    60a2:	89 0f       	add	r24, r25
    60a4:	24 96       	adiw	r28, 0x04	; 4
    60a6:	8f af       	std	Y+63, r24	; 0x3f
    60a8:	24 97       	sbiw	r28, 0x04	; 4
    60aa:	24 96       	adiw	r28, 0x04	; 4
    60ac:	8f ad       	ldd	r24, Y+63	; 0x3f
    60ae:	24 97       	sbiw	r28, 0x04	; 4
    60b0:	e1 e0       	ldi	r30, 0x01	; 1
    60b2:	f0 e0       	ldi	r31, 0x00	; 0
    60b4:	ec 0f       	add	r30, r28
    60b6:	fd 1f       	adc	r31, r29
    60b8:	e8 0f       	add	r30, r24
    60ba:	f1 1d       	adc	r31, r1
    60bc:	8a e3       	ldi	r24, 0x3A	; 58
    60be:	80 83       	st	Z, r24
    60c0:	24 96       	adiw	r28, 0x04	; 4
    60c2:	8f ad       	ldd	r24, Y+63	; 0x3f
    60c4:	24 97       	sbiw	r28, 0x04	; 4
    60c6:	8f 5f       	subi	r24, 0xFF	; 255
    60c8:	24 96       	adiw	r28, 0x04	; 4
    60ca:	8f af       	std	Y+63, r24	; 0x3f
    60cc:	24 97       	sbiw	r28, 0x04	; 4
    60ce:	1b aa       	std	Y+51, r1	; 0x33
    60d0:	1c aa       	std	Y+52, r1	; 0x34
    60d2:	1d aa       	std	Y+53, r1	; 0x35
    60d4:	1e aa       	std	Y+54, r1	; 0x36
    60d6:	1f aa       	std	Y+55, r1	; 0x37
    60d8:	18 ae       	std	Y+56, r1	; 0x38
    60da:	19 ae       	std	Y+57, r1	; 0x39
    60dc:	1a ae       	std	Y+58, r1	; 0x3a
    60de:	2b a9       	ldd	r18, Y+51	; 0x33
    60e0:	3c a9       	ldd	r19, Y+52	; 0x34
    60e2:	4d a9       	ldd	r20, Y+53	; 0x35
    60e4:	5e a9       	ldd	r21, Y+54	; 0x36
    60e6:	6f a9       	ldd	r22, Y+55	; 0x37
    60e8:	78 ad       	ldd	r23, Y+56	; 0x38
    60ea:	89 ad       	ldd	r24, Y+57	; 0x39
    60ec:	9a ad       	ldd	r25, Y+58	; 0x3a
    60ee:	23 96       	adiw	r28, 0x03	; 3
    60f0:	ef ad       	ldd	r30, Y+63	; 0x3f
    60f2:	23 97       	sbiw	r28, 0x03	; 3
    60f4:	f0 e0       	ldi	r31, 0x00	; 0
    60f6:	df 01       	movw	r26, r30
    60f8:	aa 0f       	add	r26, r26
    60fa:	bb 1f       	adc	r27, r27
    60fc:	aa 0f       	add	r26, r26
    60fe:	bb 1f       	adc	r27, r27
    6100:	ea 0f       	add	r30, r26
    6102:	fb 1f       	adc	r31, r27
    6104:	e0 52       	subi	r30, 0x20	; 32
    6106:	f3 4f       	sbci	r31, 0xF3	; 243
    6108:	e3 81       	ldd	r30, Z+3	; 0x03
    610a:	08 e0       	ldi	r16, 0x08	; 8
    610c:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    6110:	e2 2b       	or	r30, r18
    6112:	eb ab       	std	Y+51, r30	; 0x33
    6114:	3c ab       	std	Y+52, r19	; 0x34
    6116:	4d ab       	std	Y+53, r20	; 0x35
    6118:	5e ab       	std	Y+54, r21	; 0x36
    611a:	6f ab       	std	Y+55, r22	; 0x37
    611c:	78 af       	std	Y+56, r23	; 0x38
    611e:	89 af       	std	Y+57, r24	; 0x39
    6120:	9a af       	std	Y+58, r25	; 0x3a
    6122:	2b a9       	ldd	r18, Y+51	; 0x33
    6124:	3c a9       	ldd	r19, Y+52	; 0x34
    6126:	4d a9       	ldd	r20, Y+53	; 0x35
    6128:	5e a9       	ldd	r21, Y+54	; 0x36
    612a:	6f a9       	ldd	r22, Y+55	; 0x37
    612c:	78 ad       	ldd	r23, Y+56	; 0x38
    612e:	89 ad       	ldd	r24, Y+57	; 0x39
    6130:	9a ad       	ldd	r25, Y+58	; 0x3a
    6132:	23 96       	adiw	r28, 0x03	; 3
    6134:	ef ad       	ldd	r30, Y+63	; 0x3f
    6136:	23 97       	sbiw	r28, 0x03	; 3
    6138:	f0 e0       	ldi	r31, 0x00	; 0
    613a:	df 01       	movw	r26, r30
    613c:	aa 0f       	add	r26, r26
    613e:	bb 1f       	adc	r27, r27
    6140:	aa 0f       	add	r26, r26
    6142:	bb 1f       	adc	r27, r27
    6144:	ea 0f       	add	r30, r26
    6146:	fb 1f       	adc	r31, r27
    6148:	e0 52       	subi	r30, 0x20	; 32
    614a:	f3 4f       	sbci	r31, 0xF3	; 243
    614c:	e4 81       	ldd	r30, Z+4	; 0x04
    614e:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    6152:	e2 2b       	or	r30, r18
    6154:	eb ab       	std	Y+51, r30	; 0x33
    6156:	3c ab       	std	Y+52, r19	; 0x34
    6158:	4d ab       	std	Y+53, r20	; 0x35
    615a:	5e ab       	std	Y+54, r21	; 0x36
    615c:	6f ab       	std	Y+55, r22	; 0x37
    615e:	78 af       	std	Y+56, r23	; 0x38
    6160:	89 af       	std	Y+57, r24	; 0x39
    6162:	9a af       	std	Y+58, r25	; 0x3a
    6164:	0b a9       	ldd	r16, Y+51	; 0x33
    6166:	1c a9       	ldd	r17, Y+52	; 0x34
    6168:	2d a9       	ldd	r18, Y+53	; 0x35
    616a:	3e a9       	ldd	r19, Y+54	; 0x36
    616c:	4f a9       	ldd	r20, Y+55	; 0x37
    616e:	58 ad       	ldd	r21, Y+56	; 0x38
    6170:	69 ad       	ldd	r22, Y+57	; 0x39
    6172:	7a ad       	ldd	r23, Y+58	; 0x3a
    6174:	ce 01       	movw	r24, r28
    6176:	4f 96       	adiw	r24, 0x1f	; 31
    6178:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    617c:	88 23       	and	r24, r24
    617e:	d1 f0       	breq	.+52     	; 0x61b4 <SENSORS_APPLY_SEND_BUFFER+0xa76>
    6180:	20 e0       	ldi	r18, 0x00	; 0
    6182:	30 e0       	ldi	r19, 0x00	; 0
    6184:	24 96       	adiw	r28, 0x04	; 4
    6186:	9f ad       	ldd	r25, Y+63	; 0x3f
    6188:	24 97       	sbiw	r28, 0x04	; 4
    618a:	f9 01       	movw	r30, r18
    618c:	e9 0f       	add	r30, r25
    618e:	f1 1d       	adc	r31, r1
    6190:	af e1       	ldi	r26, 0x1F	; 31
    6192:	b0 e0       	ldi	r27, 0x00	; 0
    6194:	ac 0f       	add	r26, r28
    6196:	bd 1f       	adc	r27, r29
    6198:	a2 0f       	add	r26, r18
    619a:	b3 1f       	adc	r27, r19
    619c:	9c 91       	ld	r25, X
    619e:	41 e0       	ldi	r20, 0x01	; 1
    61a0:	50 e0       	ldi	r21, 0x00	; 0
    61a2:	4c 0f       	add	r20, r28
    61a4:	5d 1f       	adc	r21, r29
    61a6:	e4 0f       	add	r30, r20
    61a8:	f5 1f       	adc	r31, r21
    61aa:	90 83       	st	Z, r25
    61ac:	2f 5f       	subi	r18, 0xFF	; 255
    61ae:	3f 4f       	sbci	r19, 0xFF	; 255
    61b0:	28 17       	cp	r18, r24
    61b2:	40 f3       	brcs	.-48     	; 0x6184 <SENSORS_APPLY_SEND_BUFFER+0xa46>
    61b4:	24 96       	adiw	r28, 0x04	; 4
    61b6:	9f ad       	ldd	r25, Y+63	; 0x3f
    61b8:	24 97       	sbiw	r28, 0x04	; 4
    61ba:	89 0f       	add	r24, r25
    61bc:	24 96       	adiw	r28, 0x04	; 4
    61be:	8f af       	std	Y+63, r24	; 0x3f
    61c0:	24 97       	sbiw	r28, 0x04	; 4
    61c2:	24 96       	adiw	r28, 0x04	; 4
    61c4:	8f ad       	ldd	r24, Y+63	; 0x3f
    61c6:	24 97       	sbiw	r28, 0x04	; 4
    61c8:	e1 e0       	ldi	r30, 0x01	; 1
    61ca:	f0 e0       	ldi	r31, 0x00	; 0
    61cc:	ec 0f       	add	r30, r28
    61ce:	fd 1f       	adc	r31, r29
    61d0:	e8 0f       	add	r30, r24
    61d2:	f1 1d       	adc	r31, r1
    61d4:	8a e3       	ldi	r24, 0x3A	; 58
    61d6:	80 83       	st	Z, r24
    61d8:	24 96       	adiw	r28, 0x04	; 4
    61da:	ef ad       	ldd	r30, Y+63	; 0x3f
    61dc:	24 97       	sbiw	r28, 0x04	; 4
    61de:	f0 e0       	ldi	r31, 0x00	; 0
    61e0:	31 96       	adiw	r30, 0x01	; 1
    61e2:	81 e0       	ldi	r24, 0x01	; 1
    61e4:	90 e0       	ldi	r25, 0x00	; 0
    61e6:	8c 0f       	add	r24, r28
    61e8:	9d 1f       	adc	r25, r29
    61ea:	e8 0f       	add	r30, r24
    61ec:	f9 1f       	adc	r31, r25
    61ee:	10 82       	st	Z, r1
    61f0:	4f ef       	ldi	r20, 0xFF	; 255
    61f2:	5f ef       	ldi	r21, 0xFF	; 255
    61f4:	ba 01       	movw	r22, r20
    61f6:	80 91 71 0e 	lds	r24, 0x0E71
    61fa:	90 91 72 0e 	lds	r25, 0x0E72
    61fe:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    6202:	24 96       	adiw	r28, 0x04	; 4
    6204:	4f ad       	ldd	r20, Y+63	; 0x3f
    6206:	24 97       	sbiw	r28, 0x04	; 4
    6208:	4e 5f       	subi	r20, 0xFE	; 254
    620a:	be 01       	movw	r22, r28
    620c:	6f 5f       	subi	r22, 0xFF	; 255
    620e:	7f 4f       	sbci	r23, 0xFF	; 255
    6210:	89 e2       	ldi	r24, 0x29	; 41
    6212:	9f e0       	ldi	r25, 0x0F	; 15
    6214:	0e 94 4f 05 	call	0xa9e	; 0xa9e <QUEUE_ADD_ARRAY_U8>
    6218:	00 e0       	ldi	r16, 0x00	; 0
    621a:	20 e0       	ldi	r18, 0x00	; 0
    621c:	30 e0       	ldi	r19, 0x00	; 0
    621e:	a9 01       	movw	r20, r18
    6220:	60 e0       	ldi	r22, 0x00	; 0
    6222:	70 e0       	ldi	r23, 0x00	; 0
    6224:	80 91 71 0e 	lds	r24, 0x0E71
    6228:	90 91 72 0e 	lds	r25, 0x0E72
    622c:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <xQueueGenericSend>
    6230:	23 96       	adiw	r28, 0x03	; 3
    6232:	8f ad       	ldd	r24, Y+63	; 0x3f
    6234:	23 97       	sbiw	r28, 0x03	; 3
    6236:	8f 5f       	subi	r24, 0xFF	; 255
    6238:	23 96       	adiw	r28, 0x03	; 3
    623a:	8f af       	std	Y+63, r24	; 0x3f
    623c:	23 97       	sbiw	r28, 0x03	; 3
    623e:	23 96       	adiw	r28, 0x03	; 3
    6240:	9f ad       	ldd	r25, Y+63	; 0x3f
    6242:	23 97       	sbiw	r28, 0x03	; 3
    6244:	80 91 51 0c 	lds	r24, 0x0C51
    6248:	98 17       	cp	r25, r24
    624a:	08 f4       	brcc	.+2      	; 0x624e <SENSORS_APPLY_SEND_BUFFER+0xb10>
    624c:	b8 ca       	rjmp	.-2704   	; 0x57be <SENSORS_APPLY_SEND_BUFFER+0x80>
    624e:	10 92 51 0c 	sts	0x0C51, r1
    6252:	cd 5b       	subi	r28, 0xBD	; 189
    6254:	df 4f       	sbci	r29, 0xFF	; 255
    6256:	0f b6       	in	r0, 0x3f	; 63
    6258:	f8 94       	cli
    625a:	de bf       	out	0x3e, r29	; 62
    625c:	0f be       	out	0x3f, r0	; 63
    625e:	cd bf       	out	0x3d, r28	; 61
    6260:	df 91       	pop	r29
    6262:	cf 91       	pop	r28
    6264:	1f 91       	pop	r17
    6266:	0f 91       	pop	r16
    6268:	ff 90       	pop	r15
    626a:	ef 90       	pop	r14
    626c:	df 90       	pop	r13
    626e:	cf 90       	pop	r12
    6270:	bf 90       	pop	r11
    6272:	af 90       	pop	r10
    6274:	9f 90       	pop	r9
    6276:	8f 90       	pop	r8
    6278:	7f 90       	pop	r7
    627a:	6f 90       	pop	r6
    627c:	5f 90       	pop	r5
    627e:	08 95       	ret

00006280 <SENSORS_APPLY_READ_BUFFER>:
    6280:	2f 92       	push	r2
    6282:	3f 92       	push	r3
    6284:	4f 92       	push	r4
    6286:	5f 92       	push	r5
    6288:	6f 92       	push	r6
    628a:	7f 92       	push	r7
    628c:	8f 92       	push	r8
    628e:	9f 92       	push	r9
    6290:	af 92       	push	r10
    6292:	bf 92       	push	r11
    6294:	cf 92       	push	r12
    6296:	df 92       	push	r13
    6298:	ef 92       	push	r14
    629a:	ff 92       	push	r15
    629c:	0f 93       	push	r16
    629e:	1f 93       	push	r17
    62a0:	cf 93       	push	r28
    62a2:	df 93       	push	r29
    62a4:	cd b7       	in	r28, 0x3d	; 61
    62a6:	de b7       	in	r29, 0x3e	; 62
    62a8:	e8 97       	sbiw	r28, 0x38	; 56
    62aa:	0f b6       	in	r0, 0x3f	; 63
    62ac:	f8 94       	cli
    62ae:	de bf       	out	0x3e, r29	; 62
    62b0:	0f be       	out	0x3f, r0	; 63
    62b2:	cd bf       	out	0x3d, r28	; 61
    62b4:	80 91 50 0c 	lds	r24, 0x0C50
    62b8:	88 23       	and	r24, r24
    62ba:	09 f4       	brne	.+2      	; 0x62be <SENSORS_APPLY_READ_BUFFER+0x3e>
    62bc:	6e c3       	rjmp	.+1756   	; 0x699a <SENSORS_APPLY_READ_BUFFER+0x71a>
    62be:	80 91 50 0c 	lds	r24, 0x0C50
    62c2:	88 23       	and	r24, r24
    62c4:	09 f4       	brne	.+2      	; 0x62c8 <SENSORS_APPLY_READ_BUFFER+0x48>
    62c6:	5d c3       	rjmp	.+1722   	; 0x6982 <SENSORS_APPLY_READ_BUFFER+0x702>
    62c8:	81 2c       	mov	r8, r1
    62ca:	1d aa       	std	Y+53, r1	; 0x35
    62cc:	1e aa       	std	Y+54, r1	; 0x36
    62ce:	1f aa       	std	Y+55, r1	; 0x37
    62d0:	18 ae       	std	Y+56, r1	; 0x38
    62d2:	1b aa       	std	Y+51, r1	; 0x33
    62d4:	21 2c       	mov	r2, r1
    62d6:	31 2c       	mov	r3, r1
    62d8:	41 2c       	mov	r4, r1
    62da:	71 2c       	mov	r7, r1
    62dc:	0f 2e       	mov	r0, r31
    62de:	f9 e1       	ldi	r31, 0x19	; 25
    62e0:	6f 2e       	mov	r6, r31
    62e2:	f0 2d       	mov	r31, r0
    62e4:	51 2c       	mov	r5, r1
    62e6:	c7 2c       	mov	r12, r7
    62e8:	d1 2c       	mov	r13, r1
    62ea:	f6 01       	movw	r30, r12
    62ec:	ee 0f       	add	r30, r30
    62ee:	ff 1f       	adc	r31, r31
    62f0:	ee 0f       	add	r30, r30
    62f2:	ff 1f       	adc	r31, r31
    62f4:	ec 0d       	add	r30, r12
    62f6:	fd 1d       	adc	r31, r13
    62f8:	ed 5c       	subi	r30, 0xCD	; 205
    62fa:	f1 4f       	sbci	r31, 0xF1	; 241
    62fc:	90 80       	ld	r9, Z
    62fe:	a9 2c       	mov	r10, r9
    6300:	b1 2c       	mov	r11, r1
    6302:	6a 9c       	mul	r6, r10
    6304:	f0 01       	movw	r30, r0
    6306:	6b 9c       	mul	r6, r11
    6308:	f0 0d       	add	r31, r0
    630a:	11 24       	eor	r1, r1
    630c:	ed 5e       	subi	r30, 0xED	; 237
    630e:	f2 4f       	sbci	r31, 0xF2	; 242
    6310:	84 85       	ldd	r24, Z+12	; 0x0c
    6312:	88 23       	and	r24, r24
    6314:	09 f4       	brne	.+2      	; 0x6318 <SENSORS_APPLY_READ_BUFFER+0x98>
    6316:	b7 c1       	rjmp	.+878    	; 0x6686 <SENSORS_APPLY_READ_BUFFER+0x406>
    6318:	6a 9c       	mul	r6, r10
    631a:	f0 01       	movw	r30, r0
    631c:	6b 9c       	mul	r6, r11
    631e:	f0 0d       	add	r31, r0
    6320:	11 24       	eor	r1, r1
    6322:	ed 5e       	subi	r30, 0xED	; 237
    6324:	f2 4f       	sbci	r31, 0xF2	; 242
    6326:	86 85       	ldd	r24, Z+14	; 0x0e
    6328:	88 23       	and	r24, r24
    632a:	09 f4       	brne	.+2      	; 0x632e <SENSORS_APPLY_READ_BUFFER+0xae>
    632c:	ac c1       	rjmp	.+856    	; 0x6686 <SENSORS_APPLY_READ_BUFFER+0x406>
    632e:	6a 9c       	mul	r6, r10
    6330:	f0 01       	movw	r30, r0
    6332:	6b 9c       	mul	r6, r11
    6334:	f0 0d       	add	r31, r0
    6336:	11 24       	eor	r1, r1
    6338:	ed 5e       	subi	r30, 0xED	; 237
    633a:	f2 4f       	sbci	r31, 0xF2	; 242
    633c:	84 89       	ldd	r24, Z+20	; 0x14
    633e:	88 23       	and	r24, r24
    6340:	09 f4       	brne	.+2      	; 0x6344 <SENSORS_APPLY_READ_BUFFER+0xc4>
    6342:	a1 c1       	rjmp	.+834    	; 0x6686 <SENSORS_APPLY_READ_BUFFER+0x406>
    6344:	6a 9c       	mul	r6, r10
    6346:	c0 01       	movw	r24, r0
    6348:	6b 9c       	mul	r6, r11
    634a:	90 0d       	add	r25, r0
    634c:	11 24       	eor	r1, r1
    634e:	9c ab       	std	Y+52, r25	; 0x34
    6350:	8b ab       	std	Y+51, r24	; 0x33
    6352:	8f 01       	movw	r16, r30
    6354:	e3 89       	ldd	r30, Z+19	; 0x13
    6356:	f0 e0       	ldi	r31, 0x00	; 0
    6358:	ec 5e       	subi	r30, 0xEC	; 236
    635a:	fe 4f       	sbci	r31, 0xFE	; 254
    635c:	80 81       	ld	r24, Z
    635e:	0e 94 c0 10 	call	0x2180	; 0x2180 <NRF_UPDATE_USED_CHANNEL>
    6362:	f8 01       	movw	r30, r16
    6364:	40 81       	ld	r20, Z
    6366:	62 85       	ldd	r22, Z+10	; 0x0a
    6368:	86 01       	movw	r16, r12
    636a:	00 0f       	add	r16, r16
    636c:	11 1f       	adc	r17, r17
    636e:	00 0f       	add	r16, r16
    6370:	11 1f       	adc	r17, r17
    6372:	0c 0d       	add	r16, r12
    6374:	1d 1d       	adc	r17, r13
    6376:	c8 01       	movw	r24, r16
    6378:	8a 5c       	subi	r24, 0xCA	; 202
    637a:	91 4f       	sbci	r25, 0xF1	; 241
    637c:	7c 01       	movw	r14, r24
    637e:	0c 5c       	subi	r16, 0xCC	; 204
    6380:	11 4f       	sbci	r17, 0xF1	; 241
    6382:	2b a9       	ldd	r18, Y+51	; 0x33
    6384:	3c a9       	ldd	r19, Y+52	; 0x34
    6386:	28 5d       	subi	r18, 0xD8	; 216
    6388:	32 4f       	sbci	r19, 0xF2	; 242
    638a:	8b a9       	ldd	r24, Y+51	; 0x33
    638c:	9c a9       	ldd	r25, Y+52	; 0x34
    638e:	8c 5e       	subi	r24, 0xEC	; 236
    6390:	92 4f       	sbci	r25, 0xF2	; 242
    6392:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <PROTOCOL_DATA_READ>
    6396:	88 23       	and	r24, r24
    6398:	09 f4       	brne	.+2      	; 0x639c <SENSORS_APPLY_READ_BUFFER+0x11c>
    639a:	75 c1       	rjmp	.+746    	; 0x6686 <SENSORS_APPLY_READ_BUFFER+0x406>
    639c:	6a 9c       	mul	r6, r10
    639e:	80 01       	movw	r16, r0
    63a0:	6b 9c       	mul	r6, r11
    63a2:	10 0d       	add	r17, r0
    63a4:	11 24       	eor	r1, r1
    63a6:	0d 5e       	subi	r16, 0xED	; 237
    63a8:	12 4f       	sbci	r17, 0xF2	; 242
    63aa:	d8 01       	movw	r26, r16
    63ac:	58 96       	adiw	r26, 0x18	; 24
    63ae:	1c 92       	st	X, r1
    63b0:	84 e9       	ldi	r24, 0x94	; 148
    63b2:	91 e0       	ldi	r25, 0x01	; 1
    63b4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    63b8:	84 e9       	ldi	r24, 0x94	; 148
    63ba:	91 e0       	ldi	r25, 0x01	; 1
    63bc:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    63c0:	84 e9       	ldi	r24, 0x94	; 148
    63c2:	91 e0       	ldi	r25, 0x01	; 1
    63c4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    63c8:	84 e9       	ldi	r24, 0x94	; 148
    63ca:	91 e0       	ldi	r25, 0x01	; 1
    63cc:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    63d0:	84 e9       	ldi	r24, 0x94	; 148
    63d2:	91 e0       	ldi	r25, 0x01	; 1
    63d4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    63d8:	84 e9       	ldi	r24, 0x94	; 148
    63da:	91 e0       	ldi	r25, 0x01	; 1
    63dc:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    63e0:	84 e9       	ldi	r24, 0x94	; 148
    63e2:	91 e0       	ldi	r25, 0x01	; 1
    63e4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    63e8:	84 e9       	ldi	r24, 0x94	; 148
    63ea:	91 e0       	ldi	r25, 0x01	; 1
    63ec:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    63f0:	85 ec       	ldi	r24, 0xC5	; 197
    63f2:	93 e0       	ldi	r25, 0x03	; 3
    63f4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    63f8:	29 2d       	mov	r18, r9
    63fa:	30 e0       	ldi	r19, 0x00	; 0
    63fc:	40 e0       	ldi	r20, 0x00	; 0
    63fe:	50 e0       	ldi	r21, 0x00	; 0
    6400:	60 e0       	ldi	r22, 0x00	; 0
    6402:	70 e0       	ldi	r23, 0x00	; 0
    6404:	80 e0       	ldi	r24, 0x00	; 0
    6406:	90 e0       	ldi	r25, 0x00	; 0
    6408:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    640c:	84 e9       	ldi	r24, 0x94	; 148
    640e:	91 e0       	ldi	r25, 0x01	; 1
    6410:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    6414:	84 e9       	ldi	r24, 0x94	; 148
    6416:	91 e0       	ldi	r25, 0x01	; 1
    6418:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    641c:	84 e9       	ldi	r24, 0x94	; 148
    641e:	91 e0       	ldi	r25, 0x01	; 1
    6420:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    6424:	84 e9       	ldi	r24, 0x94	; 148
    6426:	91 e0       	ldi	r25, 0x01	; 1
    6428:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    642c:	84 e9       	ldi	r24, 0x94	; 148
    642e:	91 e0       	ldi	r25, 0x01	; 1
    6430:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    6434:	84 e9       	ldi	r24, 0x94	; 148
    6436:	91 e0       	ldi	r25, 0x01	; 1
    6438:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    643c:	84 e9       	ldi	r24, 0x94	; 148
    643e:	91 e0       	ldi	r25, 0x01	; 1
    6440:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    6444:	84 e9       	ldi	r24, 0x94	; 148
    6446:	91 e0       	ldi	r25, 0x01	; 1
    6448:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    644c:	f8 01       	movw	r30, r16
    644e:	11 8a       	std	Z+17, r1	; 0x11
    6450:	f1 e4       	ldi	r31, 0x41	; 65
    6452:	f9 83       	std	Y+1, r31	; 0x01
    6454:	2a e3       	ldi	r18, 0x3A	; 58
    6456:	2a 83       	std	Y+2, r18	; 0x02
    6458:	d8 01       	movw	r26, r16
    645a:	1c 91       	ld	r17, X
    645c:	11 23       	and	r17, r17
    645e:	19 f1       	breq	.+70     	; 0x64a6 <SENSORS_APPLY_READ_BUFFER+0x226>
    6460:	6a 9c       	mul	r6, r10
    6462:	d0 01       	movw	r26, r0
    6464:	6b 9c       	mul	r6, r11
    6466:	b0 0d       	add	r27, r0
    6468:	11 24       	eor	r1, r1
    646a:	ad 5e       	subi	r26, 0xED	; 237
    646c:	b2 4f       	sbci	r27, 0xF2	; 242
    646e:	28 2d       	mov	r18, r8
    6470:	3d a9       	ldd	r19, Y+53	; 0x35
    6472:	4e a9       	ldd	r20, Y+54	; 0x36
    6474:	5f a9       	ldd	r21, Y+55	; 0x37
    6476:	68 ad       	ldd	r22, Y+56	; 0x38
    6478:	75 2d       	mov	r23, r5
    647a:	82 2d       	mov	r24, r2
    647c:	93 2d       	mov	r25, r3
    647e:	08 e0       	ldi	r16, 0x08	; 8
    6480:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    6484:	e1 2f       	mov	r30, r17
    6486:	f0 e0       	ldi	r31, 0x00	; 0
    6488:	31 97       	sbiw	r30, 0x01	; 1
    648a:	ea 0f       	add	r30, r26
    648c:	fb 1f       	adc	r31, r27
    648e:	e1 81       	ldd	r30, Z+1	; 0x01
    6490:	2e 2b       	or	r18, r30
    6492:	11 50       	subi	r17, 0x01	; 1
    6494:	a1 f7       	brne	.-24     	; 0x647e <SENSORS_APPLY_READ_BUFFER+0x1fe>
    6496:	82 2e       	mov	r8, r18
    6498:	3d ab       	std	Y+53, r19	; 0x35
    649a:	4e ab       	std	Y+54, r20	; 0x36
    649c:	5f ab       	std	Y+55, r21	; 0x37
    649e:	68 af       	std	Y+56, r22	; 0x38
    64a0:	57 2e       	mov	r5, r23
    64a2:	28 2e       	mov	r2, r24
    64a4:	39 2e       	mov	r3, r25
    64a6:	08 2d       	mov	r16, r8
    64a8:	1d a9       	ldd	r17, Y+53	; 0x35
    64aa:	2e a9       	ldd	r18, Y+54	; 0x36
    64ac:	3f a9       	ldd	r19, Y+55	; 0x37
    64ae:	48 ad       	ldd	r20, Y+56	; 0x38
    64b0:	55 2d       	mov	r21, r5
    64b2:	62 2d       	mov	r22, r2
    64b4:	73 2d       	mov	r23, r3
    64b6:	ce 01       	movw	r24, r28
    64b8:	4f 96       	adiw	r24, 0x1f	; 31
    64ba:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    64be:	e8 2e       	mov	r14, r24
    64c0:	88 23       	and	r24, r24
    64c2:	89 f0       	breq	.+34     	; 0x64e6 <SENSORS_APPLY_READ_BUFFER+0x266>
    64c4:	fe 01       	movw	r30, r28
    64c6:	7f 96       	adiw	r30, 0x1f	; 31
    64c8:	de 01       	movw	r26, r28
    64ca:	13 96       	adiw	r26, 0x03	; 3
    64cc:	8f ef       	ldi	r24, 0xFF	; 255
    64ce:	8e 0d       	add	r24, r14
    64d0:	20 e2       	ldi	r18, 0x20	; 32
    64d2:	30 e0       	ldi	r19, 0x00	; 0
    64d4:	2c 0f       	add	r18, r28
    64d6:	3d 1f       	adc	r19, r29
    64d8:	28 0f       	add	r18, r24
    64da:	31 1d       	adc	r19, r1
    64dc:	81 91       	ld	r24, Z+
    64de:	8d 93       	st	X+, r24
    64e0:	e2 17       	cp	r30, r18
    64e2:	f3 07       	cpc	r31, r19
    64e4:	d9 f7       	brne	.-10     	; 0x64dc <SENSORS_APPLY_READ_BUFFER+0x25c>
    64e6:	82 e0       	ldi	r24, 0x02	; 2
    64e8:	8e 0d       	add	r24, r14
    64ea:	90 e0       	ldi	r25, 0x00	; 0
    64ec:	e1 e0       	ldi	r30, 0x01	; 1
    64ee:	f0 e0       	ldi	r31, 0x00	; 0
    64f0:	ec 0f       	add	r30, r28
    64f2:	fd 1f       	adc	r31, r29
    64f4:	e8 0f       	add	r30, r24
    64f6:	f9 1f       	adc	r31, r25
    64f8:	ba e3       	ldi	r27, 0x3A	; 58
    64fa:	b0 83       	st	Z, r27
    64fc:	e2 e0       	ldi	r30, 0x02	; 2
    64fe:	f0 e0       	ldi	r31, 0x00	; 0
    6500:	ec 0f       	add	r30, r28
    6502:	fd 1f       	adc	r31, r29
    6504:	e8 0f       	add	r30, r24
    6506:	f9 1f       	adc	r31, r25
    6508:	2b e4       	ldi	r18, 0x4B	; 75
    650a:	20 83       	st	Z, r18
    650c:	e3 e0       	ldi	r30, 0x03	; 3
    650e:	f0 e0       	ldi	r31, 0x00	; 0
    6510:	ec 0f       	add	r30, r28
    6512:	fd 1f       	adc	r31, r29
    6514:	e8 0f       	add	r30, r24
    6516:	f9 1f       	adc	r31, r25
    6518:	b0 83       	st	Z, r27
    651a:	0f 2e       	mov	r0, r31
    651c:	f5 e0       	ldi	r31, 0x05	; 5
    651e:	ff 2e       	mov	r15, r31
    6520:	f0 2d       	mov	r31, r0
    6522:	fe 0c       	add	r15, r14
    6524:	f6 01       	movw	r30, r12
    6526:	ee 0f       	add	r30, r30
    6528:	ff 1f       	adc	r31, r31
    652a:	ee 0f       	add	r30, r30
    652c:	ff 1f       	adc	r31, r31
    652e:	ec 0d       	add	r30, r12
    6530:	fd 1d       	adc	r31, r13
    6532:	ed 5c       	subi	r30, 0xCD	; 205
    6534:	f1 4f       	sbci	r31, 0xF1	; 241
    6536:	21 81       	ldd	r18, Z+1	; 0x01
    6538:	e2 81       	ldd	r30, Z+2	; 0x02
    653a:	30 e0       	ldi	r19, 0x00	; 0
    653c:	40 e0       	ldi	r20, 0x00	; 0
    653e:	50 e0       	ldi	r21, 0x00	; 0
    6540:	60 e0       	ldi	r22, 0x00	; 0
    6542:	70 e0       	ldi	r23, 0x00	; 0
    6544:	80 e0       	ldi	r24, 0x00	; 0
    6546:	90 e0       	ldi	r25, 0x00	; 0
    6548:	08 e0       	ldi	r16, 0x08	; 8
    654a:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    654e:	02 2f       	mov	r16, r18
    6550:	0e 2b       	or	r16, r30
    6552:	13 2f       	mov	r17, r19
    6554:	24 2f       	mov	r18, r20
    6556:	35 2f       	mov	r19, r21
    6558:	46 2f       	mov	r20, r22
    655a:	57 2f       	mov	r21, r23
    655c:	68 2f       	mov	r22, r24
    655e:	79 2f       	mov	r23, r25
    6560:	ce 01       	movw	r24, r28
    6562:	4f 96       	adiw	r24, 0x1f	; 31
    6564:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    6568:	88 23       	and	r24, r24
    656a:	89 f0       	breq	.+34     	; 0x658e <SENSORS_APPLY_READ_BUFFER+0x30e>
    656c:	fe 01       	movw	r30, r28
    656e:	7f 96       	adiw	r30, 0x1f	; 31
    6570:	38 2f       	mov	r19, r24
    6572:	3e 0d       	add	r19, r14
    6574:	3b 5f       	subi	r19, 0xFB	; 251
    6576:	9f 2d       	mov	r25, r15
    6578:	21 91       	ld	r18, Z+
    657a:	a1 e0       	ldi	r26, 0x01	; 1
    657c:	b0 e0       	ldi	r27, 0x00	; 0
    657e:	ac 0f       	add	r26, r28
    6580:	bd 1f       	adc	r27, r29
    6582:	a9 0f       	add	r26, r25
    6584:	b1 1d       	adc	r27, r1
    6586:	2c 93       	st	X, r18
    6588:	9f 5f       	subi	r25, 0xFF	; 255
    658a:	93 13       	cpse	r25, r19
    658c:	f5 cf       	rjmp	.-22     	; 0x6578 <SENSORS_APPLY_READ_BUFFER+0x2f8>
    658e:	f8 0e       	add	r15, r24
    6590:	e1 e0       	ldi	r30, 0x01	; 1
    6592:	f0 e0       	ldi	r31, 0x00	; 0
    6594:	ec 0f       	add	r30, r28
    6596:	fd 1f       	adc	r31, r29
    6598:	ef 0d       	add	r30, r15
    659a:	f1 1d       	adc	r31, r1
    659c:	8a e3       	ldi	r24, 0x3A	; 58
    659e:	80 83       	st	Z, r24
    65a0:	ee 24       	eor	r14, r14
    65a2:	e3 94       	inc	r14
    65a4:	ef 0c       	add	r14, r15
    65a6:	f6 01       	movw	r30, r12
    65a8:	ee 0f       	add	r30, r30
    65aa:	ff 1f       	adc	r31, r31
    65ac:	ee 0f       	add	r30, r30
    65ae:	ff 1f       	adc	r31, r31
    65b0:	ec 0d       	add	r30, r12
    65b2:	fd 1d       	adc	r31, r13
    65b4:	ed 5c       	subi	r30, 0xCD	; 205
    65b6:	f1 4f       	sbci	r31, 0xF1	; 241
    65b8:	23 81       	ldd	r18, Z+3	; 0x03
    65ba:	e4 81       	ldd	r30, Z+4	; 0x04
    65bc:	30 e0       	ldi	r19, 0x00	; 0
    65be:	40 e0       	ldi	r20, 0x00	; 0
    65c0:	50 e0       	ldi	r21, 0x00	; 0
    65c2:	60 e0       	ldi	r22, 0x00	; 0
    65c4:	70 e0       	ldi	r23, 0x00	; 0
    65c6:	80 e0       	ldi	r24, 0x00	; 0
    65c8:	90 e0       	ldi	r25, 0x00	; 0
    65ca:	08 e0       	ldi	r16, 0x08	; 8
    65cc:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    65d0:	82 2e       	mov	r8, r18
    65d2:	8e 2a       	or	r8, r30
    65d4:	3d ab       	std	Y+53, r19	; 0x35
    65d6:	4e ab       	std	Y+54, r20	; 0x36
    65d8:	5f ab       	std	Y+55, r21	; 0x37
    65da:	68 af       	std	Y+56, r22	; 0x38
    65dc:	57 2e       	mov	r5, r23
    65de:	28 2e       	mov	r2, r24
    65e0:	39 2e       	mov	r3, r25
    65e2:	08 2d       	mov	r16, r8
    65e4:	13 2f       	mov	r17, r19
    65e6:	24 2f       	mov	r18, r20
    65e8:	35 2f       	mov	r19, r21
    65ea:	46 2f       	mov	r20, r22
    65ec:	57 2f       	mov	r21, r23
    65ee:	68 2f       	mov	r22, r24
    65f0:	79 2f       	mov	r23, r25
    65f2:	ce 01       	movw	r24, r28
    65f4:	4f 96       	adiw	r24, 0x1f	; 31
    65f6:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    65fa:	88 23       	and	r24, r24
    65fc:	89 f0       	breq	.+34     	; 0x6620 <SENSORS_APPLY_READ_BUFFER+0x3a0>
    65fe:	fe 01       	movw	r30, r28
    6600:	7f 96       	adiw	r30, 0x1f	; 31
    6602:	91 e0       	ldi	r25, 0x01	; 1
    6604:	98 0f       	add	r25, r24
    6606:	f9 0e       	add	r15, r25
    6608:	9e 2d       	mov	r25, r14
    660a:	21 91       	ld	r18, Z+
    660c:	a1 e0       	ldi	r26, 0x01	; 1
    660e:	b0 e0       	ldi	r27, 0x00	; 0
    6610:	ac 0f       	add	r26, r28
    6612:	bd 1f       	adc	r27, r29
    6614:	a9 0f       	add	r26, r25
    6616:	b1 1d       	adc	r27, r1
    6618:	2c 93       	st	X, r18
    661a:	9f 5f       	subi	r25, 0xFF	; 255
    661c:	9f 11       	cpse	r25, r15
    661e:	f5 cf       	rjmp	.-22     	; 0x660a <SENSORS_APPLY_READ_BUFFER+0x38a>
    6620:	e8 0e       	add	r14, r24
    6622:	2e 2d       	mov	r18, r14
    6624:	30 e0       	ldi	r19, 0x00	; 0
    6626:	e1 e0       	ldi	r30, 0x01	; 1
    6628:	f0 e0       	ldi	r31, 0x00	; 0
    662a:	ec 0f       	add	r30, r28
    662c:	fd 1f       	adc	r31, r29
    662e:	e2 0f       	add	r30, r18
    6630:	f3 1f       	adc	r31, r19
    6632:	9a e3       	ldi	r25, 0x3A	; 58
    6634:	90 83       	st	Z, r25
    6636:	e2 e0       	ldi	r30, 0x02	; 2
    6638:	f0 e0       	ldi	r31, 0x00	; 0
    663a:	ec 0f       	add	r30, r28
    663c:	fd 1f       	adc	r31, r29
    663e:	e2 0f       	add	r30, r18
    6640:	f3 1f       	adc	r31, r19
    6642:	10 82       	st	Z, r1
    6644:	4f ef       	ldi	r20, 0xFF	; 255
    6646:	5f ef       	ldi	r21, 0xFF	; 255
    6648:	ba 01       	movw	r22, r20
    664a:	80 91 71 0e 	lds	r24, 0x0E71
    664e:	90 91 72 0e 	lds	r25, 0x0E72
    6652:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    6656:	42 e0       	ldi	r20, 0x02	; 2
    6658:	4e 0d       	add	r20, r14
    665a:	be 01       	movw	r22, r28
    665c:	6f 5f       	subi	r22, 0xFF	; 255
    665e:	7f 4f       	sbci	r23, 0xFF	; 255
    6660:	89 e2       	ldi	r24, 0x29	; 41
    6662:	9f e0       	ldi	r25, 0x0F	; 15
    6664:	0e 94 4f 05 	call	0xa9e	; 0xa9e <QUEUE_ADD_ARRAY_U8>
    6668:	00 e0       	ldi	r16, 0x00	; 0
    666a:	20 e0       	ldi	r18, 0x00	; 0
    666c:	30 e0       	ldi	r19, 0x00	; 0
    666e:	a9 01       	movw	r20, r18
    6670:	60 e0       	ldi	r22, 0x00	; 0
    6672:	70 e0       	ldi	r23, 0x00	; 0
    6674:	80 91 71 0e 	lds	r24, 0x0E71
    6678:	90 91 72 0e 	lds	r25, 0x0E72
    667c:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <xQueueGenericSend>
    6680:	44 24       	eor	r4, r4
    6682:	43 94       	inc	r4
    6684:	78 c1       	rjmp	.+752    	; 0x6976 <SENSORS_APPLY_READ_BUFFER+0x6f6>
    6686:	41 10       	cpse	r4, r1
    6688:	76 c1       	rjmp	.+748    	; 0x6976 <SENSORS_APPLY_READ_BUFFER+0x6f6>
    668a:	6a 9c       	mul	r6, r10
    668c:	f0 01       	movw	r30, r0
    668e:	6b 9c       	mul	r6, r11
    6690:	f0 0d       	add	r31, r0
    6692:	11 24       	eor	r1, r1
    6694:	ed 5e       	subi	r30, 0xED	; 237
    6696:	f2 4f       	sbci	r31, 0xF2	; 242
    6698:	80 8d       	ldd	r24, Z+24	; 0x18
    669a:	8f 5f       	subi	r24, 0xFF	; 255
    669c:	80 8f       	std	Z+24, r24	; 0x18
    669e:	80 8d       	ldd	r24, Z+24	; 0x18
    66a0:	83 30       	cpi	r24, 0x03	; 3
    66a2:	09 f0       	breq	.+2      	; 0x66a6 <SENSORS_APPLY_READ_BUFFER+0x426>
    66a4:	68 c1       	rjmp	.+720    	; 0x6976 <SENSORS_APPLY_READ_BUFFER+0x6f6>
    66a6:	8f 01       	movw	r16, r30
    66a8:	10 8e       	std	Z+24, r1	; 0x18
    66aa:	84 e9       	ldi	r24, 0x94	; 148
    66ac:	91 e0       	ldi	r25, 0x01	; 1
    66ae:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    66b2:	84 e9       	ldi	r24, 0x94	; 148
    66b4:	91 e0       	ldi	r25, 0x01	; 1
    66b6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    66ba:	84 e9       	ldi	r24, 0x94	; 148
    66bc:	91 e0       	ldi	r25, 0x01	; 1
    66be:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    66c2:	84 e9       	ldi	r24, 0x94	; 148
    66c4:	91 e0       	ldi	r25, 0x01	; 1
    66c6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    66ca:	84 e9       	ldi	r24, 0x94	; 148
    66cc:	91 e0       	ldi	r25, 0x01	; 1
    66ce:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    66d2:	84 e9       	ldi	r24, 0x94	; 148
    66d4:	91 e0       	ldi	r25, 0x01	; 1
    66d6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    66da:	84 e9       	ldi	r24, 0x94	; 148
    66dc:	91 e0       	ldi	r25, 0x01	; 1
    66de:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    66e2:	84 e9       	ldi	r24, 0x94	; 148
    66e4:	91 e0       	ldi	r25, 0x01	; 1
    66e6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    66ea:	8f ec       	ldi	r24, 0xCF	; 207
    66ec:	93 e0       	ldi	r25, 0x03	; 3
    66ee:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    66f2:	29 2d       	mov	r18, r9
    66f4:	30 e0       	ldi	r19, 0x00	; 0
    66f6:	40 e0       	ldi	r20, 0x00	; 0
    66f8:	50 e0       	ldi	r21, 0x00	; 0
    66fa:	60 e0       	ldi	r22, 0x00	; 0
    66fc:	70 e0       	ldi	r23, 0x00	; 0
    66fe:	80 e0       	ldi	r24, 0x00	; 0
    6700:	90 e0       	ldi	r25, 0x00	; 0
    6702:	0e 94 1d 3d 	call	0x7a3a	; 0x7a3a <TEST_UART_SEND_VALUE>
    6706:	84 e9       	ldi	r24, 0x94	; 148
    6708:	91 e0       	ldi	r25, 0x01	; 1
    670a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    670e:	84 e9       	ldi	r24, 0x94	; 148
    6710:	91 e0       	ldi	r25, 0x01	; 1
    6712:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    6716:	84 e9       	ldi	r24, 0x94	; 148
    6718:	91 e0       	ldi	r25, 0x01	; 1
    671a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    671e:	84 e9       	ldi	r24, 0x94	; 148
    6720:	91 e0       	ldi	r25, 0x01	; 1
    6722:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    6726:	84 e9       	ldi	r24, 0x94	; 148
    6728:	91 e0       	ldi	r25, 0x01	; 1
    672a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    672e:	84 e9       	ldi	r24, 0x94	; 148
    6730:	91 e0       	ldi	r25, 0x01	; 1
    6732:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    6736:	84 e9       	ldi	r24, 0x94	; 148
    6738:	91 e0       	ldi	r25, 0x01	; 1
    673a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    673e:	84 e9       	ldi	r24, 0x94	; 148
    6740:	91 e0       	ldi	r25, 0x01	; 1
    6742:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <TEST_UART_SEND_str>
    6746:	b1 e4       	ldi	r27, 0x41	; 65
    6748:	b9 83       	std	Y+1, r27	; 0x01
    674a:	ea e3       	ldi	r30, 0x3A	; 58
    674c:	ea 83       	std	Y+2, r30	; 0x02
    674e:	d8 01       	movw	r26, r16
    6750:	fc 90       	ld	r15, X
    6752:	ff 20       	and	r15, r15
    6754:	b1 f0       	breq	.+44     	; 0x6782 <SENSORS_APPLY_READ_BUFFER+0x502>
    6756:	20 e0       	ldi	r18, 0x00	; 0
    6758:	30 e0       	ldi	r19, 0x00	; 0
    675a:	40 e0       	ldi	r20, 0x00	; 0
    675c:	50 e0       	ldi	r21, 0x00	; 0
    675e:	60 e0       	ldi	r22, 0x00	; 0
    6760:	70 e0       	ldi	r23, 0x00	; 0
    6762:	80 e0       	ldi	r24, 0x00	; 0
    6764:	90 e0       	ldi	r25, 0x00	; 0
    6766:	d8 01       	movw	r26, r16
    6768:	08 e0       	ldi	r16, 0x08	; 8
    676a:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    676e:	ef 2d       	mov	r30, r15
    6770:	f0 e0       	ldi	r31, 0x00	; 0
    6772:	31 97       	sbiw	r30, 0x01	; 1
    6774:	ea 0f       	add	r30, r26
    6776:	fb 1f       	adc	r31, r27
    6778:	e1 81       	ldd	r30, Z+1	; 0x01
    677a:	2e 2b       	or	r18, r30
    677c:	fa 94       	dec	r15
    677e:	a1 f7       	brne	.-24     	; 0x6768 <SENSORS_APPLY_READ_BUFFER+0x4e8>
    6780:	08 c0       	rjmp	.+16     	; 0x6792 <SENSORS_APPLY_READ_BUFFER+0x512>
    6782:	20 e0       	ldi	r18, 0x00	; 0
    6784:	30 e0       	ldi	r19, 0x00	; 0
    6786:	40 e0       	ldi	r20, 0x00	; 0
    6788:	50 e0       	ldi	r21, 0x00	; 0
    678a:	60 e0       	ldi	r22, 0x00	; 0
    678c:	70 e0       	ldi	r23, 0x00	; 0
    678e:	80 e0       	ldi	r24, 0x00	; 0
    6790:	90 e0       	ldi	r25, 0x00	; 0
    6792:	02 2f       	mov	r16, r18
    6794:	13 2f       	mov	r17, r19
    6796:	24 2f       	mov	r18, r20
    6798:	35 2f       	mov	r19, r21
    679a:	46 2f       	mov	r20, r22
    679c:	57 2f       	mov	r21, r23
    679e:	68 2f       	mov	r22, r24
    67a0:	79 2f       	mov	r23, r25
    67a2:	ce 01       	movw	r24, r28
    67a4:	4f 96       	adiw	r24, 0x1f	; 31
    67a6:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    67aa:	88 23       	and	r24, r24
    67ac:	89 f0       	breq	.+34     	; 0x67d0 <SENSORS_APPLY_READ_BUFFER+0x550>
    67ae:	fe 01       	movw	r30, r28
    67b0:	7f 96       	adiw	r30, 0x1f	; 31
    67b2:	de 01       	movw	r26, r28
    67b4:	13 96       	adiw	r26, 0x03	; 3
    67b6:	9f ef       	ldi	r25, 0xFF	; 255
    67b8:	98 0f       	add	r25, r24
    67ba:	20 e2       	ldi	r18, 0x20	; 32
    67bc:	30 e0       	ldi	r19, 0x00	; 0
    67be:	2c 0f       	add	r18, r28
    67c0:	3d 1f       	adc	r19, r29
    67c2:	29 0f       	add	r18, r25
    67c4:	31 1d       	adc	r19, r1
    67c6:	91 91       	ld	r25, Z+
    67c8:	9d 93       	st	X+, r25
    67ca:	e2 17       	cp	r30, r18
    67cc:	f3 07       	cpc	r31, r19
    67ce:	d9 f7       	brne	.-10     	; 0x67c6 <SENSORS_APPLY_READ_BUFFER+0x546>
    67d0:	22 e0       	ldi	r18, 0x02	; 2
    67d2:	28 0f       	add	r18, r24
    67d4:	30 e0       	ldi	r19, 0x00	; 0
    67d6:	e1 e0       	ldi	r30, 0x01	; 1
    67d8:	f0 e0       	ldi	r31, 0x00	; 0
    67da:	ec 0f       	add	r30, r28
    67dc:	fd 1f       	adc	r31, r29
    67de:	e2 0f       	add	r30, r18
    67e0:	f3 1f       	adc	r31, r19
    67e2:	ba e3       	ldi	r27, 0x3A	; 58
    67e4:	b0 83       	st	Z, r27
    67e6:	e2 e0       	ldi	r30, 0x02	; 2
    67e8:	f0 e0       	ldi	r31, 0x00	; 0
    67ea:	ec 0f       	add	r30, r28
    67ec:	fd 1f       	adc	r31, r29
    67ee:	e2 0f       	add	r30, r18
    67f0:	f3 1f       	adc	r31, r19
    67f2:	96 e4       	ldi	r25, 0x46	; 70
    67f4:	90 83       	st	Z, r25
    67f6:	e3 e0       	ldi	r30, 0x03	; 3
    67f8:	f0 e0       	ldi	r31, 0x00	; 0
    67fa:	ec 0f       	add	r30, r28
    67fc:	fd 1f       	adc	r31, r29
    67fe:	e2 0f       	add	r30, r18
    6800:	f3 1f       	adc	r31, r19
    6802:	b0 83       	st	Z, r27
    6804:	0f 2e       	mov	r0, r31
    6806:	f5 e0       	ldi	r31, 0x05	; 5
    6808:	ff 2e       	mov	r15, r31
    680a:	f0 2d       	mov	r31, r0
    680c:	f8 0e       	add	r15, r24
    680e:	f6 01       	movw	r30, r12
    6810:	ee 0f       	add	r30, r30
    6812:	ff 1f       	adc	r31, r31
    6814:	ee 0f       	add	r30, r30
    6816:	ff 1f       	adc	r31, r31
    6818:	ec 0d       	add	r30, r12
    681a:	fd 1d       	adc	r31, r13
    681c:	ed 5c       	subi	r30, 0xCD	; 205
    681e:	f1 4f       	sbci	r31, 0xF1	; 241
    6820:	21 81       	ldd	r18, Z+1	; 0x01
    6822:	e2 81       	ldd	r30, Z+2	; 0x02
    6824:	30 e0       	ldi	r19, 0x00	; 0
    6826:	40 e0       	ldi	r20, 0x00	; 0
    6828:	50 e0       	ldi	r21, 0x00	; 0
    682a:	60 e0       	ldi	r22, 0x00	; 0
    682c:	70 e0       	ldi	r23, 0x00	; 0
    682e:	80 e0       	ldi	r24, 0x00	; 0
    6830:	90 e0       	ldi	r25, 0x00	; 0
    6832:	08 e0       	ldi	r16, 0x08	; 8
    6834:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    6838:	02 2f       	mov	r16, r18
    683a:	0e 2b       	or	r16, r30
    683c:	13 2f       	mov	r17, r19
    683e:	24 2f       	mov	r18, r20
    6840:	35 2f       	mov	r19, r21
    6842:	46 2f       	mov	r20, r22
    6844:	57 2f       	mov	r21, r23
    6846:	68 2f       	mov	r22, r24
    6848:	79 2f       	mov	r23, r25
    684a:	ce 01       	movw	r24, r28
    684c:	4f 96       	adiw	r24, 0x1f	; 31
    684e:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    6852:	88 23       	and	r24, r24
    6854:	a9 f0       	breq	.+42     	; 0x6880 <SENSORS_APPLY_READ_BUFFER+0x600>
    6856:	fe 01       	movw	r30, r28
    6858:	7f 96       	adiw	r30, 0x1f	; 31
    685a:	a1 e0       	ldi	r26, 0x01	; 1
    685c:	b0 e0       	ldi	r27, 0x00	; 0
    685e:	ac 0f       	add	r26, r28
    6860:	bd 1f       	adc	r27, r29
    6862:	af 0d       	add	r26, r15
    6864:	b1 1d       	adc	r27, r1
    6866:	9f ef       	ldi	r25, 0xFF	; 255
    6868:	98 0f       	add	r25, r24
    686a:	20 e2       	ldi	r18, 0x20	; 32
    686c:	30 e0       	ldi	r19, 0x00	; 0
    686e:	2c 0f       	add	r18, r28
    6870:	3d 1f       	adc	r19, r29
    6872:	29 0f       	add	r18, r25
    6874:	31 1d       	adc	r19, r1
    6876:	91 91       	ld	r25, Z+
    6878:	9d 93       	st	X+, r25
    687a:	e2 17       	cp	r30, r18
    687c:	f3 07       	cpc	r31, r19
    687e:	d9 f7       	brne	.-10     	; 0x6876 <SENSORS_APPLY_READ_BUFFER+0x5f6>
    6880:	f8 0e       	add	r15, r24
    6882:	e1 e0       	ldi	r30, 0x01	; 1
    6884:	f0 e0       	ldi	r31, 0x00	; 0
    6886:	ec 0f       	add	r30, r28
    6888:	fd 1f       	adc	r31, r29
    688a:	ef 0d       	add	r30, r15
    688c:	f1 1d       	adc	r31, r1
    688e:	aa e3       	ldi	r26, 0x3A	; 58
    6890:	a0 83       	st	Z, r26
    6892:	f3 94       	inc	r15
    6894:	f6 01       	movw	r30, r12
    6896:	ee 0f       	add	r30, r30
    6898:	ff 1f       	adc	r31, r31
    689a:	ee 0f       	add	r30, r30
    689c:	ff 1f       	adc	r31, r31
    689e:	ec 0d       	add	r30, r12
    68a0:	fd 1d       	adc	r31, r13
    68a2:	ed 5c       	subi	r30, 0xCD	; 205
    68a4:	f1 4f       	sbci	r31, 0xF1	; 241
    68a6:	23 81       	ldd	r18, Z+3	; 0x03
    68a8:	e4 81       	ldd	r30, Z+4	; 0x04
    68aa:	30 e0       	ldi	r19, 0x00	; 0
    68ac:	40 e0       	ldi	r20, 0x00	; 0
    68ae:	50 e0       	ldi	r21, 0x00	; 0
    68b0:	60 e0       	ldi	r22, 0x00	; 0
    68b2:	70 e0       	ldi	r23, 0x00	; 0
    68b4:	80 e0       	ldi	r24, 0x00	; 0
    68b6:	90 e0       	ldi	r25, 0x00	; 0
    68b8:	08 e0       	ldi	r16, 0x08	; 8
    68ba:	0e 94 b9 42 	call	0x8572	; 0x8572 <__ashldi3>
    68be:	82 2e       	mov	r8, r18
    68c0:	8e 2a       	or	r8, r30
    68c2:	3d ab       	std	Y+53, r19	; 0x35
    68c4:	4e ab       	std	Y+54, r20	; 0x36
    68c6:	5f ab       	std	Y+55, r21	; 0x37
    68c8:	68 af       	std	Y+56, r22	; 0x38
    68ca:	57 2e       	mov	r5, r23
    68cc:	28 2e       	mov	r2, r24
    68ce:	39 2e       	mov	r3, r25
    68d0:	08 2d       	mov	r16, r8
    68d2:	13 2f       	mov	r17, r19
    68d4:	24 2f       	mov	r18, r20
    68d6:	35 2f       	mov	r19, r21
    68d8:	46 2f       	mov	r20, r22
    68da:	57 2f       	mov	r21, r23
    68dc:	68 2f       	mov	r22, r24
    68de:	79 2f       	mov	r23, r25
    68e0:	ce 01       	movw	r24, r28
    68e2:	4f 96       	adiw	r24, 0x1f	; 31
    68e4:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    68e8:	88 23       	and	r24, r24
    68ea:	a9 f0       	breq	.+42     	; 0x6916 <SENSORS_APPLY_READ_BUFFER+0x696>
    68ec:	fe 01       	movw	r30, r28
    68ee:	7f 96       	adiw	r30, 0x1f	; 31
    68f0:	a1 e0       	ldi	r26, 0x01	; 1
    68f2:	b0 e0       	ldi	r27, 0x00	; 0
    68f4:	ac 0f       	add	r26, r28
    68f6:	bd 1f       	adc	r27, r29
    68f8:	af 0d       	add	r26, r15
    68fa:	b1 1d       	adc	r27, r1
    68fc:	9f ef       	ldi	r25, 0xFF	; 255
    68fe:	98 0f       	add	r25, r24
    6900:	20 e2       	ldi	r18, 0x20	; 32
    6902:	30 e0       	ldi	r19, 0x00	; 0
    6904:	2c 0f       	add	r18, r28
    6906:	3d 1f       	adc	r19, r29
    6908:	29 0f       	add	r18, r25
    690a:	31 1d       	adc	r19, r1
    690c:	91 91       	ld	r25, Z+
    690e:	9d 93       	st	X+, r25
    6910:	e2 17       	cp	r30, r18
    6912:	f3 07       	cpc	r31, r19
    6914:	d9 f7       	brne	.-10     	; 0x690c <SENSORS_APPLY_READ_BUFFER+0x68c>
    6916:	f8 0e       	add	r15, r24
    6918:	2f 2d       	mov	r18, r15
    691a:	30 e0       	ldi	r19, 0x00	; 0
    691c:	e1 e0       	ldi	r30, 0x01	; 1
    691e:	f0 e0       	ldi	r31, 0x00	; 0
    6920:	ec 0f       	add	r30, r28
    6922:	fd 1f       	adc	r31, r29
    6924:	e2 0f       	add	r30, r18
    6926:	f3 1f       	adc	r31, r19
    6928:	ba e3       	ldi	r27, 0x3A	; 58
    692a:	b0 83       	st	Z, r27
    692c:	e2 e0       	ldi	r30, 0x02	; 2
    692e:	f0 e0       	ldi	r31, 0x00	; 0
    6930:	ec 0f       	add	r30, r28
    6932:	fd 1f       	adc	r31, r29
    6934:	e2 0f       	add	r30, r18
    6936:	f3 1f       	adc	r31, r19
    6938:	10 82       	st	Z, r1
    693a:	4f ef       	ldi	r20, 0xFF	; 255
    693c:	5f ef       	ldi	r21, 0xFF	; 255
    693e:	ba 01       	movw	r22, r20
    6940:	80 91 71 0e 	lds	r24, 0x0E71
    6944:	90 91 72 0e 	lds	r25, 0x0E72
    6948:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    694c:	42 e0       	ldi	r20, 0x02	; 2
    694e:	4f 0d       	add	r20, r15
    6950:	be 01       	movw	r22, r28
    6952:	6f 5f       	subi	r22, 0xFF	; 255
    6954:	7f 4f       	sbci	r23, 0xFF	; 255
    6956:	89 e2       	ldi	r24, 0x29	; 41
    6958:	9f e0       	ldi	r25, 0x0F	; 15
    695a:	0e 94 4f 05 	call	0xa9e	; 0xa9e <QUEUE_ADD_ARRAY_U8>
    695e:	00 e0       	ldi	r16, 0x00	; 0
    6960:	20 e0       	ldi	r18, 0x00	; 0
    6962:	30 e0       	ldi	r19, 0x00	; 0
    6964:	a9 01       	movw	r20, r18
    6966:	60 e0       	ldi	r22, 0x00	; 0
    6968:	70 e0       	ldi	r23, 0x00	; 0
    696a:	80 91 71 0e 	lds	r24, 0x0E71
    696e:	90 91 72 0e 	lds	r25, 0x0E72
    6972:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <xQueueGenericSend>
    6976:	73 94       	inc	r7
    6978:	80 91 50 0c 	lds	r24, 0x0C50
    697c:	78 16       	cp	r7, r24
    697e:	08 f4       	brcc	.+2      	; 0x6982 <SENSORS_APPLY_READ_BUFFER+0x702>
    6980:	b2 cc       	rjmp	.-1692   	; 0x62e6 <SENSORS_APPLY_READ_BUFFER+0x66>
    6982:	10 92 50 0c 	sts	0x0C50, r1
    6986:	80 91 50 0c 	lds	r24, 0x0C50
    698a:	81 11       	cpse	r24, r1
    698c:	06 c0       	rjmp	.+12     	; 0x699a <SENSORS_APPLY_READ_BUFFER+0x71a>
    698e:	80 91 51 0c 	lds	r24, 0x0C51
    6992:	81 11       	cpse	r24, r1
    6994:	02 c0       	rjmp	.+4      	; 0x699a <SENSORS_APPLY_READ_BUFFER+0x71a>
    6996:	10 92 c6 10 	sts	0x10C6, r1
    699a:	e8 96       	adiw	r28, 0x38	; 56
    699c:	0f b6       	in	r0, 0x3f	; 63
    699e:	f8 94       	cli
    69a0:	de bf       	out	0x3e, r29	; 62
    69a2:	0f be       	out	0x3f, r0	; 63
    69a4:	cd bf       	out	0x3d, r28	; 61
    69a6:	df 91       	pop	r29
    69a8:	cf 91       	pop	r28
    69aa:	1f 91       	pop	r17
    69ac:	0f 91       	pop	r16
    69ae:	ff 90       	pop	r15
    69b0:	ef 90       	pop	r14
    69b2:	df 90       	pop	r13
    69b4:	cf 90       	pop	r12
    69b6:	bf 90       	pop	r11
    69b8:	af 90       	pop	r10
    69ba:	9f 90       	pop	r9
    69bc:	8f 90       	pop	r8
    69be:	7f 90       	pop	r7
    69c0:	6f 90       	pop	r6
    69c2:	5f 90       	pop	r5
    69c4:	4f 90       	pop	r4
    69c6:	3f 90       	pop	r3
    69c8:	2f 90       	pop	r2
    69ca:	08 95       	ret

000069cc <SENSORS_IO_SETUP>:
    69cc:	26 e0       	ldi	r18, 0x06	; 6
    69ce:	41 e0       	ldi	r20, 0x01	; 1
    69d0:	63 e2       	ldi	r22, 0x23	; 35
    69d2:	70 e0       	ldi	r23, 0x00	; 0
    69d4:	82 e2       	ldi	r24, 0x22	; 34
    69d6:	90 e0       	ldi	r25, 0x00	; 0
    69d8:	0c 94 55 08 	jmp	0x10aa	; 0x10aa <gpio_inputconfg>
    69dc:	08 95       	ret

000069de <SENSORS_LOAD_EEPROM>:
    69de:	df 92       	push	r13
    69e0:	ef 92       	push	r14
    69e2:	ff 92       	push	r15
    69e4:	0f 93       	push	r16
    69e6:	1f 93       	push	r17
    69e8:	cf 93       	push	r28
    69ea:	df 93       	push	r29
    69ec:	83 e6       	ldi	r24, 0x63	; 99
    69ee:	90 e0       	ldi	r25, 0x00	; 0
    69f0:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    69f4:	84 34       	cpi	r24, 0x44	; 68
    69f6:	09 f0       	breq	.+2      	; 0x69fa <SENSORS_LOAD_EEPROM+0x1c>
    69f8:	72 c0       	rjmp	.+228    	; 0x6ade <SENSORS_LOAD_EEPROM+0x100>
    69fa:	84 e6       	ldi	r24, 0x64	; 100
    69fc:	90 e0       	ldi	r25, 0x00	; 0
    69fe:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6a02:	80 93 56 0c 	sts	0x0C56, r24
    6a06:	c5 e6       	ldi	r28, 0x65	; 101
    6a08:	d0 e0       	ldi	r29, 0x00	; 0
    6a0a:	e1 2c       	mov	r14, r1
    6a0c:	f1 2c       	mov	r15, r1
    6a0e:	0f 2e       	mov	r0, r31
    6a10:	f9 e1       	ldi	r31, 0x19	; 25
    6a12:	df 2e       	mov	r13, r31
    6a14:	f0 2d       	mov	r31, r0
    6a16:	ce 01       	movw	r24, r28
    6a18:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6a1c:	de 9c       	mul	r13, r14
    6a1e:	80 01       	movw	r16, r0
    6a20:	df 9c       	mul	r13, r15
    6a22:	10 0d       	add	r17, r0
    6a24:	11 24       	eor	r1, r1
    6a26:	0d 5e       	subi	r16, 0xED	; 237
    6a28:	12 4f       	sbci	r17, 0xF2	; 242
    6a2a:	f8 01       	movw	r30, r16
    6a2c:	80 83       	st	Z, r24
    6a2e:	ce 01       	movw	r24, r28
    6a30:	01 96       	adiw	r24, 0x01	; 1
    6a32:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6a36:	f8 01       	movw	r30, r16
    6a38:	81 83       	std	Z+1, r24	; 0x01
    6a3a:	ce 01       	movw	r24, r28
    6a3c:	02 96       	adiw	r24, 0x02	; 2
    6a3e:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6a42:	f8 01       	movw	r30, r16
    6a44:	82 83       	std	Z+2, r24	; 0x02
    6a46:	ce 01       	movw	r24, r28
    6a48:	03 96       	adiw	r24, 0x03	; 3
    6a4a:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6a4e:	f8 01       	movw	r30, r16
    6a50:	83 83       	std	Z+3, r24	; 0x03
    6a52:	ce 01       	movw	r24, r28
    6a54:	04 96       	adiw	r24, 0x04	; 4
    6a56:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6a5a:	f8 01       	movw	r30, r16
    6a5c:	84 83       	std	Z+4, r24	; 0x04
    6a5e:	ce 01       	movw	r24, r28
    6a60:	05 96       	adiw	r24, 0x05	; 5
    6a62:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6a66:	f8 01       	movw	r30, r16
    6a68:	85 83       	std	Z+5, r24	; 0x05
    6a6a:	ce 01       	movw	r24, r28
    6a6c:	06 96       	adiw	r24, 0x06	; 6
    6a6e:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6a72:	f8 01       	movw	r30, r16
    6a74:	86 83       	std	Z+6, r24	; 0x06
    6a76:	ce 01       	movw	r24, r28
    6a78:	07 96       	adiw	r24, 0x07	; 7
    6a7a:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6a7e:	f8 01       	movw	r30, r16
    6a80:	87 83       	std	Z+7, r24	; 0x07
    6a82:	ce 01       	movw	r24, r28
    6a84:	08 96       	adiw	r24, 0x08	; 8
    6a86:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6a8a:	f8 01       	movw	r30, r16
    6a8c:	80 87       	std	Z+8, r24	; 0x08
    6a8e:	ce 01       	movw	r24, r28
    6a90:	09 96       	adiw	r24, 0x09	; 9
    6a92:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6a96:	f8 01       	movw	r30, r16
    6a98:	81 87       	std	Z+9, r24	; 0x09
    6a9a:	ce 01       	movw	r24, r28
    6a9c:	0a 96       	adiw	r24, 0x0a	; 10
    6a9e:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6aa2:	f8 01       	movw	r30, r16
    6aa4:	82 87       	std	Z+10, r24	; 0x0a
    6aa6:	ce 01       	movw	r24, r28
    6aa8:	0b 96       	adiw	r24, 0x0b	; 11
    6aaa:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6aae:	f8 01       	movw	r30, r16
    6ab0:	83 87       	std	Z+11, r24	; 0x0b
    6ab2:	ce 01       	movw	r24, r28
    6ab4:	0c 96       	adiw	r24, 0x0c	; 12
    6ab6:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6aba:	f8 01       	movw	r30, r16
    6abc:	84 87       	std	Z+12, r24	; 0x0c
    6abe:	ce 01       	movw	r24, r28
    6ac0:	0d 96       	adiw	r24, 0x0d	; 13
    6ac2:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6ac6:	f8 01       	movw	r30, r16
    6ac8:	85 87       	std	Z+13, r24	; 0x0d
    6aca:	ff ef       	ldi	r31, 0xFF	; 255
    6acc:	ef 1a       	sub	r14, r31
    6ace:	ff 0a       	sbc	r15, r31
    6ad0:	2e 96       	adiw	r28, 0x0e	; 14
    6ad2:	8a e0       	ldi	r24, 0x0A	; 10
    6ad4:	e8 16       	cp	r14, r24
    6ad6:	f1 04       	cpc	r15, r1
    6ad8:	09 f0       	breq	.+2      	; 0x6adc <SENSORS_LOAD_EEPROM+0xfe>
    6ada:	9d cf       	rjmp	.-198    	; 0x6a16 <SENSORS_LOAD_EEPROM+0x38>
    6adc:	16 c0       	rjmp	.+44     	; 0x6b0a <SENSORS_LOAD_EEPROM+0x12c>
    6ade:	10 92 56 0c 	sts	0x0C56, r1
    6ae2:	60 e0       	ldi	r22, 0x00	; 0
    6ae4:	84 e6       	ldi	r24, 0x64	; 100
    6ae6:	90 e0       	ldi	r25, 0x00	; 0
    6ae8:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6aec:	c5 e6       	ldi	r28, 0x65	; 101
    6aee:	d0 e0       	ldi	r29, 0x00	; 0
    6af0:	60 e0       	ldi	r22, 0x00	; 0
    6af2:	ce 01       	movw	r24, r28
    6af4:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6af8:	21 96       	adiw	r28, 0x01	; 1
    6afa:	c1 3f       	cpi	r28, 0xF1	; 241
    6afc:	d1 05       	cpc	r29, r1
    6afe:	c1 f7       	brne	.-16     	; 0x6af0 <SENSORS_LOAD_EEPROM+0x112>
    6b00:	64 e4       	ldi	r22, 0x44	; 68
    6b02:	83 e6       	ldi	r24, 0x63	; 99
    6b04:	90 e0       	ldi	r25, 0x00	; 0
    6b06:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6b0a:	df 91       	pop	r29
    6b0c:	cf 91       	pop	r28
    6b0e:	1f 91       	pop	r17
    6b10:	0f 91       	pop	r16
    6b12:	ff 90       	pop	r15
    6b14:	ef 90       	pop	r14
    6b16:	df 90       	pop	r13
    6b18:	08 95       	ret

00006b1a <SAVE_OLD_LAST_ENTRY>:
    6b1a:	80 91 2d 0e 	lds	r24, 0x0E2D
    6b1e:	90 91 2e 0e 	lds	r25, 0x0E2E
    6b22:	a0 91 2f 0e 	lds	r26, 0x0E2F
    6b26:	b0 91 30 0e 	lds	r27, 0x0E30
    6b2a:	6b 2f       	mov	r22, r27
    6b2c:	77 27       	eor	r23, r23
    6b2e:	88 27       	eor	r24, r24
    6b30:	99 27       	eor	r25, r25
    6b32:	84 e8       	ldi	r24, 0x84	; 132
    6b34:	93 e0       	ldi	r25, 0x03	; 3
    6b36:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6b3a:	80 91 2d 0e 	lds	r24, 0x0E2D
    6b3e:	90 91 2e 0e 	lds	r25, 0x0E2E
    6b42:	a0 91 2f 0e 	lds	r26, 0x0E2F
    6b46:	b0 91 30 0e 	lds	r27, 0x0E30
    6b4a:	bd 01       	movw	r22, r26
    6b4c:	88 27       	eor	r24, r24
    6b4e:	99 27       	eor	r25, r25
    6b50:	85 e8       	ldi	r24, 0x85	; 133
    6b52:	93 e0       	ldi	r25, 0x03	; 3
    6b54:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6b58:	80 91 2d 0e 	lds	r24, 0x0E2D
    6b5c:	90 91 2e 0e 	lds	r25, 0x0E2E
    6b60:	a0 91 2f 0e 	lds	r26, 0x0E2F
    6b64:	b0 91 30 0e 	lds	r27, 0x0E30
    6b68:	69 2f       	mov	r22, r25
    6b6a:	7a 2f       	mov	r23, r26
    6b6c:	8b 2f       	mov	r24, r27
    6b6e:	99 27       	eor	r25, r25
    6b70:	86 e8       	ldi	r24, 0x86	; 134
    6b72:	93 e0       	ldi	r25, 0x03	; 3
    6b74:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6b78:	60 91 2d 0e 	lds	r22, 0x0E2D
    6b7c:	70 91 2e 0e 	lds	r23, 0x0E2E
    6b80:	80 91 2f 0e 	lds	r24, 0x0E2F
    6b84:	90 91 30 0e 	lds	r25, 0x0E30
    6b88:	87 e8       	ldi	r24, 0x87	; 135
    6b8a:	93 e0       	ldi	r25, 0x03	; 3
    6b8c:	0c 94 48 1c 	jmp	0x3890	; 0x3890 <writeeeprom>
    6b90:	08 95       	ret

00006b92 <LOAD_OLD_LAST_ENTRY>:
    6b92:	cf 92       	push	r12
    6b94:	df 92       	push	r13
    6b96:	ef 92       	push	r14
    6b98:	ff 92       	push	r15
    6b9a:	cf 93       	push	r28
    6b9c:	df 93       	push	r29
    6b9e:	10 92 2d 0e 	sts	0x0E2D, r1
    6ba2:	10 92 2e 0e 	sts	0x0E2E, r1
    6ba6:	10 92 2f 0e 	sts	0x0E2F, r1
    6baa:	10 92 30 0e 	sts	0x0E30, r1
    6bae:	83 e8       	ldi	r24, 0x83	; 131
    6bb0:	93 e0       	ldi	r25, 0x03	; 3
    6bb2:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6bb6:	84 34       	cpi	r24, 0x44	; 68
    6bb8:	01 f5       	brne	.+64     	; 0x6bfa <LOAD_OLD_LAST_ENTRY+0x68>
    6bba:	c4 e8       	ldi	r28, 0x84	; 132
    6bbc:	d3 e0       	ldi	r29, 0x03	; 3
    6bbe:	c0 90 2d 0e 	lds	r12, 0x0E2D
    6bc2:	d0 90 2e 0e 	lds	r13, 0x0E2E
    6bc6:	e0 90 2f 0e 	lds	r14, 0x0E2F
    6bca:	f0 90 30 0e 	lds	r15, 0x0E30
    6bce:	ce 01       	movw	r24, r28
    6bd0:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    6bd4:	fe 2c       	mov	r15, r14
    6bd6:	ed 2c       	mov	r14, r13
    6bd8:	dc 2c       	mov	r13, r12
    6bda:	cc 24       	eor	r12, r12
    6bdc:	c8 2a       	or	r12, r24
    6bde:	c0 92 2d 0e 	sts	0x0E2D, r12
    6be2:	d0 92 2e 0e 	sts	0x0E2E, r13
    6be6:	e0 92 2f 0e 	sts	0x0E2F, r14
    6bea:	f0 92 30 0e 	sts	0x0E30, r15
    6bee:	21 96       	adiw	r28, 0x01	; 1
    6bf0:	c8 38       	cpi	r28, 0x88	; 136
    6bf2:	83 e0       	ldi	r24, 0x03	; 3
    6bf4:	d8 07       	cpc	r29, r24
    6bf6:	19 f7       	brne	.-58     	; 0x6bbe <LOAD_OLD_LAST_ENTRY+0x2c>
    6bf8:	19 c0       	rjmp	.+50     	; 0x6c2c <LOAD_OLD_LAST_ENTRY+0x9a>
    6bfa:	64 e4       	ldi	r22, 0x44	; 68
    6bfc:	83 e8       	ldi	r24, 0x83	; 131
    6bfe:	93 e0       	ldi	r25, 0x03	; 3
    6c00:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6c04:	60 e0       	ldi	r22, 0x00	; 0
    6c06:	84 e8       	ldi	r24, 0x84	; 132
    6c08:	93 e0       	ldi	r25, 0x03	; 3
    6c0a:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6c0e:	60 e0       	ldi	r22, 0x00	; 0
    6c10:	85 e8       	ldi	r24, 0x85	; 133
    6c12:	93 e0       	ldi	r25, 0x03	; 3
    6c14:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6c18:	60 e0       	ldi	r22, 0x00	; 0
    6c1a:	86 e8       	ldi	r24, 0x86	; 134
    6c1c:	93 e0       	ldi	r25, 0x03	; 3
    6c1e:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6c22:	60 e0       	ldi	r22, 0x00	; 0
    6c24:	87 e8       	ldi	r24, 0x87	; 135
    6c26:	93 e0       	ldi	r25, 0x03	; 3
    6c28:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6c2c:	df 91       	pop	r29
    6c2e:	cf 91       	pop	r28
    6c30:	ff 90       	pop	r15
    6c32:	ef 90       	pop	r14
    6c34:	df 90       	pop	r13
    6c36:	cf 90       	pop	r12
    6c38:	08 95       	ret

00006c3a <SENSOR_SAVE>:
    6c3a:	0f 93       	push	r16
    6c3c:	1f 93       	push	r17
    6c3e:	cf 93       	push	r28
    6c40:	df 93       	push	r29
    6c42:	28 2f       	mov	r18, r24
    6c44:	30 e0       	ldi	r19, 0x00	; 0
    6c46:	99 e1       	ldi	r25, 0x19	; 25
    6c48:	89 9f       	mul	r24, r25
    6c4a:	80 01       	movw	r16, r0
    6c4c:	11 24       	eor	r1, r1
    6c4e:	0d 5e       	subi	r16, 0xED	; 237
    6c50:	12 4f       	sbci	r17, 0xF2	; 242
    6c52:	f8 01       	movw	r30, r16
    6c54:	60 81       	ld	r22, Z
    6c56:	c9 01       	movw	r24, r18
    6c58:	88 0f       	add	r24, r24
    6c5a:	99 1f       	adc	r25, r25
    6c5c:	ec 01       	movw	r28, r24
    6c5e:	cc 0f       	add	r28, r28
    6c60:	dd 1f       	adc	r29, r29
    6c62:	cc 0f       	add	r28, r28
    6c64:	dd 1f       	adc	r29, r29
    6c66:	cc 0f       	add	r28, r28
    6c68:	dd 1f       	adc	r29, r29
    6c6a:	c8 1b       	sub	r28, r24
    6c6c:	d9 0b       	sbc	r29, r25
    6c6e:	ce 01       	movw	r24, r28
    6c70:	8b 59       	subi	r24, 0x9B	; 155
    6c72:	9f 4f       	sbci	r25, 0xFF	; 255
    6c74:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6c78:	f8 01       	movw	r30, r16
    6c7a:	61 81       	ldd	r22, Z+1	; 0x01
    6c7c:	ce 01       	movw	r24, r28
    6c7e:	8a 59       	subi	r24, 0x9A	; 154
    6c80:	9f 4f       	sbci	r25, 0xFF	; 255
    6c82:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6c86:	f8 01       	movw	r30, r16
    6c88:	62 81       	ldd	r22, Z+2	; 0x02
    6c8a:	ce 01       	movw	r24, r28
    6c8c:	89 59       	subi	r24, 0x99	; 153
    6c8e:	9f 4f       	sbci	r25, 0xFF	; 255
    6c90:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6c94:	f8 01       	movw	r30, r16
    6c96:	63 81       	ldd	r22, Z+3	; 0x03
    6c98:	ce 01       	movw	r24, r28
    6c9a:	88 59       	subi	r24, 0x98	; 152
    6c9c:	9f 4f       	sbci	r25, 0xFF	; 255
    6c9e:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6ca2:	f8 01       	movw	r30, r16
    6ca4:	64 81       	ldd	r22, Z+4	; 0x04
    6ca6:	ce 01       	movw	r24, r28
    6ca8:	87 59       	subi	r24, 0x97	; 151
    6caa:	9f 4f       	sbci	r25, 0xFF	; 255
    6cac:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6cb0:	f8 01       	movw	r30, r16
    6cb2:	65 81       	ldd	r22, Z+5	; 0x05
    6cb4:	ce 01       	movw	r24, r28
    6cb6:	86 59       	subi	r24, 0x96	; 150
    6cb8:	9f 4f       	sbci	r25, 0xFF	; 255
    6cba:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6cbe:	f8 01       	movw	r30, r16
    6cc0:	66 81       	ldd	r22, Z+6	; 0x06
    6cc2:	ce 01       	movw	r24, r28
    6cc4:	85 59       	subi	r24, 0x95	; 149
    6cc6:	9f 4f       	sbci	r25, 0xFF	; 255
    6cc8:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6ccc:	f8 01       	movw	r30, r16
    6cce:	67 81       	ldd	r22, Z+7	; 0x07
    6cd0:	ce 01       	movw	r24, r28
    6cd2:	84 59       	subi	r24, 0x94	; 148
    6cd4:	9f 4f       	sbci	r25, 0xFF	; 255
    6cd6:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6cda:	f8 01       	movw	r30, r16
    6cdc:	60 85       	ldd	r22, Z+8	; 0x08
    6cde:	ce 01       	movw	r24, r28
    6ce0:	83 59       	subi	r24, 0x93	; 147
    6ce2:	9f 4f       	sbci	r25, 0xFF	; 255
    6ce4:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6ce8:	f8 01       	movw	r30, r16
    6cea:	61 85       	ldd	r22, Z+9	; 0x09
    6cec:	ce 01       	movw	r24, r28
    6cee:	82 59       	subi	r24, 0x92	; 146
    6cf0:	9f 4f       	sbci	r25, 0xFF	; 255
    6cf2:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6cf6:	f8 01       	movw	r30, r16
    6cf8:	62 85       	ldd	r22, Z+10	; 0x0a
    6cfa:	ce 01       	movw	r24, r28
    6cfc:	81 59       	subi	r24, 0x91	; 145
    6cfe:	9f 4f       	sbci	r25, 0xFF	; 255
    6d00:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6d04:	f8 01       	movw	r30, r16
    6d06:	63 85       	ldd	r22, Z+11	; 0x0b
    6d08:	ce 01       	movw	r24, r28
    6d0a:	80 59       	subi	r24, 0x90	; 144
    6d0c:	9f 4f       	sbci	r25, 0xFF	; 255
    6d0e:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6d12:	f8 01       	movw	r30, r16
    6d14:	64 85       	ldd	r22, Z+12	; 0x0c
    6d16:	ce 01       	movw	r24, r28
    6d18:	8f 58       	subi	r24, 0x8F	; 143
    6d1a:	9f 4f       	sbci	r25, 0xFF	; 255
    6d1c:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6d20:	f8 01       	movw	r30, r16
    6d22:	65 85       	ldd	r22, Z+13	; 0x0d
    6d24:	ce 01       	movw	r24, r28
    6d26:	8e 58       	subi	r24, 0x8E	; 142
    6d28:	9f 4f       	sbci	r25, 0xFF	; 255
    6d2a:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
    6d2e:	df 91       	pop	r29
    6d30:	cf 91       	pop	r28
    6d32:	1f 91       	pop	r17
    6d34:	0f 91       	pop	r16
    6d36:	08 95       	ret

00006d38 <NUM_SENSOR_SAVE>:
	
}

void NUM_SENSOR_SAVE()
{
	writeeeprom(MY_EEPROM_NUMBER_OF_SENSORS,NUMBER_OF_SENSORS);
    6d38:	60 91 56 0c 	lds	r22, 0x0C56
    6d3c:	84 e6       	ldi	r24, 0x64	; 100
    6d3e:	90 e0       	ldi	r25, 0x00	; 0
    6d40:	0c 94 48 1c 	jmp	0x3890	; 0x3890 <writeeeprom>
    6d44:	08 95       	ret

00006d46 <FIND_SENSOR>:
}

char FIND_SENSOR(unsigned char* ADDRESS,unsigned char ADDRESS_LENGTH)/*RETURN INDEX OR -1*/
{
    6d46:	df 92       	push	r13
    6d48:	ef 92       	push	r14
    6d4a:	ff 92       	push	r15
    6d4c:	0f 93       	push	r16
    6d4e:	1f 93       	push	r17
    6d50:	cf 93       	push	r28
    6d52:	df 93       	push	r29
	char index=0,counter_address,miss_match=0;
	if (NUMBER_OF_SENSORS==0)/*ARRAY IS EMPTY*/
    6d54:	20 91 56 0c 	lds	r18, 0x0C56
    6d58:	22 23       	and	r18, r18
    6d5a:	09 f4       	brne	.+2      	; 0x6d5e <FIND_SENSOR+0x18>
    6d5c:	42 c0       	rjmp	.+132    	; 0x6de2 <FIND_SENSOR+0x9c>
    6d5e:	40 e0       	ldi	r20, 0x00	; 0
    6d60:	50 e0       	ldi	r21, 0x00	; 0
		return -1;
	}
	
	for (index=0;index<NUMBER_OF_SENSORS_IN_DATA_BASE;++index)
	{
		if (MY_SENSORS[(unsigned char)index].SENSOR_OCCUBIED==1)
    6d62:	79 e1       	ldi	r23, 0x19	; 25
    6d64:	8c 01       	movw	r16, r24
    6d66:	0f 5f       	subi	r16, 0xFF	; 255
    6d68:	1f 4f       	sbci	r17, 0xFF	; 255
		{
			miss_match=0;
			for (counter_address=0;counter_address<ADDRESS_LENGTH;++counter_address)
			{
				if (MY_SENSORS[(unsigned char)index].SENSOR_ADDRESS[(unsigned char)counter_address]!=ADDRESS[(unsigned char)counter_address])
    6d6a:	dd 24       	eor	r13, r13
    6d6c:	d3 94       	inc	r13
    6d6e:	e1 2c       	mov	r14, r1
    6d70:	f4 2e       	mov	r15, r20
		return -1;
	}
	
	for (index=0;index<NUMBER_OF_SENSORS_IN_DATA_BASE;++index)
	{
		if (MY_SENSORS[(unsigned char)index].SENSOR_OCCUBIED==1)
    6d72:	da 01       	movw	r26, r20
    6d74:	74 9f       	mul	r23, r20
    6d76:	f0 01       	movw	r30, r0
    6d78:	75 9f       	mul	r23, r21
    6d7a:	f0 0d       	add	r31, r0
    6d7c:	11 24       	eor	r1, r1
    6d7e:	ed 5e       	subi	r30, 0xED	; 237
    6d80:	f2 4f       	sbci	r31, 0xF2	; 242
    6d82:	25 85       	ldd	r18, Z+13	; 0x0d
    6d84:	21 30       	cpi	r18, 0x01	; 1
    6d86:	39 f5       	brne	.+78     	; 0x6dd6 <FIND_SENSOR+0x90>
		{
			miss_match=0;
			for (counter_address=0;counter_address<ADDRESS_LENGTH;++counter_address)
    6d88:	66 23       	and	r22, r22
    6d8a:	69 f1       	breq	.+90     	; 0x6de6 <FIND_SENSOR+0xa0>
			{
				if (MY_SENSORS[(unsigned char)index].SENSOR_ADDRESS[(unsigned char)counter_address]!=ADDRESS[(unsigned char)counter_address])
    6d8c:	7a 9f       	mul	r23, r26
    6d8e:	f0 01       	movw	r30, r0
    6d90:	7b 9f       	mul	r23, r27
    6d92:	f0 0d       	add	r31, r0
    6d94:	11 24       	eor	r1, r1
    6d96:	ed 5e       	subi	r30, 0xED	; 237
    6d98:	f2 4f       	sbci	r31, 0xF2	; 242
    6d9a:	31 81       	ldd	r19, Z+1	; 0x01
    6d9c:	fc 01       	movw	r30, r24
    6d9e:	20 81       	ld	r18, Z
    6da0:	32 13       	cpse	r19, r18
    6da2:	19 c0       	rjmp	.+50     	; 0x6dd6 <FIND_SENSOR+0x90>
    6da4:	f8 01       	movw	r30, r16
    6da6:	2d 2d       	mov	r18, r13
    6da8:	3e 2d       	mov	r19, r14
    6daa:	7a 9f       	mul	r23, r26
    6dac:	e0 01       	movw	r28, r0
    6dae:	7b 9f       	mul	r23, r27
    6db0:	d0 0d       	add	r29, r0
    6db2:	11 24       	eor	r1, r1
    6db4:	cd 5e       	subi	r28, 0xED	; 237
    6db6:	d2 4f       	sbci	r29, 0xF2	; 242
    6db8:	0a c0       	rjmp	.+20     	; 0x6dce <FIND_SENSOR+0x88>
    6dba:	de 01       	movw	r26, r28
    6dbc:	a2 0f       	add	r26, r18
    6dbe:	b3 1f       	adc	r27, r19
    6dc0:	11 96       	adiw	r26, 0x01	; 1
    6dc2:	bc 91       	ld	r27, X
    6dc4:	a1 91       	ld	r26, Z+
    6dc6:	2f 5f       	subi	r18, 0xFF	; 255
    6dc8:	3f 4f       	sbci	r19, 0xFF	; 255
    6dca:	ba 13       	cpse	r27, r26
    6dcc:	04 c0       	rjmp	.+8      	; 0x6dd6 <FIND_SENSOR+0x90>
	for (index=0;index<NUMBER_OF_SENSORS_IN_DATA_BASE;++index)
	{
		if (MY_SENSORS[(unsigned char)index].SENSOR_OCCUBIED==1)
		{
			miss_match=0;
			for (counter_address=0;counter_address<ADDRESS_LENGTH;++counter_address)
    6dce:	26 17       	cp	r18, r22
    6dd0:	a0 f3       	brcs	.-24     	; 0x6dba <FIND_SENSOR+0x74>
    6dd2:	8f 2d       	mov	r24, r15
    6dd4:	0b c0       	rjmp	.+22     	; 0x6dec <FIND_SENSOR+0xa6>
    6dd6:	4f 5f       	subi	r20, 0xFF	; 255
    6dd8:	5f 4f       	sbci	r21, 0xFF	; 255
	if (NUMBER_OF_SENSORS==0)/*ARRAY IS EMPTY*/
	{
		return -1;
	}
	
	for (index=0;index<NUMBER_OF_SENSORS_IN_DATA_BASE;++index)
    6dda:	4a 30       	cpi	r20, 0x0A	; 10
    6ddc:	51 05       	cpc	r21, r1
    6dde:	41 f6       	brne	.-112    	; 0x6d70 <FIND_SENSOR+0x2a>
    6de0:	04 c0       	rjmp	.+8      	; 0x6dea <FIND_SENSOR+0xa4>
char FIND_SENSOR(unsigned char* ADDRESS,unsigned char ADDRESS_LENGTH)/*RETURN INDEX OR -1*/
{
	char index=0,counter_address,miss_match=0;
	if (NUMBER_OF_SENSORS==0)/*ARRAY IS EMPTY*/
	{
		return -1;
    6de2:	8f ef       	ldi	r24, 0xFF	; 255
    6de4:	03 c0       	rjmp	.+6      	; 0x6dec <FIND_SENSOR+0xa6>
	for (index=0;index<NUMBER_OF_SENSORS_IN_DATA_BASE;++index)
	{
		if (MY_SENSORS[(unsigned char)index].SENSOR_OCCUBIED==1)
		{
			miss_match=0;
			for (counter_address=0;counter_address<ADDRESS_LENGTH;++counter_address)
    6de6:	84 2f       	mov	r24, r20
    6de8:	01 c0       	rjmp	.+2      	; 0x6dec <FIND_SENSOR+0xa6>
			{
				return index;
			}
		}
	}	
	return -1;
    6dea:	8f ef       	ldi	r24, 0xFF	; 255
	
}
    6dec:	df 91       	pop	r29
    6dee:	cf 91       	pop	r28
    6df0:	1f 91       	pop	r17
    6df2:	0f 91       	pop	r16
    6df4:	ff 90       	pop	r15
    6df6:	ef 90       	pop	r14
    6df8:	df 90       	pop	r13
    6dfa:	08 95       	ret

00006dfc <SENSORS_FILL_SENSOR_BUFFERS>:
		}
	}
}

void SENSORS_FILL_SENSOR_BUFFERS()
{
    6dfc:	2f 92       	push	r2
    6dfe:	3f 92       	push	r3
    6e00:	4f 92       	push	r4
    6e02:	5f 92       	push	r5
    6e04:	6f 92       	push	r6
    6e06:	7f 92       	push	r7
    6e08:	8f 92       	push	r8
    6e0a:	9f 92       	push	r9
    6e0c:	af 92       	push	r10
    6e0e:	bf 92       	push	r11
    6e10:	cf 92       	push	r12
    6e12:	df 92       	push	r13
    6e14:	ef 92       	push	r14
    6e16:	ff 92       	push	r15
    6e18:	0f 93       	push	r16
    6e1a:	1f 93       	push	r17
    6e1c:	cf 93       	push	r28
    6e1e:	df 93       	push	r29
    6e20:	cd b7       	in	r28, 0x3d	; 61
    6e22:	de b7       	in	r29, 0x3e	; 62
    6e24:	69 97       	sbiw	r28, 0x19	; 25
    6e26:	0f b6       	in	r0, 0x3f	; 63
    6e28:	f8 94       	cli
    6e2a:	de bf       	out	0x3e, r29	; 62
    6e2c:	0f be       	out	0x3f, r0	; 63
    6e2e:	cd bf       	out	0x3d, r28	; 61
	
	if(F_LAST_RECIVED_DATA_NOT_HANDLED)   /*MAKE SENSOR WORK ON IT*/
    6e30:	80 91 c6 10 	lds	r24, 0x10C6
    6e34:	88 23       	and	r24, r24
    6e36:	09 f4       	brne	.+2      	; 0x6e3a <SENSORS_FILL_SENSOR_BUFFERS+0x3e>
    6e38:	61 c2       	rjmp	.+1218   	; 0x72fc <SENSORS_FILL_SENSOR_BUFFERS+0x500>
	{
		
		if (FIRST_READ_FLAG)
    6e3a:	80 91 13 01 	lds	r24, 0x0113
    6e3e:	88 23       	and	r24, r24
    6e40:	91 f0       	breq	.+36     	; 0x6e66 <SENSORS_FILL_SENSOR_BUFFERS+0x6a>
		{
			OLD_LAST_ENTRY=NEW_LAST_ENTRY;
    6e42:	80 91 b3 0c 	lds	r24, 0x0CB3
    6e46:	90 91 b4 0c 	lds	r25, 0x0CB4
    6e4a:	a0 91 b5 0c 	lds	r26, 0x0CB5
    6e4e:	b0 91 b6 0c 	lds	r27, 0x0CB6
    6e52:	80 93 2d 0e 	sts	0x0E2D, r24
    6e56:	90 93 2e 0e 	sts	0x0E2E, r25
    6e5a:	a0 93 2f 0e 	sts	0x0E2F, r26
    6e5e:	b0 93 30 0e 	sts	0x0E30, r27
			FIRST_READ_FLAG=0;
    6e62:	10 92 13 01 	sts	0x0113, r1
		}
		
		if (OLD_LAST_ENTRY<NEW_LAST_ENTRY)
    6e66:	40 91 2d 0e 	lds	r20, 0x0E2D
    6e6a:	50 91 2e 0e 	lds	r21, 0x0E2E
    6e6e:	60 91 2f 0e 	lds	r22, 0x0E2F
    6e72:	70 91 30 0e 	lds	r23, 0x0E30
    6e76:	80 91 b3 0c 	lds	r24, 0x0CB3
    6e7a:	90 91 b4 0c 	lds	r25, 0x0CB4
    6e7e:	a0 91 b5 0c 	lds	r26, 0x0CB5
    6e82:	b0 91 b6 0c 	lds	r27, 0x0CB6
    6e86:	48 17       	cp	r20, r24
    6e88:	59 07       	cpc	r21, r25
    6e8a:	6a 07       	cpc	r22, r26
    6e8c:	7b 07       	cpc	r23, r27
    6e8e:	08 f0       	brcs	.+2      	; 0x6e92 <SENSORS_FILL_SENSOR_BUFFERS+0x96>
    6e90:	33 c2       	rjmp	.+1126   	; 0x72f8 <SENSORS_FILL_SENSOR_BUFFERS+0x4fc>
		{
			unsigned long TEMP_DIFF=NEW_LAST_ENTRY-OLD_LAST_ENTRY;
    6e92:	c0 90 b3 0c 	lds	r12, 0x0CB3
    6e96:	d0 90 b4 0c 	lds	r13, 0x0CB4
    6e9a:	e0 90 b5 0c 	lds	r14, 0x0CB5
    6e9e:	f0 90 b6 0c 	lds	r15, 0x0CB6
    6ea2:	40 91 2d 0e 	lds	r20, 0x0E2D
    6ea6:	50 91 2e 0e 	lds	r21, 0x0E2E
    6eaa:	60 91 2f 0e 	lds	r22, 0x0E2F
    6eae:	70 91 30 0e 	lds	r23, 0x0E30
    6eb2:	c4 1a       	sub	r12, r20
    6eb4:	d5 0a       	sbc	r13, r21
    6eb6:	e6 0a       	sbc	r14, r22
    6eb8:	f7 0a       	sbc	r15, r23
			OLD_LAST_ENTRY=NEW_LAST_ENTRY;
    6eba:	80 91 b3 0c 	lds	r24, 0x0CB3
    6ebe:	90 91 b4 0c 	lds	r25, 0x0CB4
    6ec2:	a0 91 b5 0c 	lds	r26, 0x0CB5
    6ec6:	b0 91 b6 0c 	lds	r27, 0x0CB6
    6eca:	80 93 2d 0e 	sts	0x0E2D, r24
    6ece:	90 93 2e 0e 	sts	0x0E2E, r25
    6ed2:	a0 93 2f 0e 	sts	0x0E2F, r26
    6ed6:	b0 93 30 0e 	sts	0x0E30, r27
			SAVE_OLD_LAST_ENTRY();
    6eda:	1f de       	rcall	.-962    	; 0x6b1a <SAVE_OLD_LAST_ENTRY>
    6edc:	d7 01       	movw	r26, r14
    6ede:	c6 01       	movw	r24, r12
    6ee0:	86 30       	cpi	r24, 0x06	; 6
    6ee2:	91 05       	cpc	r25, r1
    6ee4:	a1 05       	cpc	r26, r1
    6ee6:	b1 05       	cpc	r27, r1
    6ee8:	20 f0       	brcs	.+8      	; 0x6ef2 <SENSORS_FILL_SENSOR_BUFFERS+0xf6>
    6eea:	85 e0       	ldi	r24, 0x05	; 5
    6eec:	90 e0       	ldi	r25, 0x00	; 0
    6eee:	a0 e0       	ldi	r26, 0x00	; 0
    6ef0:	b0 e0       	ldi	r27, 0x00	; 0
			unsigned char i=0,k=0,J=0;
			unsigned char NUMBER_STRING_BUFFER[20];
			unsigned long long NUMBER_BUFFER=0;
			/*M:ADDRESS SENSOR(decimal):COMMAND(W or R):DATA1:DATA2:*/
			/*M:ADDRESS SENSOR:COMMAND:DATA1:*/
			for (i=5-TEMP_DIFF;i<5;++i)
    6ef2:	15 e0       	ldi	r17, 0x05	; 5
    6ef4:	18 1b       	sub	r17, r24
    6ef6:	15 30       	cpi	r17, 0x05	; 5
    6ef8:	08 f0       	brcs	.+2      	; 0x6efc <SENSORS_FILL_SENSOR_BUFFERS+0x100>
    6efa:	00 c2       	rjmp	.+1024   	; 0x72fc <SENSORS_FILL_SENSOR_BUFFERS+0x500>
			{	
				if (G_RECIVED_DATA[i].DATA_ELEMENT[0]=='M')/*MEANS THAT ANDROID SEND THIS TO MASTER*/
    6efc:	0f 2e       	mov	r0, r31
    6efe:	ff e1       	ldi	r31, 0x1F	; 31
    6f00:	af 2e       	mov	r10, r31
    6f02:	f0 2d       	mov	r31, r0
								
									if (G_RECIVED_DATA[i].DATA_ELEMENT[4+k]==':')
									{
										k=5+k;
										SENSOR_READ_BUFFER[SENSOR_READ_BUFFER_LENGTH].SENSOR_INDEX=SENSOR_INDEX_BUFFER;
										J=0;
    6f04:	91 2c       	mov	r9, r1
										/*ADDRESS REGISTER*/
										while(G_RECIVED_DATA[i].DATA_ELEMENT[k+J]!=':')
    6f06:	71 2c       	mov	r7, r1
    6f08:	81 2c       	mov	r8, r1
				{
					if (G_RECIVED_DATA[i].DATA_ELEMENT[1]==':')/*COTATION*/
					{
						k=0;
						/*ADDRESS SENSOR*/
						while(G_RECIVED_DATA[i].DATA_ELEMENT[2+k]!=':')/*COTATION*/
    6f0a:	61 2c       	mov	r6, r1
			unsigned long long NUMBER_BUFFER=0;
			/*M:ADDRESS SENSOR(decimal):COMMAND(W or R):DATA1:DATA2:*/
			/*M:ADDRESS SENSOR:COMMAND:DATA1:*/
			for (i=5-TEMP_DIFF;i<5;++i)
			{	
				if (G_RECIVED_DATA[i].DATA_ELEMENT[0]=='M')/*MEANS THAT ANDROID SEND THIS TO MASTER*/
    6f0c:	c1 2e       	mov	r12, r17
    6f0e:	d1 2c       	mov	r13, r1
    6f10:	ac 9c       	mul	r10, r12
    6f12:	f0 01       	movw	r30, r0
    6f14:	ad 9c       	mul	r10, r13
    6f16:	f0 0d       	add	r31, r0
    6f18:	11 24       	eor	r1, r1
    6f1a:	eb 58       	subi	r30, 0x8B	; 139
    6f1c:	f1 4f       	sbci	r31, 0xF1	; 241
    6f1e:	80 81       	ld	r24, Z
    6f20:	8d 34       	cpi	r24, 0x4D	; 77
    6f22:	09 f0       	breq	.+2      	; 0x6f26 <SENSORS_FILL_SENSOR_BUFFERS+0x12a>
    6f24:	e4 c1       	rjmp	.+968    	; 0x72ee <SENSORS_FILL_SENSOR_BUFFERS+0x4f2>
				{
					if (G_RECIVED_DATA[i].DATA_ELEMENT[1]==':')/*COTATION*/
    6f26:	ac 9c       	mul	r10, r12
    6f28:	f0 01       	movw	r30, r0
    6f2a:	ad 9c       	mul	r10, r13
    6f2c:	f0 0d       	add	r31, r0
    6f2e:	11 24       	eor	r1, r1
    6f30:	eb 58       	subi	r30, 0x8B	; 139
    6f32:	f1 4f       	sbci	r31, 0xF1	; 241
    6f34:	81 81       	ldd	r24, Z+1	; 0x01
    6f36:	8a 33       	cpi	r24, 0x3A	; 58
    6f38:	09 f0       	breq	.+2      	; 0x6f3c <SENSORS_FILL_SENSOR_BUFFERS+0x140>
    6f3a:	d9 c1       	rjmp	.+946    	; 0x72ee <SENSORS_FILL_SENSOR_BUFFERS+0x4f2>
					{
						k=0;
						/*ADDRESS SENSOR*/
						while(G_RECIVED_DATA[i].DATA_ELEMENT[2+k]!=':')/*COTATION*/
    6f3c:	ac 9c       	mul	r10, r12
    6f3e:	f0 01       	movw	r30, r0
    6f40:	ad 9c       	mul	r10, r13
    6f42:	f0 0d       	add	r31, r0
    6f44:	11 24       	eor	r1, r1
    6f46:	eb 58       	subi	r30, 0x8B	; 139
    6f48:	f1 4f       	sbci	r31, 0xF1	; 241
    6f4a:	82 81       	ldd	r24, Z+2	; 0x02
    6f4c:	8a 33       	cpi	r24, 0x3A	; 58
    6f4e:	29 f1       	breq	.+74     	; 0x6f9a <SENSORS_FILL_SENSOR_BUFFERS+0x19e>
    6f50:	82 e0       	ldi	r24, 0x02	; 2
    6f52:	96 2d       	mov	r25, r6
    6f54:	e7 2c       	mov	r14, r7
    6f56:	f8 2c       	mov	r15, r8
    6f58:	b9 2c       	mov	r11, r9
						{
							NUMBER_STRING_BUFFER[k]=G_RECIVED_DATA[i].DATA_ELEMENT[2+k];
    6f5a:	ac 9c       	mul	r10, r12
    6f5c:	90 01       	movw	r18, r0
    6f5e:	ad 9c       	mul	r10, r13
    6f60:	30 0d       	add	r19, r0
    6f62:	11 24       	eor	r1, r1
    6f64:	82 0f       	add	r24, r18
    6f66:	93 1f       	adc	r25, r19
    6f68:	fc 01       	movw	r30, r24
    6f6a:	eb 58       	subi	r30, 0x8B	; 139
    6f6c:	f1 4f       	sbci	r31, 0xF1	; 241
    6f6e:	80 81       	ld	r24, Z
    6f70:	e1 e0       	ldi	r30, 0x01	; 1
    6f72:	f0 e0       	ldi	r31, 0x00	; 0
    6f74:	ec 0f       	add	r30, r28
    6f76:	fd 1f       	adc	r31, r29
    6f78:	ee 0d       	add	r30, r14
    6f7a:	ff 1d       	adc	r31, r15
    6f7c:	80 83       	st	Z, r24
							k++;
    6f7e:	b3 94       	inc	r11
				{
					if (G_RECIVED_DATA[i].DATA_ELEMENT[1]==':')/*COTATION*/
					{
						k=0;
						/*ADDRESS SENSOR*/
						while(G_RECIVED_DATA[i].DATA_ELEMENT[2+k]!=':')/*COTATION*/
    6f80:	eb 2c       	mov	r14, r11
    6f82:	f1 2c       	mov	r15, r1
    6f84:	c7 01       	movw	r24, r14
    6f86:	02 96       	adiw	r24, 0x02	; 2
    6f88:	f9 01       	movw	r30, r18
    6f8a:	e8 0f       	add	r30, r24
    6f8c:	f9 1f       	adc	r31, r25
    6f8e:	eb 58       	subi	r30, 0x8B	; 139
    6f90:	f1 4f       	sbci	r31, 0xF1	; 241
    6f92:	40 81       	ld	r20, Z
    6f94:	4a 33       	cpi	r20, 0x3A	; 58
    6f96:	31 f7       	brne	.-52     	; 0x6f64 <SENSORS_FILL_SENSOR_BUFFERS+0x168>
    6f98:	03 c0       	rjmp	.+6      	; 0x6fa0 <SENSORS_FILL_SENSOR_BUFFERS+0x1a4>
    6f9a:	e7 2c       	mov	r14, r7
    6f9c:	f8 2c       	mov	r15, r8
    6f9e:	b9 2c       	mov	r11, r9
						{
							NUMBER_STRING_BUFFER[k]=G_RECIVED_DATA[i].DATA_ELEMENT[2+k];
							k++;
							
						}
						NUMBER_BUFFER=STRINGTOINT(NUMBER_STRING_BUFFER,k);
    6fa0:	6b 2d       	mov	r22, r11
    6fa2:	ce 01       	movw	r24, r28
    6fa4:	01 96       	adiw	r24, 0x01	; 1
    6fa6:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <STRINGTOINT>
    6faa:	e2 2f       	mov	r30, r18
    6fac:	23 2e       	mov	r2, r19
    6fae:	34 2e       	mov	r3, r20
    6fb0:	45 2e       	mov	r4, r21
    6fb2:	56 2e       	mov	r5, r22
    6fb4:	b7 2f       	mov	r27, r23
    6fb6:	a8 2f       	mov	r26, r24
    6fb8:	f9 2f       	mov	r31, r25
						
							unsigned char ARRAY_BUFFER[5];
							ARRAY_BUFFER[0]=NUMBER_BUFFER&0XFF;
    6fba:	2d 8b       	std	Y+21, r18	; 0x15
							ARRAY_BUFFER[1]=(NUMBER_BUFFER>>8)&0XFF;
    6fbc:	08 e0       	ldi	r16, 0x08	; 8
    6fbe:	0e 94 d4 42 	call	0x85a8	; 0x85a8 <__lshrdi3>
    6fc2:	2e 8b       	std	Y+22, r18	; 0x16
							ARRAY_BUFFER[2]=(NUMBER_BUFFER>>16)&0XFF;
    6fc4:	2e 2f       	mov	r18, r30
    6fc6:	32 2d       	mov	r19, r2
    6fc8:	43 2d       	mov	r20, r3
    6fca:	54 2d       	mov	r21, r4
    6fcc:	65 2d       	mov	r22, r5
    6fce:	7b 2f       	mov	r23, r27
    6fd0:	8a 2f       	mov	r24, r26
    6fd2:	9f 2f       	mov	r25, r31
    6fd4:	00 e1       	ldi	r16, 0x10	; 16
    6fd6:	0e 94 d4 42 	call	0x85a8	; 0x85a8 <__lshrdi3>
    6fda:	2f 8b       	std	Y+23, r18	; 0x17
							ARRAY_BUFFER[3]=(NUMBER_BUFFER>>24)&0XFF;
    6fdc:	2e 2f       	mov	r18, r30
    6fde:	32 2d       	mov	r19, r2
    6fe0:	43 2d       	mov	r20, r3
    6fe2:	54 2d       	mov	r21, r4
    6fe4:	65 2d       	mov	r22, r5
    6fe6:	7b 2f       	mov	r23, r27
    6fe8:	8a 2f       	mov	r24, r26
    6fea:	9f 2f       	mov	r25, r31
    6fec:	08 e1       	ldi	r16, 0x18	; 24
    6fee:	0e 94 d4 42 	call	0x85a8	; 0x85a8 <__lshrdi3>
    6ff2:	28 8f       	std	Y+24, r18	; 0x18
							ARRAY_BUFFER[4]=(NUMBER_BUFFER>>32)&0XFF;
    6ff4:	2e 2f       	mov	r18, r30
    6ff6:	32 2d       	mov	r19, r2
    6ff8:	43 2d       	mov	r20, r3
    6ffa:	54 2d       	mov	r21, r4
    6ffc:	65 2d       	mov	r22, r5
    6ffe:	7b 2f       	mov	r23, r27
    7000:	8a 2f       	mov	r24, r26
    7002:	9f 2f       	mov	r25, r31
    7004:	00 e2       	ldi	r16, 0x20	; 32
    7006:	0e 94 d4 42 	call	0x85a8	; 0x85a8 <__lshrdi3>
    700a:	29 8f       	std	Y+25, r18	; 0x19
						char SENSOR_INDEX_BUFFER=FIND_SENSOR(ARRAY_BUFFER,5);
    700c:	65 e0       	ldi	r22, 0x05	; 5
    700e:	ce 01       	movw	r24, r28
    7010:	45 96       	adiw	r24, 0x15	; 21
    7012:	99 de       	rcall	.-718    	; 0x6d46 <FIND_SENSOR>
						if (SENSOR_INDEX_BUFFER!=(char)(-1))
    7014:	8f 3f       	cpi	r24, 0xFF	; 255
    7016:	09 f4       	brne	.+2      	; 0x701a <SENSORS_FILL_SENSOR_BUFFERS+0x21e>
    7018:	6a c1       	rjmp	.+724    	; 0x72ee <SENSORS_FILL_SENSOR_BUFFERS+0x4f2>
						{
							
					
						
						
						if(G_RECIVED_DATA[i].DATA_ELEMENT[3+k]=='W')/*MEANS ANDROID NEED TO CHANGE DATA*/
    701a:	97 01       	movw	r18, r14
    701c:	2d 5f       	subi	r18, 0xFD	; 253
    701e:	3f 4f       	sbci	r19, 0xFF	; 255
    7020:	ac 9c       	mul	r10, r12
    7022:	f0 01       	movw	r30, r0
    7024:	ad 9c       	mul	r10, r13
    7026:	f0 0d       	add	r31, r0
    7028:	11 24       	eor	r1, r1
    702a:	e2 0f       	add	r30, r18
    702c:	f3 1f       	adc	r31, r19
    702e:	eb 58       	subi	r30, 0x8B	; 139
    7030:	f1 4f       	sbci	r31, 0xF1	; 241
    7032:	90 81       	ld	r25, Z
    7034:	97 35       	cpi	r25, 0x57	; 87
    7036:	09 f0       	breq	.+2      	; 0x703a <SENSORS_FILL_SENSOR_BUFFERS+0x23e>
    7038:	d4 c0       	rjmp	.+424    	; 0x71e2 <SENSORS_FILL_SENSOR_BUFFERS+0x3e6>
						{
							if (G_RECIVED_DATA[i].DATA_ELEMENT[4+k]==':')/*COTATION*/
    703a:	ac 9c       	mul	r10, r12
    703c:	f0 01       	movw	r30, r0
    703e:	ad 9c       	mul	r10, r13
    7040:	f0 0d       	add	r31, r0
    7042:	11 24       	eor	r1, r1
    7044:	ee 0d       	add	r30, r14
    7046:	ff 1d       	adc	r31, r15
    7048:	e7 58       	subi	r30, 0x87	; 135
    704a:	f1 4f       	sbci	r31, 0xF1	; 241
    704c:	90 81       	ld	r25, Z
    704e:	9a 33       	cpi	r25, 0x3A	; 58
    7050:	09 f0       	breq	.+2      	; 0x7054 <SENSORS_FILL_SENSOR_BUFFERS+0x258>
    7052:	4d c1       	rjmp	.+666    	; 0x72ee <SENSORS_FILL_SENSOR_BUFFERS+0x4f2>
							{
								k=5+k;
								
								
								SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].SENSOR_INDEX=SENSOR_INDEX_BUFFER;
    7054:	20 91 51 0c 	lds	r18, 0x0C51
    7058:	30 e0       	ldi	r19, 0x00	; 0
    705a:	f9 01       	movw	r30, r18
    705c:	ee 0f       	add	r30, r30
    705e:	ff 1f       	adc	r31, r31
    7060:	ee 0f       	add	r30, r30
    7062:	ff 1f       	adc	r31, r31
    7064:	2e 0f       	add	r18, r30
    7066:	3f 1f       	adc	r19, r31
    7068:	f9 01       	movw	r30, r18
    706a:	e0 52       	subi	r30, 0x20	; 32
    706c:	f3 4f       	sbci	r31, 0xF3	; 243
    706e:	80 83       	st	Z, r24
						
						if(G_RECIVED_DATA[i].DATA_ELEMENT[3+k]=='W')/*MEANS ANDROID NEED TO CHANGE DATA*/
						{
							if (G_RECIVED_DATA[i].DATA_ELEMENT[4+k]==':')/*COTATION*/
							{
								k=5+k;
    7070:	65 e0       	ldi	r22, 0x05	; 5
    7072:	6b 0d       	add	r22, r11
								
								SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].SENSOR_INDEX=SENSOR_INDEX_BUFFER;
								
									J=0;
									/*ADDRESS REGISTER*/
									while(G_RECIVED_DATA[i].DATA_ELEMENT[k+J]!=':')/*COTATION*/
    7074:	70 e0       	ldi	r23, 0x00	; 0
    7076:	ac 9c       	mul	r10, r12
    7078:	f0 01       	movw	r30, r0
    707a:	ad 9c       	mul	r10, r13
    707c:	f0 0d       	add	r31, r0
    707e:	11 24       	eor	r1, r1
    7080:	e6 0f       	add	r30, r22
    7082:	f7 1f       	adc	r31, r23
    7084:	eb 58       	subi	r30, 0x8B	; 139
    7086:	f1 4f       	sbci	r31, 0xF1	; 241
    7088:	80 81       	ld	r24, Z
    708a:	8a 33       	cpi	r24, 0x3A	; 58
    708c:	29 f1       	breq	.+74     	; 0x70d8 <SENSORS_FILL_SENSOR_BUFFERS+0x2dc>
    708e:	9b 01       	movw	r18, r22
    7090:	87 2d       	mov	r24, r7
    7092:	98 2d       	mov	r25, r8
								k=5+k;
								
								
								SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].SENSOR_INDEX=SENSOR_INDEX_BUFFER;
								
									J=0;
    7094:	f9 2c       	mov	r15, r9
									/*ADDRESS REGISTER*/
									while(G_RECIVED_DATA[i].DATA_ELEMENT[k+J]!=':')/*COTATION*/
									{
										NUMBER_STRING_BUFFER[J]=G_RECIVED_DATA[i].DATA_ELEMENT[J+k];
    7096:	ac 9c       	mul	r10, r12
    7098:	a0 01       	movw	r20, r0
    709a:	ad 9c       	mul	r10, r13
    709c:	50 0d       	add	r21, r0
    709e:	11 24       	eor	r1, r1
    70a0:	24 0f       	add	r18, r20
    70a2:	35 1f       	adc	r19, r21
    70a4:	f9 01       	movw	r30, r18
    70a6:	eb 58       	subi	r30, 0x8B	; 139
    70a8:	f1 4f       	sbci	r31, 0xF1	; 241
    70aa:	20 81       	ld	r18, Z
    70ac:	e1 e0       	ldi	r30, 0x01	; 1
    70ae:	f0 e0       	ldi	r31, 0x00	; 0
    70b0:	ec 0f       	add	r30, r28
    70b2:	fd 1f       	adc	r31, r29
    70b4:	e8 0f       	add	r30, r24
    70b6:	f9 1f       	adc	r31, r25
    70b8:	20 83       	st	Z, r18
										J++;
    70ba:	f3 94       	inc	r15
								
								SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].SENSOR_INDEX=SENSOR_INDEX_BUFFER;
								
									J=0;
									/*ADDRESS REGISTER*/
									while(G_RECIVED_DATA[i].DATA_ELEMENT[k+J]!=':')/*COTATION*/
    70bc:	8f 2d       	mov	r24, r15
    70be:	90 e0       	ldi	r25, 0x00	; 0
    70c0:	9c 01       	movw	r18, r24
    70c2:	26 0f       	add	r18, r22
    70c4:	37 1f       	adc	r19, r23
    70c6:	fa 01       	movw	r30, r20
    70c8:	e2 0f       	add	r30, r18
    70ca:	f3 1f       	adc	r31, r19
    70cc:	eb 58       	subi	r30, 0x8B	; 139
    70ce:	f1 4f       	sbci	r31, 0xF1	; 241
    70d0:	e0 81       	ld	r30, Z
    70d2:	ea 33       	cpi	r30, 0x3A	; 58
    70d4:	29 f7       	brne	.-54     	; 0x70a0 <SENSORS_FILL_SENSOR_BUFFERS+0x2a4>
    70d6:	01 c0       	rjmp	.+2      	; 0x70da <SENSORS_FILL_SENSOR_BUFFERS+0x2de>
								k=5+k;
								
								
								SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].SENSOR_INDEX=SENSOR_INDEX_BUFFER;
								
									J=0;
    70d8:	f9 2c       	mov	r15, r9
									{
										NUMBER_STRING_BUFFER[J]=G_RECIVED_DATA[i].DATA_ELEMENT[J+k];
										J++;
										
									}
									NUMBER_BUFFER=STRINGTOINT(NUMBER_STRING_BUFFER,J);
    70da:	6f 2d       	mov	r22, r15
    70dc:	ce 01       	movw	r24, r28
    70de:	01 96       	adiw	r24, 0x01	; 1
    70e0:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <STRINGTOINT>
    70e4:	a2 2f       	mov	r26, r18
									SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].ADDRESS_REGISTER[0]=NUMBER_BUFFER>>8;
    70e6:	e0 91 51 0c 	lds	r30, 0x0C51
    70ea:	f0 e0       	ldi	r31, 0x00	; 0
    70ec:	08 e0       	ldi	r16, 0x08	; 8
    70ee:	0e 94 d4 42 	call	0x85a8	; 0x85a8 <__lshrdi3>
    70f2:	cf 01       	movw	r24, r30
    70f4:	88 0f       	add	r24, r24
    70f6:	99 1f       	adc	r25, r25
    70f8:	88 0f       	add	r24, r24
    70fa:	99 1f       	adc	r25, r25
    70fc:	e8 0f       	add	r30, r24
    70fe:	f9 1f       	adc	r31, r25
    7100:	e0 52       	subi	r30, 0x20	; 32
    7102:	f3 4f       	sbci	r31, 0xF3	; 243
    7104:	21 83       	std	Z+1, r18	; 0x01
									SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].ADDRESS_REGISTER[1]=NUMBER_BUFFER;
    7106:	80 91 51 0c 	lds	r24, 0x0C51
    710a:	90 e0       	ldi	r25, 0x00	; 0
    710c:	fc 01       	movw	r30, r24
    710e:	ee 0f       	add	r30, r30
    7110:	ff 1f       	adc	r31, r31
    7112:	ee 0f       	add	r30, r30
    7114:	ff 1f       	adc	r31, r31
    7116:	8e 0f       	add	r24, r30
    7118:	9f 1f       	adc	r25, r31
    711a:	fc 01       	movw	r30, r24
    711c:	e0 52       	subi	r30, 0x20	; 32
    711e:	f3 4f       	sbci	r31, 0xF3	; 243
    7120:	a2 83       	std	Z+2, r26	; 0x02
									k=J+k+1;
    7122:	e6 e0       	ldi	r30, 0x06	; 6
    7124:	eb 0d       	add	r30, r11
    7126:	fe 0e       	add	r15, r30
									J=0;
									/*DATA VALUE*/
									while(G_RECIVED_DATA[i].DATA_ELEMENT[k+J]!=':')
    7128:	ef 2d       	mov	r30, r15
    712a:	f0 e0       	ldi	r31, 0x00	; 0
    712c:	ac 9c       	mul	r10, r12
    712e:	d0 01       	movw	r26, r0
    7130:	ad 9c       	mul	r10, r13
    7132:	b0 0d       	add	r27, r0
    7134:	11 24       	eor	r1, r1
    7136:	ae 0f       	add	r26, r30
    7138:	bf 1f       	adc	r27, r31
    713a:	ab 58       	subi	r26, 0x8B	; 139
    713c:	b1 4f       	sbci	r27, 0xF1	; 241
    713e:	8c 91       	ld	r24, X
    7140:	8a 33       	cpi	r24, 0x3A	; 58
    7142:	29 f1       	breq	.+74     	; 0x718e <SENSORS_FILL_SENSOR_BUFFERS+0x392>
    7144:	9f 01       	movw	r18, r30
    7146:	87 2d       	mov	r24, r7
    7148:	98 2d       	mov	r25, r8
									}
									NUMBER_BUFFER=STRINGTOINT(NUMBER_STRING_BUFFER,J);
									SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].ADDRESS_REGISTER[0]=NUMBER_BUFFER>>8;
									SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].ADDRESS_REGISTER[1]=NUMBER_BUFFER;
									k=J+k+1;
									J=0;
    714a:	69 2d       	mov	r22, r9
									/*DATA VALUE*/
									while(G_RECIVED_DATA[i].DATA_ELEMENT[k+J]!=':')
									{
										NUMBER_STRING_BUFFER[J]=G_RECIVED_DATA[i].DATA_ELEMENT[J+k];
    714c:	ac 9c       	mul	r10, r12
    714e:	a0 01       	movw	r20, r0
    7150:	ad 9c       	mul	r10, r13
    7152:	50 0d       	add	r21, r0
    7154:	11 24       	eor	r1, r1
    7156:	24 0f       	add	r18, r20
    7158:	35 1f       	adc	r19, r21
    715a:	d9 01       	movw	r26, r18
    715c:	ab 58       	subi	r26, 0x8B	; 139
    715e:	b1 4f       	sbci	r27, 0xF1	; 241
    7160:	2c 91       	ld	r18, X
    7162:	a1 e0       	ldi	r26, 0x01	; 1
    7164:	b0 e0       	ldi	r27, 0x00	; 0
    7166:	ac 0f       	add	r26, r28
    7168:	bd 1f       	adc	r27, r29
    716a:	a8 0f       	add	r26, r24
    716c:	b9 1f       	adc	r27, r25
    716e:	2c 93       	st	X, r18
										J++;
    7170:	6f 5f       	subi	r22, 0xFF	; 255
									SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].ADDRESS_REGISTER[0]=NUMBER_BUFFER>>8;
									SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].ADDRESS_REGISTER[1]=NUMBER_BUFFER;
									k=J+k+1;
									J=0;
									/*DATA VALUE*/
									while(G_RECIVED_DATA[i].DATA_ELEMENT[k+J]!=':')
    7172:	86 2f       	mov	r24, r22
    7174:	90 e0       	ldi	r25, 0x00	; 0
    7176:	9c 01       	movw	r18, r24
    7178:	2e 0f       	add	r18, r30
    717a:	3f 1f       	adc	r19, r31
    717c:	da 01       	movw	r26, r20
    717e:	a2 0f       	add	r26, r18
    7180:	b3 1f       	adc	r27, r19
    7182:	ab 58       	subi	r26, 0x8B	; 139
    7184:	b1 4f       	sbci	r27, 0xF1	; 241
    7186:	7c 91       	ld	r23, X
    7188:	7a 33       	cpi	r23, 0x3A	; 58
    718a:	29 f7       	brne	.-54     	; 0x7156 <SENSORS_FILL_SENSOR_BUFFERS+0x35a>
    718c:	01 c0       	rjmp	.+2      	; 0x7190 <SENSORS_FILL_SENSOR_BUFFERS+0x394>
									}
									NUMBER_BUFFER=STRINGTOINT(NUMBER_STRING_BUFFER,J);
									SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].ADDRESS_REGISTER[0]=NUMBER_BUFFER>>8;
									SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].ADDRESS_REGISTER[1]=NUMBER_BUFFER;
									k=J+k+1;
									J=0;
    718e:	69 2d       	mov	r22, r9
									{
										NUMBER_STRING_BUFFER[J]=G_RECIVED_DATA[i].DATA_ELEMENT[J+k];
										J++;
										
									}
									NUMBER_BUFFER=STRINGTOINT(NUMBER_STRING_BUFFER,J);
    7190:	ce 01       	movw	r24, r28
    7192:	01 96       	adiw	r24, 0x01	; 1
    7194:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <STRINGTOINT>
    7198:	a2 2f       	mov	r26, r18
									SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].NEW_VALUE[0]=NUMBER_BUFFER>>8;
    719a:	e0 91 51 0c 	lds	r30, 0x0C51
    719e:	f0 e0       	ldi	r31, 0x00	; 0
    71a0:	08 e0       	ldi	r16, 0x08	; 8
    71a2:	0e 94 d4 42 	call	0x85a8	; 0x85a8 <__lshrdi3>
    71a6:	cf 01       	movw	r24, r30
    71a8:	88 0f       	add	r24, r24
    71aa:	99 1f       	adc	r25, r25
    71ac:	88 0f       	add	r24, r24
    71ae:	99 1f       	adc	r25, r25
    71b0:	e8 0f       	add	r30, r24
    71b2:	f9 1f       	adc	r31, r25
    71b4:	e0 52       	subi	r30, 0x20	; 32
    71b6:	f3 4f       	sbci	r31, 0xF3	; 243
    71b8:	23 83       	std	Z+3, r18	; 0x03
									SENSOR_SEND_BUFFER[SENSOR_SEND_BUFFER_LENGTH].NEW_VALUE[1]=NUMBER_BUFFER;
    71ba:	80 91 51 0c 	lds	r24, 0x0C51
    71be:	90 e0       	ldi	r25, 0x00	; 0
    71c0:	fc 01       	movw	r30, r24
    71c2:	ee 0f       	add	r30, r30
    71c4:	ff 1f       	adc	r31, r31
    71c6:	ee 0f       	add	r30, r30
    71c8:	ff 1f       	adc	r31, r31
    71ca:	8e 0f       	add	r24, r30
    71cc:	9f 1f       	adc	r25, r31
    71ce:	fc 01       	movw	r30, r24
    71d0:	e0 52       	subi	r30, 0x20	; 32
    71d2:	f3 4f       	sbci	r31, 0xF3	; 243
    71d4:	a4 83       	std	Z+4, r26	; 0x04
									
									SENSOR_SEND_BUFFER_LENGTH++;
    71d6:	80 91 51 0c 	lds	r24, 0x0C51
    71da:	8f 5f       	subi	r24, 0xFF	; 255
    71dc:	80 93 51 0c 	sts	0x0C51, r24
    71e0:	86 c0       	rjmp	.+268    	; 0x72ee <SENSORS_FILL_SENSOR_BUFFERS+0x4f2>
								
							}
						}
						else
						{
							if(G_RECIVED_DATA[i].DATA_ELEMENT[3+k]=='R')/*MEANS ANDROID NEED TO READ DATA*/
    71e2:	ac 9c       	mul	r10, r12
    71e4:	f0 01       	movw	r30, r0
    71e6:	ad 9c       	mul	r10, r13
    71e8:	f0 0d       	add	r31, r0
    71ea:	11 24       	eor	r1, r1
    71ec:	2e 0f       	add	r18, r30
    71ee:	3f 1f       	adc	r19, r31
    71f0:	f9 01       	movw	r30, r18
    71f2:	eb 58       	subi	r30, 0x8B	; 139
    71f4:	f1 4f       	sbci	r31, 0xF1	; 241
    71f6:	90 81       	ld	r25, Z
    71f8:	92 35       	cpi	r25, 0x52	; 82
    71fa:	09 f0       	breq	.+2      	; 0x71fe <SENSORS_FILL_SENSOR_BUFFERS+0x402>
    71fc:	78 c0       	rjmp	.+240    	; 0x72ee <SENSORS_FILL_SENSOR_BUFFERS+0x4f2>
							{
								
									if (G_RECIVED_DATA[i].DATA_ELEMENT[4+k]==':')
    71fe:	ac 9c       	mul	r10, r12
    7200:	f0 01       	movw	r30, r0
    7202:	ad 9c       	mul	r10, r13
    7204:	f0 0d       	add	r31, r0
    7206:	11 24       	eor	r1, r1
    7208:	ee 0d       	add	r30, r14
    720a:	ff 1d       	adc	r31, r15
    720c:	e7 58       	subi	r30, 0x87	; 135
    720e:	f1 4f       	sbci	r31, 0xF1	; 241
    7210:	90 81       	ld	r25, Z
    7212:	9a 33       	cpi	r25, 0x3A	; 58
    7214:	09 f0       	breq	.+2      	; 0x7218 <SENSORS_FILL_SENSOR_BUFFERS+0x41c>
    7216:	6b c0       	rjmp	.+214    	; 0x72ee <SENSORS_FILL_SENSOR_BUFFERS+0x4f2>
									{
										k=5+k;
										SENSOR_READ_BUFFER[SENSOR_READ_BUFFER_LENGTH].SENSOR_INDEX=SENSOR_INDEX_BUFFER;
    7218:	20 91 50 0c 	lds	r18, 0x0C50
    721c:	30 e0       	ldi	r19, 0x00	; 0
    721e:	f9 01       	movw	r30, r18
    7220:	ee 0f       	add	r30, r30
    7222:	ff 1f       	adc	r31, r31
    7224:	ee 0f       	add	r30, r30
    7226:	ff 1f       	adc	r31, r31
    7228:	2e 0f       	add	r18, r30
    722a:	3f 1f       	adc	r19, r31
    722c:	f9 01       	movw	r30, r18
    722e:	ed 5c       	subi	r30, 0xCD	; 205
    7230:	f1 4f       	sbci	r31, 0xF1	; 241
    7232:	80 83       	st	Z, r24
							if(G_RECIVED_DATA[i].DATA_ELEMENT[3+k]=='R')/*MEANS ANDROID NEED TO READ DATA*/
							{
								
									if (G_RECIVED_DATA[i].DATA_ELEMENT[4+k]==':')
									{
										k=5+k;
    7234:	e5 e0       	ldi	r30, 0x05	; 5
    7236:	eb 0d       	add	r30, r11
										SENSOR_READ_BUFFER[SENSOR_READ_BUFFER_LENGTH].SENSOR_INDEX=SENSOR_INDEX_BUFFER;
										J=0;
										/*ADDRESS REGISTER*/
										while(G_RECIVED_DATA[i].DATA_ELEMENT[k+J]!=':')
    7238:	f0 e0       	ldi	r31, 0x00	; 0
    723a:	ac 9c       	mul	r10, r12
    723c:	d0 01       	movw	r26, r0
    723e:	ad 9c       	mul	r10, r13
    7240:	b0 0d       	add	r27, r0
    7242:	11 24       	eor	r1, r1
    7244:	ae 0f       	add	r26, r30
    7246:	bf 1f       	adc	r27, r31
    7248:	ab 58       	subi	r26, 0x8B	; 139
    724a:	b1 4f       	sbci	r27, 0xF1	; 241
    724c:	8c 91       	ld	r24, X
    724e:	8a 33       	cpi	r24, 0x3A	; 58
    7250:	29 f1       	breq	.+74     	; 0x729c <SENSORS_FILL_SENSOR_BUFFERS+0x4a0>
    7252:	9f 01       	movw	r18, r30
    7254:	87 2d       	mov	r24, r7
    7256:	98 2d       	mov	r25, r8
								
									if (G_RECIVED_DATA[i].DATA_ELEMENT[4+k]==':')
									{
										k=5+k;
										SENSOR_READ_BUFFER[SENSOR_READ_BUFFER_LENGTH].SENSOR_INDEX=SENSOR_INDEX_BUFFER;
										J=0;
    7258:	69 2d       	mov	r22, r9
										/*ADDRESS REGISTER*/
										while(G_RECIVED_DATA[i].DATA_ELEMENT[k+J]!=':')
										{
											NUMBER_STRING_BUFFER[J]=G_RECIVED_DATA[i].DATA_ELEMENT[J+k];
    725a:	ac 9c       	mul	r10, r12
    725c:	a0 01       	movw	r20, r0
    725e:	ad 9c       	mul	r10, r13
    7260:	50 0d       	add	r21, r0
    7262:	11 24       	eor	r1, r1
    7264:	24 0f       	add	r18, r20
    7266:	35 1f       	adc	r19, r21
    7268:	d9 01       	movw	r26, r18
    726a:	ab 58       	subi	r26, 0x8B	; 139
    726c:	b1 4f       	sbci	r27, 0xF1	; 241
    726e:	2c 91       	ld	r18, X
    7270:	a1 e0       	ldi	r26, 0x01	; 1
    7272:	b0 e0       	ldi	r27, 0x00	; 0
    7274:	ac 0f       	add	r26, r28
    7276:	bd 1f       	adc	r27, r29
    7278:	a8 0f       	add	r26, r24
    727a:	b9 1f       	adc	r27, r25
    727c:	2c 93       	st	X, r18
											J++;
    727e:	6f 5f       	subi	r22, 0xFF	; 255
									{
										k=5+k;
										SENSOR_READ_BUFFER[SENSOR_READ_BUFFER_LENGTH].SENSOR_INDEX=SENSOR_INDEX_BUFFER;
										J=0;
										/*ADDRESS REGISTER*/
										while(G_RECIVED_DATA[i].DATA_ELEMENT[k+J]!=':')
    7280:	86 2f       	mov	r24, r22
    7282:	90 e0       	ldi	r25, 0x00	; 0
    7284:	9c 01       	movw	r18, r24
    7286:	2e 0f       	add	r18, r30
    7288:	3f 1f       	adc	r19, r31
    728a:	da 01       	movw	r26, r20
    728c:	a2 0f       	add	r26, r18
    728e:	b3 1f       	adc	r27, r19
    7290:	ab 58       	subi	r26, 0x8B	; 139
    7292:	b1 4f       	sbci	r27, 0xF1	; 241
    7294:	7c 91       	ld	r23, X
    7296:	7a 33       	cpi	r23, 0x3A	; 58
    7298:	29 f7       	brne	.-54     	; 0x7264 <SENSORS_FILL_SENSOR_BUFFERS+0x468>
    729a:	01 c0       	rjmp	.+2      	; 0x729e <SENSORS_FILL_SENSOR_BUFFERS+0x4a2>
								
									if (G_RECIVED_DATA[i].DATA_ELEMENT[4+k]==':')
									{
										k=5+k;
										SENSOR_READ_BUFFER[SENSOR_READ_BUFFER_LENGTH].SENSOR_INDEX=SENSOR_INDEX_BUFFER;
										J=0;
    729c:	69 2d       	mov	r22, r9
										{
											NUMBER_STRING_BUFFER[J]=G_RECIVED_DATA[i].DATA_ELEMENT[J+k];
											J++;
										
										}
										NUMBER_BUFFER=STRINGTOINT(NUMBER_STRING_BUFFER,J);
    729e:	ce 01       	movw	r24, r28
    72a0:	01 96       	adiw	r24, 0x01	; 1
    72a2:	0e 94 31 0f 	call	0x1e62	; 0x1e62 <STRINGTOINT>
    72a6:	a2 2f       	mov	r26, r18
										SENSOR_READ_BUFFER[SENSOR_READ_BUFFER_LENGTH].ADDRESS_REGISTER[0]=NUMBER_BUFFER>>8;
    72a8:	e0 91 50 0c 	lds	r30, 0x0C50
    72ac:	f0 e0       	ldi	r31, 0x00	; 0
    72ae:	08 e0       	ldi	r16, 0x08	; 8
    72b0:	0e 94 d4 42 	call	0x85a8	; 0x85a8 <__lshrdi3>
    72b4:	cf 01       	movw	r24, r30
    72b6:	88 0f       	add	r24, r24
    72b8:	99 1f       	adc	r25, r25
    72ba:	88 0f       	add	r24, r24
    72bc:	99 1f       	adc	r25, r25
    72be:	e8 0f       	add	r30, r24
    72c0:	f9 1f       	adc	r31, r25
    72c2:	ed 5c       	subi	r30, 0xCD	; 205
    72c4:	f1 4f       	sbci	r31, 0xF1	; 241
    72c6:	21 83       	std	Z+1, r18	; 0x01
										SENSOR_READ_BUFFER[SENSOR_READ_BUFFER_LENGTH].ADDRESS_REGISTER[1]=NUMBER_BUFFER;
    72c8:	80 91 50 0c 	lds	r24, 0x0C50
    72cc:	90 e0       	ldi	r25, 0x00	; 0
    72ce:	fc 01       	movw	r30, r24
    72d0:	ee 0f       	add	r30, r30
    72d2:	ff 1f       	adc	r31, r31
    72d4:	ee 0f       	add	r30, r30
    72d6:	ff 1f       	adc	r31, r31
    72d8:	8e 0f       	add	r24, r30
    72da:	9f 1f       	adc	r25, r31
    72dc:	fc 01       	movw	r30, r24
    72de:	ed 5c       	subi	r30, 0xCD	; 205
    72e0:	f1 4f       	sbci	r31, 0xF1	; 241
    72e2:	a2 83       	std	Z+2, r26	; 0x02
									
										SENSOR_READ_BUFFER_LENGTH++;
    72e4:	80 91 50 0c 	lds	r24, 0x0C50
    72e8:	8f 5f       	subi	r24, 0xFF	; 255
    72ea:	80 93 50 0c 	sts	0x0C50, r24
			unsigned char i=0,k=0,J=0;
			unsigned char NUMBER_STRING_BUFFER[20];
			unsigned long long NUMBER_BUFFER=0;
			/*M:ADDRESS SENSOR(decimal):COMMAND(W or R):DATA1:DATA2:*/
			/*M:ADDRESS SENSOR:COMMAND:DATA1:*/
			for (i=5-TEMP_DIFF;i<5;++i)
    72ee:	1f 5f       	subi	r17, 0xFF	; 255
    72f0:	15 30       	cpi	r17, 0x05	; 5
    72f2:	09 f0       	breq	.+2      	; 0x72f6 <SENSORS_FILL_SENSOR_BUFFERS+0x4fa>
    72f4:	0b ce       	rjmp	.-1002   	; 0x6f0c <SENSORS_FILL_SENSOR_BUFFERS+0x110>
    72f6:	02 c0       	rjmp	.+4      	; 0x72fc <SENSORS_FILL_SENSOR_BUFFERS+0x500>
				}	
			}
		}	
		else
		{
			F_LAST_RECIVED_DATA_NOT_HANDLED=0;
    72f8:	10 92 c6 10 	sts	0x10C6, r1
		}
		
		
		
	}
}
    72fc:	69 96       	adiw	r28, 0x19	; 25
    72fe:	0f b6       	in	r0, 0x3f	; 63
    7300:	f8 94       	cli
    7302:	de bf       	out	0x3e, r29	; 62
    7304:	0f be       	out	0x3f, r0	; 63
    7306:	cd bf       	out	0x3d, r28	; 61
    7308:	df 91       	pop	r29
    730a:	cf 91       	pop	r28
    730c:	1f 91       	pop	r17
    730e:	0f 91       	pop	r16
    7310:	ff 90       	pop	r15
    7312:	ef 90       	pop	r14
    7314:	df 90       	pop	r13
    7316:	cf 90       	pop	r12
    7318:	bf 90       	pop	r11
    731a:	af 90       	pop	r10
    731c:	9f 90       	pop	r9
    731e:	8f 90       	pop	r8
    7320:	7f 90       	pop	r7
    7322:	6f 90       	pop	r6
    7324:	5f 90       	pop	r5
    7326:	4f 90       	pop	r4
    7328:	3f 90       	pop	r3
    732a:	2f 90       	pop	r2
    732c:	08 95       	ret

0000732e <ADD_NEW_SENSOR>:
		writeeeprom(MY_EEPROM_START_OF_SENSOR_ARRAY+index*SIZE_OF_SENSOR_DATA_EEPROM+13,MY_SENSORS[index].SENSOR_OCCUBIED);
	}
}
/*RETURN ITS INDEX OR RETURN -1 OF FAILED*/
char ADD_NEW_SENSOR(SENSOR_DT NEW_SENSOR)
{
    732e:	1f 93       	push	r17
    7330:	cf 93       	push	r28
    7332:	df 93       	push	r29
    7334:	cd b7       	in	r28, 0x3d	; 61
    7336:	de b7       	in	r29, 0x3e	; 62
	char index=0;
	if (NUMBER_OF_SENSORS==NUMBER_OF_SENSORS_IN_DATA_BASE)
    7338:	80 91 56 0c 	lds	r24, 0x0C56
    733c:	8a 30       	cpi	r24, 0x0A	; 10
    733e:	09 f4       	brne	.+2      	; 0x7342 <ADD_NEW_SENSOR+0x14>
    7340:	4a c0       	rjmp	.+148    	; 0x73d6 <ADD_NEW_SENSOR+0xa8>
	{
		 index=-1;
	}
	else
	{ 
		if (FIND_SENSOR(NEW_SENSOR.SENSOR_ADDRESS,5)==(char)(-1))/*if the same address was found*/
    7342:	65 e0       	ldi	r22, 0x05	; 5
    7344:	ce 01       	movw	r24, r28
    7346:	07 96       	adiw	r24, 0x07	; 7
    7348:	fe dc       	rcall	.-1540   	; 0x6d46 <FIND_SENSOR>
    734a:	8f 3f       	cpi	r24, 0xFF	; 255
    734c:	09 f0       	breq	.+2      	; 0x7350 <ADD_NEW_SENSOR+0x22>
    734e:	45 c0       	rjmp	.+138    	; 0x73da <ADD_NEW_SENSOR+0xac>
		{
			while(MY_SENSORS[(unsigned char)index].SENSOR_OCCUBIED==1)
    7350:	80 91 20 0d 	lds	r24, 0x0D20
    7354:	81 30       	cpi	r24, 0x01	; 1
    7356:	81 f4       	brne	.+32     	; 0x7378 <ADD_NEW_SENSOR+0x4a>
    7358:	10 e0       	ldi	r17, 0x00	; 0
    735a:	99 e1       	ldi	r25, 0x19	; 25
			{
				++index;
    735c:	1f 5f       	subi	r17, 0xFF	; 255
	}
	else
	{ 
		if (FIND_SENSOR(NEW_SENSOR.SENSOR_ADDRESS,5)==(char)(-1))/*if the same address was found*/
		{
			while(MY_SENSORS[(unsigned char)index].SENSOR_OCCUBIED==1)
    735e:	21 2f       	mov	r18, r17
    7360:	30 e0       	ldi	r19, 0x00	; 0
    7362:	92 9f       	mul	r25, r18
    7364:	f0 01       	movw	r30, r0
    7366:	93 9f       	mul	r25, r19
    7368:	f0 0d       	add	r31, r0
    736a:	11 24       	eor	r1, r1
    736c:	ed 5e       	subi	r30, 0xED	; 237
    736e:	f2 4f       	sbci	r31, 0xF2	; 242
    7370:	85 85       	ldd	r24, Z+13	; 0x0d
    7372:	81 30       	cpi	r24, 0x01	; 1
    7374:	99 f3       	breq	.-26     	; 0x735c <ADD_NEW_SENSOR+0x2e>
    7376:	03 c0       	rjmp	.+6      	; 0x737e <ADD_NEW_SENSOR+0x50>
    7378:	20 e0       	ldi	r18, 0x00	; 0
    737a:	30 e0       	ldi	r19, 0x00	; 0
    737c:	10 e0       	ldi	r17, 0x00	; 0
			{
				++index;
			}
			MY_SENSORS[(unsigned char)index].SENSOR_ADDRESS_LENGTH=5/*NEW_SENSOR.SENSOR_ADDRESS_LENGTH*/;
    737e:	89 e1       	ldi	r24, 0x19	; 25
    7380:	82 9f       	mul	r24, r18
    7382:	f0 01       	movw	r30, r0
    7384:	83 9f       	mul	r24, r19
    7386:	f0 0d       	add	r31, r0
    7388:	11 24       	eor	r1, r1
    738a:	ed 5e       	subi	r30, 0xED	; 237
    738c:	f2 4f       	sbci	r31, 0xF2	; 242
    738e:	85 e0       	ldi	r24, 0x05	; 5
    7390:	80 83       	st	Z, r24
			MY_SENSORS[(unsigned char)index].SENSOR_ADDRESS[0]=NEW_SENSOR.SENSOR_ADDRESS[0];
    7392:	8f 81       	ldd	r24, Y+7	; 0x07
    7394:	81 83       	std	Z+1, r24	; 0x01
			MY_SENSORS[(unsigned char)index].SENSOR_ADDRESS[1]=NEW_SENSOR.SENSOR_ADDRESS[1];
    7396:	88 85       	ldd	r24, Y+8	; 0x08
    7398:	82 83       	std	Z+2, r24	; 0x02
			MY_SENSORS[(unsigned char)index].SENSOR_ADDRESS[2]=NEW_SENSOR.SENSOR_ADDRESS[2];
    739a:	89 85       	ldd	r24, Y+9	; 0x09
    739c:	83 83       	std	Z+3, r24	; 0x03
			MY_SENSORS[(unsigned char)index].SENSOR_ADDRESS[3]=NEW_SENSOR.SENSOR_ADDRESS[3];
    739e:	8a 85       	ldd	r24, Y+10	; 0x0a
    73a0:	84 83       	std	Z+4, r24	; 0x04
			MY_SENSORS[(unsigned char)index].SENSOR_ADDRESS[4]=NEW_SENSOR.SENSOR_ADDRESS[4];
    73a2:	8b 85       	ldd	r24, Y+11	; 0x0b
    73a4:	85 83       	std	Z+5, r24	; 0x05
		
			MY_SENSORS[(unsigned char)index].SENSOR_PASSWORD[0]=NEW_SENSOR.SENSOR_PASSWORD[0];
    73a6:	8c 85       	ldd	r24, Y+12	; 0x0c
    73a8:	86 83       	std	Z+6, r24	; 0x06
			MY_SENSORS[(unsigned char)index].SENSOR_PASSWORD[1]=NEW_SENSOR.SENSOR_PASSWORD[1];
    73aa:	8d 85       	ldd	r24, Y+13	; 0x0d
    73ac:	87 83       	std	Z+7, r24	; 0x07
			MY_SENSORS[(unsigned char)index].SENSOR_PASSWORD[2]=NEW_SENSOR.SENSOR_PASSWORD[2];
    73ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    73b0:	80 87       	std	Z+8, r24	; 0x08
			MY_SENSORS[(unsigned char)index].SENSOR_PASSWORD[3]=NEW_SENSOR.SENSOR_PASSWORD[3];
    73b2:	8f 85       	ldd	r24, Y+15	; 0x0f
    73b4:	81 87       	std	Z+9, r24	; 0x09
		
			MY_SENSORS[(unsigned char)index].SENSOR_VERSION=NEW_SENSOR.SENSOR_VERSION;
    73b6:	88 89       	ldd	r24, Y+16	; 0x10
    73b8:	82 87       	std	Z+10, r24	; 0x0a
			MY_SENSORS[(unsigned char)index].SENSOR_TYPE=NEW_SENSOR.SENSOR_TYPE;
    73ba:	89 89       	ldd	r24, Y+17	; 0x11
    73bc:	83 87       	std	Z+11, r24	; 0x0b
			MY_SENSORS[(unsigned char)index].SENSOR_STATE=1;
    73be:	81 e0       	ldi	r24, 0x01	; 1
    73c0:	84 87       	std	Z+12, r24	; 0x0c
			MY_SENSORS[(unsigned char)index].SENSOR_OCCUBIED=1;
    73c2:	85 87       	std	Z+13, r24	; 0x0d
			++NUMBER_OF_SENSORS;
    73c4:	80 91 56 0c 	lds	r24, 0x0C56
    73c8:	8f 5f       	subi	r24, 0xFF	; 255
    73ca:	80 93 56 0c 	sts	0x0C56, r24
			SENSOR_SAVE((unsigned char)index);
    73ce:	81 2f       	mov	r24, r17
    73d0:	34 dc       	rcall	.-1944   	; 0x6c3a <SENSOR_SAVE>
			NUM_SENSOR_SAVE();
    73d2:	b2 dc       	rcall	.-1692   	; 0x6d38 <NUM_SENSOR_SAVE>
    73d4:	03 c0       	rjmp	.+6      	; 0x73dc <ADD_NEW_SENSOR+0xae>
char ADD_NEW_SENSOR(SENSOR_DT NEW_SENSOR)
{
	char index=0;
	if (NUMBER_OF_SENSORS==NUMBER_OF_SENSORS_IN_DATA_BASE)
	{
		 index=-1;
    73d6:	1f ef       	ldi	r17, 0xFF	; 255
    73d8:	01 c0       	rjmp	.+2      	; 0x73dc <ADD_NEW_SENSOR+0xae>
			SENSOR_SAVE((unsigned char)index);
			NUM_SENSOR_SAVE();
		}
		else
		{
			 index=-1;
    73da:	1f ef       	ldi	r17, 0xFF	; 255
		
		
	}
	return index;
	
}
    73dc:	81 2f       	mov	r24, r17
    73de:	df 91       	pop	r29
    73e0:	cf 91       	pop	r28
    73e2:	1f 91       	pop	r17
    73e4:	08 95       	ret

000073e6 <DELETE_SENSOR>:
	
}

void DELETE_SENSOR(unsigned char* ADDRESS,unsigned char ADDRESS_LENGTH)
{
	char index=FIND_SENSOR(ADDRESS,ADDRESS_LENGTH);
    73e6:	af dc       	rcall	.-1698   	; 0x6d46 <FIND_SENSOR>
	if (index!=-1)
	{
		MY_SENSORS[(unsigned char)index].SENSOR_OCCUBIED=0;
    73e8:	28 2f       	mov	r18, r24
    73ea:	30 e0       	ldi	r19, 0x00	; 0
    73ec:	99 e1       	ldi	r25, 0x19	; 25
    73ee:	89 9f       	mul	r24, r25
    73f0:	f0 01       	movw	r30, r0
    73f2:	11 24       	eor	r1, r1
    73f4:	ed 5e       	subi	r30, 0xED	; 237
    73f6:	f2 4f       	sbci	r31, 0xF2	; 242
    73f8:	15 86       	std	Z+13, r1	; 0x0d
		writeeeprom(MY_EEPROM_START_OF_SENSOR_ARRAY+((unsigned char)index)*SIZE_OF_SENSOR_DATA_EEPROM+13,0);
    73fa:	22 0f       	add	r18, r18
    73fc:	33 1f       	adc	r19, r19
    73fe:	c9 01       	movw	r24, r18
    7400:	88 0f       	add	r24, r24
    7402:	99 1f       	adc	r25, r25
    7404:	88 0f       	add	r24, r24
    7406:	99 1f       	adc	r25, r25
    7408:	88 0f       	add	r24, r24
    740a:	99 1f       	adc	r25, r25
    740c:	82 1b       	sub	r24, r18
    740e:	93 0b       	sbc	r25, r19
    7410:	60 e0       	ldi	r22, 0x00	; 0
    7412:	8e 58       	subi	r24, 0x8E	; 142
    7414:	9f 4f       	sbci	r25, 0xFF	; 255
    7416:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
		--NUMBER_OF_SENSORS;
    741a:	80 91 56 0c 	lds	r24, 0x0C56
    741e:	81 50       	subi	r24, 0x01	; 1
    7420:	80 93 56 0c 	sts	0x0C56, r24
		NUM_SENSOR_SAVE();
    7424:	89 cc       	rjmp	.-1774   	; 0x6d38 <NUM_SENSOR_SAVE>
    7426:	08 95       	ret

00007428 <DELETE_ALL_SENSOR>:
	}
}

void DELETE_ALL_SENSOR()
{
    7428:	1f 93       	push	r17
    742a:	cf 93       	push	r28
    742c:	df 93       	push	r29
    742e:	1f 92       	push	r1
    7430:	cd b7       	in	r28, 0x3d	; 61
    7432:	de b7       	in	r29, 0x3e	; 62
	volatile unsigned char index=0;
    7434:	19 82       	std	Y+1, r1	; 0x01
	for(index=0;index<NUMBER_OF_SENSORS_IN_DATA_BASE;++index)
    7436:	19 82       	std	Y+1, r1	; 0x01
    7438:	89 81       	ldd	r24, Y+1	; 0x01
    743a:	8a 30       	cpi	r24, 0x0A	; 10
    743c:	00 f5       	brcc	.+64     	; 0x747e <DELETE_ALL_SENSOR+0x56>
	{
		MY_SENSORS[(unsigned char)index].SENSOR_OCCUBIED=0;
    743e:	19 e1       	ldi	r17, 0x19	; 25
    7440:	e9 81       	ldd	r30, Y+1	; 0x01
    7442:	1e 9f       	mul	r17, r30
    7444:	f0 01       	movw	r30, r0
    7446:	11 24       	eor	r1, r1
    7448:	ed 5e       	subi	r30, 0xED	; 237
    744a:	f2 4f       	sbci	r31, 0xF2	; 242
    744c:	15 86       	std	Z+13, r1	; 0x0d
		writeeeprom(MY_EEPROM_START_OF_SENSOR_ARRAY+((unsigned char)index)*SIZE_OF_SENSOR_DATA_EEPROM+13,0);
    744e:	29 81       	ldd	r18, Y+1	; 0x01
    7450:	30 e0       	ldi	r19, 0x00	; 0
    7452:	22 0f       	add	r18, r18
    7454:	33 1f       	adc	r19, r19
    7456:	c9 01       	movw	r24, r18
    7458:	88 0f       	add	r24, r24
    745a:	99 1f       	adc	r25, r25
    745c:	88 0f       	add	r24, r24
    745e:	99 1f       	adc	r25, r25
    7460:	88 0f       	add	r24, r24
    7462:	99 1f       	adc	r25, r25
    7464:	82 1b       	sub	r24, r18
    7466:	93 0b       	sbc	r25, r19
    7468:	60 e0       	ldi	r22, 0x00	; 0
    746a:	8e 58       	subi	r24, 0x8E	; 142
    746c:	9f 4f       	sbci	r25, 0xFF	; 255
    746e:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
}

void DELETE_ALL_SENSOR()
{
	volatile unsigned char index=0;
	for(index=0;index<NUMBER_OF_SENSORS_IN_DATA_BASE;++index)
    7472:	89 81       	ldd	r24, Y+1	; 0x01
    7474:	8f 5f       	subi	r24, 0xFF	; 255
    7476:	89 83       	std	Y+1, r24	; 0x01
    7478:	89 81       	ldd	r24, Y+1	; 0x01
    747a:	8a 30       	cpi	r24, 0x0A	; 10
    747c:	08 f3       	brcs	.-62     	; 0x7440 <DELETE_ALL_SENSOR+0x18>
	{
		MY_SENSORS[(unsigned char)index].SENSOR_OCCUBIED=0;
		writeeeprom(MY_EEPROM_START_OF_SENSOR_ARRAY+((unsigned char)index)*SIZE_OF_SENSOR_DATA_EEPROM+13,0);
	}
	NUMBER_OF_SENSORS=0;
    747e:	10 92 56 0c 	sts	0x0C56, r1
	NUM_SENSOR_SAVE();
    7482:	5a dc       	rcall	.-1868   	; 0x6d38 <NUM_SENSOR_SAVE>
}
    7484:	0f 90       	pop	r0
    7486:	df 91       	pop	r29
    7488:	cf 91       	pop	r28
    748a:	1f 91       	pop	r17
    748c:	08 95       	ret

0000748e <SENSORS_RESET_LOOP>:
	vTaskDelay(pdMS_TO_TICKS(10));
}

void SENSORS_RESET_LOOP()
{
	if (F_B_RESET_SENSORS)
    748e:	80 91 6a 0e 	lds	r24, 0x0E6A
    7492:	88 23       	and	r24, r24
    7494:	19 f0       	breq	.+6      	; 0x749c <SENSORS_RESET_LOOP+0xe>
	{
		F_B_RESET_SENSORS=0;
    7496:	10 92 6a 0e 	sts	0x0E6A, r1
		DELETE_ALL_SENSOR();
    749a:	c6 cf       	rjmp	.-116    	; 0x7428 <DELETE_ALL_SENSOR>
    749c:	08 95       	ret

0000749e <RESET_ALL_LOOP>:
}


void RESET_ALL_LOOP()
{
	if (F_B_RESET_ALL)
    749e:	80 91 74 0e 	lds	r24, 0x0E74
    74a2:	88 23       	and	r24, r24
    74a4:	21 f0       	breq	.+8      	; 0x74ae <RESET_ALL_LOOP+0x10>
	{
		F_B_RESET_ALL=0;
    74a6:	10 92 74 0e 	sts	0x0E74, r1
		DELETE_ALL_SENSOR();
    74aa:	be df       	rcall	.-132    	; 0x7428 <DELETE_ALL_SENSOR>
		WIFI_RESET();
    74ac:	1b c6       	rjmp	.+3126   	; 0x80e4 <WIFI_RESET>
    74ae:	08 95       	ret

000074b0 <SENSOR_STATE_ENABLE>:
	NUM_SENSOR_SAVE();
}

void SENSOR_STATE_ENABLE(unsigned char* ADDRESS,unsigned char ADDRESS_LENGTH)
{
	char index=FIND_SENSOR(ADDRESS,ADDRESS_LENGTH);
    74b0:	4a dc       	rcall	.-1900   	; 0x6d46 <FIND_SENSOR>
	if (index!=-1)
	{
		MY_SENSORS[(unsigned char)index].SENSOR_STATE=1;
    74b2:	28 2f       	mov	r18, r24
    74b4:	30 e0       	ldi	r19, 0x00	; 0
    74b6:	99 e1       	ldi	r25, 0x19	; 25
    74b8:	89 9f       	mul	r24, r25
    74ba:	f0 01       	movw	r30, r0
    74bc:	11 24       	eor	r1, r1
    74be:	ed 5e       	subi	r30, 0xED	; 237
    74c0:	f2 4f       	sbci	r31, 0xF2	; 242
    74c2:	81 e0       	ldi	r24, 0x01	; 1
    74c4:	84 87       	std	Z+12, r24	; 0x0c
		writeeeprom(MY_EEPROM_START_OF_SENSOR_ARRAY+((unsigned char)index)*SIZE_OF_SENSOR_DATA_EEPROM+12,1);
    74c6:	22 0f       	add	r18, r18
    74c8:	33 1f       	adc	r19, r19
    74ca:	c9 01       	movw	r24, r18
    74cc:	88 0f       	add	r24, r24
    74ce:	99 1f       	adc	r25, r25
    74d0:	88 0f       	add	r24, r24
    74d2:	99 1f       	adc	r25, r25
    74d4:	88 0f       	add	r24, r24
    74d6:	99 1f       	adc	r25, r25
    74d8:	82 1b       	sub	r24, r18
    74da:	93 0b       	sbc	r25, r19
    74dc:	61 e0       	ldi	r22, 0x01	; 1
    74de:	8f 58       	subi	r24, 0x8F	; 143
    74e0:	9f 4f       	sbci	r25, 0xFF	; 255
    74e2:	0c 94 48 1c 	jmp	0x3890	; 0x3890 <writeeeprom>
    74e6:	08 95       	ret

000074e8 <SENSOR_STATE_DISABLE>:
	}
}

void SENSOR_STATE_DISABLE(unsigned char* ADDRESS,unsigned char ADDRESS_LENGTH)
{
	char index=FIND_SENSOR(ADDRESS,ADDRESS_LENGTH);
    74e8:	2e dc       	rcall	.-1956   	; 0x6d46 <FIND_SENSOR>
	if (index!=-1)
	{
		MY_SENSORS[(unsigned char)index].SENSOR_STATE=0;
    74ea:	28 2f       	mov	r18, r24
    74ec:	30 e0       	ldi	r19, 0x00	; 0
    74ee:	99 e1       	ldi	r25, 0x19	; 25
    74f0:	89 9f       	mul	r24, r25
    74f2:	f0 01       	movw	r30, r0
    74f4:	11 24       	eor	r1, r1
    74f6:	ed 5e       	subi	r30, 0xED	; 237
    74f8:	f2 4f       	sbci	r31, 0xF2	; 242
    74fa:	14 86       	std	Z+12, r1	; 0x0c
		writeeeprom(MY_EEPROM_START_OF_SENSOR_ARRAY+((unsigned char)index)*SIZE_OF_SENSOR_DATA_EEPROM+12,0);
    74fc:	22 0f       	add	r18, r18
    74fe:	33 1f       	adc	r19, r19
    7500:	c9 01       	movw	r24, r18
    7502:	88 0f       	add	r24, r24
    7504:	99 1f       	adc	r25, r25
    7506:	88 0f       	add	r24, r24
    7508:	99 1f       	adc	r25, r25
    750a:	88 0f       	add	r24, r24
    750c:	99 1f       	adc	r25, r25
    750e:	82 1b       	sub	r24, r18
    7510:	93 0b       	sbc	r25, r19
    7512:	60 e0       	ldi	r22, 0x00	; 0
    7514:	8f 58       	subi	r24, 0x8F	; 143
    7516:	9f 4f       	sbci	r25, 0xFF	; 255
    7518:	0c 94 48 1c 	jmp	0x3890	; 0x3890 <writeeeprom>
    751c:	08 95       	ret

0000751e <LOOP_SENSORS_MANAGE>:



void LOOP_SENSORS_MANAGE()
{
	if (F_B_ADD_NEW_SENSOR)
    751e:	80 91 12 0d 	lds	r24, 0x0D12
    7522:	88 23       	and	r24, r24
    7524:	e9 f0       	breq	.+58     	; 0x7560 <LOOP_SENSORS_MANAGE+0x42>
	{
		F_B_ADD_NEW_SENSOR=0;
    7526:	10 92 12 0d 	sts	0x0D12, r1
		ADD_NEW_SENSOR(B_NEW_SENSOR_BUFFER);
    752a:	8d b7       	in	r24, 0x3d	; 61
    752c:	9e b7       	in	r25, 0x3e	; 62
    752e:	49 97       	sbiw	r24, 0x19	; 25
    7530:	0f b6       	in	r0, 0x3f	; 63
    7532:	f8 94       	cli
    7534:	9e bf       	out	0x3e, r25	; 62
    7536:	0f be       	out	0x3f, r0	; 63
    7538:	8d bf       	out	0x3d, r24	; 61
    753a:	ad b7       	in	r26, 0x3d	; 61
    753c:	be b7       	in	r27, 0x3e	; 62
    753e:	11 96       	adiw	r26, 0x01	; 1
    7540:	89 e1       	ldi	r24, 0x19	; 25
    7542:	e4 e1       	ldi	r30, 0x14	; 20
    7544:	fe e0       	ldi	r31, 0x0E	; 14
    7546:	01 90       	ld	r0, Z+
    7548:	0d 92       	st	X+, r0
    754a:	8a 95       	dec	r24
    754c:	e1 f7       	brne	.-8      	; 0x7546 <LOOP_SENSORS_MANAGE+0x28>
    754e:	ef de       	rcall	.-546    	; 0x732e <ADD_NEW_SENSOR>
    7550:	8d b7       	in	r24, 0x3d	; 61
    7552:	9e b7       	in	r25, 0x3e	; 62
    7554:	49 96       	adiw	r24, 0x19	; 25
    7556:	0f b6       	in	r0, 0x3f	; 63
    7558:	f8 94       	cli
    755a:	9e bf       	out	0x3e, r25	; 62
    755c:	0f be       	out	0x3f, r0	; 63
    755e:	8d bf       	out	0x3d, r24	; 61
	}
	if (F_B_DELETE_SENSOR)
    7560:	80 91 13 0e 	lds	r24, 0x0E13
    7564:	88 23       	and	r24, r24
    7566:	31 f0       	breq	.+12     	; 0x7574 <LOOP_SENSORS_MANAGE+0x56>
	{
		F_B_DELETE_SENSOR=0;
    7568:	10 92 13 0e 	sts	0x0E13, r1
		DELETE_SENSOR(B_SENSOR_ADDRESS_DELETE,5/*B_SENSOR_ADDRESS_L_DELETE*/);
    756c:	65 e0       	ldi	r22, 0x05	; 5
    756e:	8e e0       	ldi	r24, 0x0E	; 14
    7570:	9e e0       	ldi	r25, 0x0E	; 14
    7572:	39 df       	rcall	.-398    	; 0x73e6 <DELETE_SENSOR>
	}
	if (F_B_ENABLE_SENSOR)
    7574:	80 91 31 0e 	lds	r24, 0x0E31
    7578:	88 23       	and	r24, r24
    757a:	31 f0       	breq	.+12     	; 0x7588 <LOOP_SENSORS_MANAGE+0x6a>
	{
		F_B_ENABLE_SENSOR=0;
    757c:	10 92 31 0e 	sts	0x0E31, r1
		SENSOR_STATE_ENABLE(B_SENSOR_ADDRESS_ENABLE,5/*B_SENSOR_ADDRESS_L_ENABLE*/);
    7580:	65 e0       	ldi	r22, 0x05	; 5
    7582:	85 e6       	ldi	r24, 0x65	; 101
    7584:	9e e0       	ldi	r25, 0x0E	; 14
    7586:	94 df       	rcall	.-216    	; 0x74b0 <SENSOR_STATE_ENABLE>
	}
	if (F_B_DISABLE_SENSOR)
    7588:	80 91 73 0e 	lds	r24, 0x0E73
    758c:	88 23       	and	r24, r24
    758e:	31 f0       	breq	.+12     	; 0x759c <LOOP_SENSORS_MANAGE+0x7e>
	{
		F_B_DISABLE_SENSOR=0;
    7590:	10 92 73 0e 	sts	0x0E73, r1
		SENSOR_STATE_DISABLE(B_SENSOR_ADDRESS_DISABLE,5/*B_SENSOR_ADDRESS_L_DISABLE*/);
    7594:	65 e0       	ldi	r22, 0x05	; 5
    7596:	8b e6       	ldi	r24, 0x6B	; 107
    7598:	9e e0       	ldi	r25, 0x0E	; 14
    759a:	a6 df       	rcall	.-180    	; 0x74e8 <SENSOR_STATE_DISABLE>
	}
	if (DELETE_FLAG)
    759c:	80 91 53 0c 	lds	r24, 0x0C53
    75a0:	88 23       	and	r24, r24
    75a2:	31 f0       	breq	.+12     	; 0x75b0 <LOOP_SENSORS_MANAGE+0x92>
	{
		DELETE_FLAG=0;
    75a4:	10 92 53 0c 	sts	0x0C53, r1
		TEST_UART_SEND_str("delete all\n");
    75a8:	8e ed       	ldi	r24, 0xDE	; 222
    75aa:	93 e0       	ldi	r25, 0x03	; 3
    75ac:	36 d2       	rcall	.+1132   	; 0x7a1a <TEST_UART_SEND_str>
		DELETE_ALL_SENSOR();/*TO BE CONTINUED*/
    75ae:	3c df       	rcall	.-392    	; 0x7428 <DELETE_ALL_SENSOR>
	}
	
	TEST2_SET();
    75b0:	a9 9a       	sbi	0x15, 1	; 21
	SENSORS_CONNECT();
    75b2:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <SENSORS_CONNECT>
	SENSORS_BEACON();
    75b6:	0e 94 74 28 	call	0x50e8	; 0x50e8 <SENSORS_BEACON>
	SENSORS_NEW_SESSIONS();
    75ba:	0e 94 79 29 	call	0x52f2	; 0x52f2 <SENSORS_NEW_SESSIONS>
	SENSORS_CHANGE_CHANNEL();
    75be:	0e 94 89 2a 	call	0x5512	; 0x5512 <SENSORS_CHANGE_CHANNEL>
	SENSORS_FILL_SENSOR_BUFFERS();
    75c2:	1c dc       	rcall	.-1992   	; 0x6dfc <SENSORS_FILL_SENSOR_BUFFERS>
	SENSORS_APPLY_SEND_BUFFER();
    75c4:	0e 94 9f 2b 	call	0x573e	; 0x573e <SENSORS_APPLY_SEND_BUFFER>
	SENSORS_APPLY_READ_BUFFER();
    75c8:	0e 94 40 31 	call	0x6280	; 0x6280 <SENSORS_APPLY_READ_BUFFER>
	SENSORS_RESET_LOOP();
    75cc:	60 df       	rcall	.-320    	; 0x748e <SENSORS_RESET_LOOP>
	RESET_ALL_LOOP();
    75ce:	67 df       	rcall	.-306    	; 0x749e <RESET_ALL_LOOP>
	toggybit(*PORT_OUT_TOGGLE_LED,TOGGLE_LED_PIN);
    75d0:	93 b1       	in	r25, 0x03	; 3
    75d2:	80 e2       	ldi	r24, 0x20	; 32
    75d4:	89 27       	eor	r24, r25
    75d6:	83 b9       	out	0x03, r24	; 3
	TEST2_CLEAR();
    75d8:	a9 98       	cbi	0x15, 1	; 21
	vTaskDelay(pdMS_TO_TICKS(10));
    75da:	61 e0       	ldi	r22, 0x01	; 1
    75dc:	70 e0       	ldi	r23, 0x00	; 0
    75de:	80 e0       	ldi	r24, 0x00	; 0
    75e0:	90 e0       	ldi	r25, 0x00	; 0
    75e2:	0c 94 15 1b 	jmp	0x362a	; 0x362a <vTaskDelay>
    75e6:	08 95       	ret

000075e8 <SENSOR_MANAGE_TASK>:



void SENSOR_MANAGE_TASK(void * pd)
{
	QUEUE_SEMAPHORE=xSemaphoreCreateBinary();
    75e8:	43 e0       	ldi	r20, 0x03	; 3
    75ea:	60 e0       	ldi	r22, 0x00	; 0
    75ec:	81 e0       	ldi	r24, 0x01	; 1
    75ee:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <xQueueGenericCreate>
    75f2:	90 93 72 0e 	sts	0x0E72, r25
    75f6:	80 93 71 0e 	sts	0x0E71, r24
	xSemaphoreGive(QUEUE_SEMAPHORE);
    75fa:	00 e0       	ldi	r16, 0x00	; 0
    75fc:	20 e0       	ldi	r18, 0x00	; 0
    75fe:	30 e0       	ldi	r19, 0x00	; 0
    7600:	a9 01       	movw	r20, r18
    7602:	60 e0       	ldi	r22, 0x00	; 0
    7604:	70 e0       	ldi	r23, 0x00	; 0
    7606:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <xQueueGenericSend>
	PROTOCOL_SETUP();
    760a:	0e 94 f7 1f 	call	0x3fee	; 0x3fee <PROTOCOL_SETUP>
	external_int_enable(INT6_ENABLE ,INT_FALLING);
    760e:	62 e0       	ldi	r22, 0x02	; 2
    7610:	80 e4       	ldi	r24, 0x40	; 64
    7612:	0e 94 5f 1c 	call	0x38be	; 0x38be <external_int_enable>
	LOAD_OLD_LAST_ENTRY();
    7616:	bd da       	rcall	.-2694   	; 0x6b92 <LOAD_OLD_LAST_ENTRY>
	SENSORS_LOAD_EEPROM();
    7618:	e2 d9       	rcall	.-3132   	; 0x69de <SENSORS_LOAD_EEPROM>
	QUEUE_INTILIZE_ARRAY_U8(&G_SEND_DATA_QUEUE);
    761a:	89 e2       	ldi	r24, 0x29	; 41
    761c:	9f e0       	ldi	r25, 0x0F	; 15
    761e:	0e 94 49 05 	call	0xa92	; 0xa92 <QUEUE_INTILIZE_ARRAY_U8>

	
	while(1)
	{
		TEST_ADD_SENSOR();
    7622:	a5 d0       	rcall	.+330    	; 0x776e <TEST_ADD_SENSOR>
		 LOOP_SENSORS_MANAGE();
    7624:	7c df       	rcall	.-264    	; 0x751e <LOOP_SENSORS_MANAGE>
    7626:	fd cf       	rjmp	.-6      	; 0x7622 <SENSOR_MANAGE_TASK+0x3a>

00007628 <INT6_ISR>:



void INT6_ISR()
{
	DELETE_COUNTER=0;
    7628:	10 92 54 0c 	sts	0x0C54, r1
	DELETE_COUNTER_FLAG=1;
    762c:	81 e0       	ldi	r24, 0x01	; 1
    762e:	80 93 52 0c 	sts	0x0C52, r24
    7632:	08 95       	ret

00007634 <SENSOR_TIMER3>:
}

void SENSOR_TIMER3()
{
    7634:	80 e0       	ldi	r24, 0x00	; 0
    7636:	90 e0       	ldi	r25, 0x00	; 0
	unsigned char index;
	for (index=0;index<NUMBER_OF_SENSORS_IN_DATA_BASE;++index)
	{
		if (MY_SENSORS[index].SENSOR_OCCUBIED)
    7638:	49 e1       	ldi	r20, 0x19	; 25
    763a:	9c 01       	movw	r18, r24
    763c:	48 9f       	mul	r20, r24
    763e:	f0 01       	movw	r30, r0
    7640:	49 9f       	mul	r20, r25
    7642:	f0 0d       	add	r31, r0
    7644:	11 24       	eor	r1, r1
    7646:	ed 5e       	subi	r30, 0xED	; 237
    7648:	f2 4f       	sbci	r31, 0xF2	; 242
    764a:	55 85       	ldd	r21, Z+13	; 0x0d
    764c:	55 23       	and	r21, r21
    764e:	09 f4       	brne	.+2      	; 0x7652 <SENSOR_TIMER3+0x1e>
    7650:	52 c0       	rjmp	.+164    	; 0x76f6 <SENSOR_TIMER3+0xc2>
		{
			if (MY_SENSORS[index].SENSOR_STATE)
    7652:	48 9f       	mul	r20, r24
    7654:	f0 01       	movw	r30, r0
    7656:	49 9f       	mul	r20, r25
    7658:	f0 0d       	add	r31, r0
    765a:	11 24       	eor	r1, r1
    765c:	ed 5e       	subi	r30, 0xED	; 237
    765e:	f2 4f       	sbci	r31, 0xF2	; 242
    7660:	54 85       	ldd	r21, Z+12	; 0x0c
    7662:	55 23       	and	r21, r21
    7664:	09 f4       	brne	.+2      	; 0x7668 <SENSOR_TIMER3+0x34>
    7666:	47 c0       	rjmp	.+142    	; 0x76f6 <SENSOR_TIMER3+0xc2>
			{
				if (MY_SENSORS[index].F_CONNECTED)
    7668:	48 9f       	mul	r20, r24
    766a:	f0 01       	movw	r30, r0
    766c:	49 9f       	mul	r20, r25
    766e:	f0 0d       	add	r31, r0
    7670:	11 24       	eor	r1, r1
    7672:	ed 5e       	subi	r30, 0xED	; 237
    7674:	f2 4f       	sbci	r31, 0xF2	; 242
    7676:	56 85       	ldd	r21, Z+14	; 0x0e
    7678:	55 23       	and	r21, r21
    767a:	49 f1       	breq	.+82     	; 0x76ce <SENSOR_TIMER3+0x9a>
				{
					if (MY_SENSORS[index].C_T_BEACON!=MAX_TIMER_BEACON_COUNTER)
    767c:	48 9f       	mul	r20, r24
    767e:	f0 01       	movw	r30, r0
    7680:	49 9f       	mul	r20, r25
    7682:	f0 0d       	add	r31, r0
    7684:	11 24       	eor	r1, r1
    7686:	ed 5e       	subi	r30, 0xED	; 237
    7688:	f2 4f       	sbci	r31, 0xF2	; 242
    768a:	50 89       	ldd	r21, Z+16	; 0x10
    768c:	58 30       	cpi	r21, 0x08	; 8
    768e:	51 f0       	breq	.+20     	; 0x76a4 <SENSOR_TIMER3+0x70>
					{
						MY_SENSORS[index].C_T_BEACON++;
    7690:	48 9f       	mul	r20, r24
    7692:	f0 01       	movw	r30, r0
    7694:	49 9f       	mul	r20, r25
    7696:	f0 0d       	add	r31, r0
    7698:	11 24       	eor	r1, r1
    769a:	ed 5e       	subi	r30, 0xED	; 237
    769c:	f2 4f       	sbci	r31, 0xF2	; 242
    769e:	50 89       	ldd	r21, Z+16	; 0x10
    76a0:	5f 5f       	subi	r21, 0xFF	; 255
    76a2:	50 8b       	std	Z+16, r21	; 0x10
					}
					if (MY_SENSORS[index].C_T_SESSION_KEY!=MAX_SESSION_KEY_TIMER_COUNT)
    76a4:	42 9f       	mul	r20, r18
    76a6:	f0 01       	movw	r30, r0
    76a8:	43 9f       	mul	r20, r19
    76aa:	f0 0d       	add	r31, r0
    76ac:	11 24       	eor	r1, r1
    76ae:	ed 5e       	subi	r30, 0xED	; 237
    76b0:	f2 4f       	sbci	r31, 0xF2	; 242
    76b2:	52 89       	ldd	r21, Z+18	; 0x12
    76b4:	58 32       	cpi	r21, 0x28	; 40
    76b6:	f9 f0       	breq	.+62     	; 0x76f6 <SENSOR_TIMER3+0xc2>
					{
						MY_SENSORS[index].C_T_SESSION_KEY++;
    76b8:	42 9f       	mul	r20, r18
    76ba:	f0 01       	movw	r30, r0
    76bc:	43 9f       	mul	r20, r19
    76be:	f0 0d       	add	r31, r0
    76c0:	11 24       	eor	r1, r1
    76c2:	ed 5e       	subi	r30, 0xED	; 237
    76c4:	f2 4f       	sbci	r31, 0xF2	; 242
    76c6:	22 89       	ldd	r18, Z+18	; 0x12
    76c8:	2f 5f       	subi	r18, 0xFF	; 255
    76ca:	22 8b       	std	Z+18, r18	; 0x12
    76cc:	14 c0       	rjmp	.+40     	; 0x76f6 <SENSOR_TIMER3+0xc2>
					}
				}
				else
				{
					if (MY_SENSORS[index].C_T_TRY_CONNECTED!=MAX_TIMER_CONNECT_COUNT_SENSOR)
    76ce:	48 9f       	mul	r20, r24
    76d0:	f0 01       	movw	r30, r0
    76d2:	49 9f       	mul	r20, r25
    76d4:	f0 0d       	add	r31, r0
    76d6:	11 24       	eor	r1, r1
    76d8:	ed 5e       	subi	r30, 0xED	; 237
    76da:	f2 4f       	sbci	r31, 0xF2	; 242
    76dc:	57 85       	ldd	r21, Z+15	; 0x0f
    76de:	54 31       	cpi	r21, 0x14	; 20
    76e0:	51 f0       	breq	.+20     	; 0x76f6 <SENSOR_TIMER3+0xc2>
					{
						MY_SENSORS[index].C_T_TRY_CONNECTED++;
    76e2:	48 9f       	mul	r20, r24
    76e4:	f0 01       	movw	r30, r0
    76e6:	49 9f       	mul	r20, r25
    76e8:	f0 0d       	add	r31, r0
    76ea:	11 24       	eor	r1, r1
    76ec:	ed 5e       	subi	r30, 0xED	; 237
    76ee:	f2 4f       	sbci	r31, 0xF2	; 242
    76f0:	27 85       	ldd	r18, Z+15	; 0x0f
    76f2:	2f 5f       	subi	r18, 0xFF	; 255
    76f4:	27 87       	std	Z+15, r18	; 0x0f
    76f6:	01 96       	adiw	r24, 0x01	; 1
}

void SENSOR_TIMER3()
{
	unsigned char index;
	for (index=0;index<NUMBER_OF_SENSORS_IN_DATA_BASE;++index)
    76f8:	8a 30       	cpi	r24, 0x0A	; 10
    76fa:	91 05       	cpc	r25, r1
    76fc:	09 f0       	breq	.+2      	; 0x7700 <SENSOR_TIMER3+0xcc>
    76fe:	9d cf       	rjmp	.-198    	; 0x763a <SENSOR_TIMER3+0x6>
				}
			}
		}
	}
	
	if(DELETE_COUNTER_FLAG)
    7700:	80 91 52 0c 	lds	r24, 0x0C52
    7704:	88 23       	and	r24, r24
    7706:	c9 f0       	breq	.+50     	; 0x773a <SENSOR_TIMER3+0x106>
	{
		if (isbitclear(*PORTE_IN_ADDRESS,6))
    7708:	0e 99       	sbic	0x01, 6	; 1
    770a:	11 c0       	rjmp	.+34     	; 0x772e <SENSOR_TIMER3+0xfa>
		{
			DELETE_COUNTER++;
    770c:	80 91 54 0c 	lds	r24, 0x0C54
    7710:	8f 5f       	subi	r24, 0xFF	; 255
    7712:	80 93 54 0c 	sts	0x0C54, r24
			if (DELETE_COUNTER==8)
    7716:	80 91 54 0c 	lds	r24, 0x0C54
    771a:	88 30       	cpi	r24, 0x08	; 8
    771c:	71 f4       	brne	.+28     	; 0x773a <SENSOR_TIMER3+0x106>
			{
				DELETE_COUNTER_FLAG=0;
    771e:	10 92 52 0c 	sts	0x0C52, r1
				DELETE_COUNTER=0;
    7722:	10 92 54 0c 	sts	0x0C54, r1
				DELETE_FLAG=1;
    7726:	81 e0       	ldi	r24, 0x01	; 1
    7728:	80 93 53 0c 	sts	0x0C53, r24
    772c:	08 95       	ret
			}
		}
		else
		{
			DELETE_COUNTER_FLAG=0;		
    772e:	10 92 52 0c 	sts	0x0C52, r1
			DELETE_COUNTER=0;
    7732:	10 92 54 0c 	sts	0x0C54, r1
			DELETE_INT_FLAG=0;
    7736:	10 92 55 0c 	sts	0x0C55, r1
    773a:	08 95       	ret

0000773c <TEST_IO_SETUP>:
	F_B_NEW_USER_PASS=1;
}

void TEST_UART_SEND_ARRAY(char*str,unsigned char LENGTH)
{
	USART0_SEND_ARRAY(str,LENGTH);
    773c:	20 e0       	ldi	r18, 0x00	; 0
    773e:	40 e0       	ldi	r20, 0x00	; 0
    7740:	63 e3       	ldi	r22, 0x33	; 51
    7742:	70 e0       	ldi	r23, 0x00	; 0
    7744:	84 e3       	ldi	r24, 0x34	; 52
    7746:	90 e0       	ldi	r25, 0x00	; 0
    7748:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
    774c:	21 e0       	ldi	r18, 0x01	; 1
    774e:	40 e0       	ldi	r20, 0x00	; 0
    7750:	63 e3       	ldi	r22, 0x33	; 51
    7752:	70 e0       	ldi	r23, 0x00	; 0
    7754:	84 e3       	ldi	r24, 0x34	; 52
    7756:	90 e0       	ldi	r25, 0x00	; 0
    7758:	0e 94 72 08 	call	0x10e4	; 0x10e4 <gpio_outputconfg>
    775c:	22 e0       	ldi	r18, 0x02	; 2
    775e:	40 e0       	ldi	r20, 0x00	; 0
    7760:	63 e3       	ldi	r22, 0x33	; 51
    7762:	70 e0       	ldi	r23, 0x00	; 0
    7764:	84 e3       	ldi	r24, 0x34	; 52
    7766:	90 e0       	ldi	r25, 0x00	; 0
    7768:	0c 94 72 08 	jmp	0x10e4	; 0x10e4 <gpio_outputconfg>
    776c:	08 95       	ret

0000776e <TEST_ADD_SENSOR>:
    776e:	80 91 57 0c 	lds	r24, 0x0C57
    7772:	81 11       	cpse	r24, r1
    7774:	21 c0       	rjmp	.+66     	; 0x77b8 <TEST_ADD_SENSOR+0x4a>
    7776:	80 e5       	ldi	r24, 0x50	; 80
    7778:	80 93 15 0e 	sts	0x0E15, r24
    777c:	80 93 16 0e 	sts	0x0E16, r24
    7780:	80 93 17 0e 	sts	0x0E17, r24
    7784:	80 93 18 0e 	sts	0x0E18, r24
    7788:	80 93 19 0e 	sts	0x0E19, r24
    778c:	87 e4       	ldi	r24, 0x47	; 71
    778e:	80 93 1a 0e 	sts	0x0E1A, r24
    7792:	80 93 1b 0e 	sts	0x0E1B, r24
    7796:	80 93 1c 0e 	sts	0x0E1C, r24
    779a:	80 93 1d 0e 	sts	0x0E1D, r24
    779e:	81 e0       	ldi	r24, 0x01	; 1
    77a0:	80 93 1e 0e 	sts	0x0E1E, r24
    77a4:	93 e0       	ldi	r25, 0x03	; 3
    77a6:	90 93 1f 0e 	sts	0x0E1F, r25
    77aa:	80 93 12 0d 	sts	0x0D12, r24
    77ae:	80 91 57 0c 	lds	r24, 0x0C57
    77b2:	8f 5f       	subi	r24, 0xFF	; 255
    77b4:	80 93 57 0c 	sts	0x0C57, r24
    77b8:	80 91 57 0c 	lds	r24, 0x0C57
    77bc:	81 30       	cpi	r24, 0x01	; 1
    77be:	29 f5       	brne	.+74     	; 0x780a <TEST_ADD_SENSOR+0x9c>
    77c0:	80 91 12 0d 	lds	r24, 0x0D12
    77c4:	81 11       	cpse	r24, r1
    77c6:	21 c0       	rjmp	.+66     	; 0x780a <TEST_ADD_SENSOR+0x9c>
    77c8:	80 e4       	ldi	r24, 0x40	; 64
    77ca:	80 93 15 0e 	sts	0x0E15, r24
    77ce:	80 93 16 0e 	sts	0x0E16, r24
    77d2:	80 93 17 0e 	sts	0x0E17, r24
    77d6:	80 93 18 0e 	sts	0x0E18, r24
    77da:	80 93 19 0e 	sts	0x0E19, r24
    77de:	87 e4       	ldi	r24, 0x47	; 71
    77e0:	80 93 1a 0e 	sts	0x0E1A, r24
    77e4:	80 93 1b 0e 	sts	0x0E1B, r24
    77e8:	80 93 1c 0e 	sts	0x0E1C, r24
    77ec:	80 93 1d 0e 	sts	0x0E1D, r24
    77f0:	81 e0       	ldi	r24, 0x01	; 1
    77f2:	80 93 1e 0e 	sts	0x0E1E, r24
    77f6:	93 e0       	ldi	r25, 0x03	; 3
    77f8:	90 93 1f 0e 	sts	0x0E1F, r25
    77fc:	80 93 12 0d 	sts	0x0D12, r24
    7800:	80 91 57 0c 	lds	r24, 0x0C57
    7804:	8f 5f       	subi	r24, 0xFF	; 255
    7806:	80 93 57 0c 	sts	0x0C57, r24
    780a:	80 91 57 0c 	lds	r24, 0x0C57
    780e:	82 30       	cpi	r24, 0x02	; 2
    7810:	21 f5       	brne	.+72     	; 0x785a <TEST_ADD_SENSOR+0xec>
    7812:	80 91 12 0d 	lds	r24, 0x0D12
    7816:	81 11       	cpse	r24, r1
    7818:	20 c0       	rjmp	.+64     	; 0x785a <TEST_ADD_SENSOR+0xec>
    781a:	80 e3       	ldi	r24, 0x30	; 48
    781c:	80 93 15 0e 	sts	0x0E15, r24
    7820:	80 93 16 0e 	sts	0x0E16, r24
    7824:	80 93 17 0e 	sts	0x0E17, r24
    7828:	80 93 18 0e 	sts	0x0E18, r24
    782c:	80 93 19 0e 	sts	0x0E19, r24
    7830:	87 e4       	ldi	r24, 0x47	; 71
    7832:	80 93 1a 0e 	sts	0x0E1A, r24
    7836:	80 93 1b 0e 	sts	0x0E1B, r24
    783a:	80 93 1c 0e 	sts	0x0E1C, r24
    783e:	80 93 1d 0e 	sts	0x0E1D, r24
    7842:	81 e0       	ldi	r24, 0x01	; 1
    7844:	80 93 1e 0e 	sts	0x0E1E, r24
    7848:	80 93 1f 0e 	sts	0x0E1F, r24
    784c:	80 93 12 0d 	sts	0x0D12, r24
    7850:	80 91 57 0c 	lds	r24, 0x0C57
    7854:	8f 5f       	subi	r24, 0xFF	; 255
    7856:	80 93 57 0c 	sts	0x0C57, r24
    785a:	80 91 57 0c 	lds	r24, 0x0C57
    785e:	83 30       	cpi	r24, 0x03	; 3
    7860:	21 f5       	brne	.+72     	; 0x78aa <TEST_ADD_SENSOR+0x13c>
    7862:	80 91 12 0d 	lds	r24, 0x0D12
    7866:	81 11       	cpse	r24, r1
    7868:	20 c0       	rjmp	.+64     	; 0x78aa <TEST_ADD_SENSOR+0x13c>
    786a:	80 e2       	ldi	r24, 0x20	; 32
    786c:	80 93 15 0e 	sts	0x0E15, r24
    7870:	80 93 16 0e 	sts	0x0E16, r24
    7874:	80 93 17 0e 	sts	0x0E17, r24
    7878:	80 93 18 0e 	sts	0x0E18, r24
    787c:	80 93 19 0e 	sts	0x0E19, r24
    7880:	87 e4       	ldi	r24, 0x47	; 71
    7882:	80 93 1a 0e 	sts	0x0E1A, r24
    7886:	80 93 1b 0e 	sts	0x0E1B, r24
    788a:	80 93 1c 0e 	sts	0x0E1C, r24
    788e:	80 93 1d 0e 	sts	0x0E1D, r24
    7892:	81 e0       	ldi	r24, 0x01	; 1
    7894:	80 93 1e 0e 	sts	0x0E1E, r24
    7898:	80 93 1f 0e 	sts	0x0E1F, r24
    789c:	80 93 12 0d 	sts	0x0D12, r24
    78a0:	80 91 57 0c 	lds	r24, 0x0C57
    78a4:	8f 5f       	subi	r24, 0xFF	; 255
    78a6:	80 93 57 0c 	sts	0x0C57, r24
    78aa:	08 95       	ret

000078ac <TEST_ADD_IOT_PARAMETERS>:
    78ac:	cf 93       	push	r28
    78ae:	df 93       	push	r29
    78b0:	cd b7       	in	r28, 0x3d	; 61
    78b2:	de b7       	in	r29, 0x3e	; 62
    78b4:	e2 97       	sbiw	r28, 0x32	; 50
    78b6:	0f b6       	in	r0, 0x3f	; 63
    78b8:	f8 94       	cli
    78ba:	de bf       	out	0x3e, r29	; 62
    78bc:	0f be       	out	0x3f, r0	; 63
    78be:	cd bf       	out	0x3d, r28	; 61
    78c0:	80 e1       	ldi	r24, 0x10	; 16
    78c2:	ea ee       	ldi	r30, 0xEA	; 234
    78c4:	f3 e0       	ldi	r31, 0x03	; 3
    78c6:	de 01       	movw	r26, r28
    78c8:	12 96       	adiw	r26, 0x02	; 2
    78ca:	01 90       	ld	r0, Z+
    78cc:	0d 92       	st	X+, r0
    78ce:	8a 95       	dec	r24
    78d0:	e1 f7       	brne	.-8      	; 0x78ca <TEST_ADD_IOT_PARAMETERS+0x1e>
    78d2:	81 e2       	ldi	r24, 0x21	; 33
    78d4:	ea ef       	ldi	r30, 0xFA	; 250
    78d6:	f3 e0       	ldi	r31, 0x03	; 3
    78d8:	de 01       	movw	r26, r28
    78da:	52 96       	adiw	r26, 0x12	; 18
    78dc:	01 90       	ld	r0, Z+
    78de:	0d 92       	st	X+, r0
    78e0:	8a 95       	dec	r24
    78e2:	e1 f7       	brne	.-8      	; 0x78dc <TEST_ADD_IOT_PARAMETERS+0x30>
    78e4:	87 e0       	ldi	r24, 0x07	; 7
    78e6:	80 93 e7 10 	sts	0x10E7, r24
    78ea:	19 82       	std	Y+1, r1	; 0x01
    78ec:	89 81       	ldd	r24, Y+1	; 0x01
    78ee:	8a 30       	cpi	r24, 0x0A	; 10
    78f0:	98 f4       	brcc	.+38     	; 0x7918 <TEST_ADD_IOT_PARAMETERS+0x6c>
    78f2:	e9 81       	ldd	r30, Y+1	; 0x01
    78f4:	f0 e0       	ldi	r31, 0x00	; 0
    78f6:	89 81       	ldd	r24, Y+1	; 0x01
    78f8:	a2 e0       	ldi	r26, 0x02	; 2
    78fa:	b0 e0       	ldi	r27, 0x00	; 0
    78fc:	ac 0f       	add	r26, r28
    78fe:	bd 1f       	adc	r27, r29
    7900:	a8 0f       	add	r26, r24
    7902:	b1 1d       	adc	r27, r1
    7904:	8c 91       	ld	r24, X
    7906:	e1 5e       	subi	r30, 0xE1	; 225
    7908:	f0 4f       	sbci	r31, 0xF0	; 240
    790a:	80 83       	st	Z, r24
    790c:	89 81       	ldd	r24, Y+1	; 0x01
    790e:	8f 5f       	subi	r24, 0xFF	; 255
    7910:	89 83       	std	Y+1, r24	; 0x01
    7912:	89 81       	ldd	r24, Y+1	; 0x01
    7914:	8a 30       	cpi	r24, 0x0A	; 10
    7916:	68 f3       	brcs	.-38     	; 0x78f2 <TEST_ADD_IOT_PARAMETERS+0x46>
    7918:	80 e1       	ldi	r24, 0x10	; 16
    791a:	80 93 c4 10 	sts	0x10C4, r24
    791e:	19 82       	std	Y+1, r1	; 0x01
    7920:	89 81       	ldd	r24, Y+1	; 0x01
    7922:	89 31       	cpi	r24, 0x19	; 25
    7924:	98 f4       	brcc	.+38     	; 0x794c <TEST_ADD_IOT_PARAMETERS+0xa0>
    7926:	e9 81       	ldd	r30, Y+1	; 0x01
    7928:	f0 e0       	ldi	r31, 0x00	; 0
    792a:	89 81       	ldd	r24, Y+1	; 0x01
    792c:	a2 e1       	ldi	r26, 0x12	; 18
    792e:	b0 e0       	ldi	r27, 0x00	; 0
    7930:	ac 0f       	add	r26, r28
    7932:	bd 1f       	adc	r27, r29
    7934:	a8 0f       	add	r26, r24
    7936:	b1 1d       	adc	r27, r1
    7938:	8c 91       	ld	r24, X
    793a:	e2 57       	subi	r30, 0x72	; 114
    793c:	ff 4e       	sbci	r31, 0xEF	; 239
    793e:	80 83       	st	Z, r24
    7940:	89 81       	ldd	r24, Y+1	; 0x01
    7942:	8f 5f       	subi	r24, 0xFF	; 255
    7944:	89 83       	std	Y+1, r24	; 0x01
    7946:	89 81       	ldd	r24, Y+1	; 0x01
    7948:	89 31       	cpi	r24, 0x19	; 25
    794a:	68 f3       	brcs	.-38     	; 0x7926 <TEST_ADD_IOT_PARAMETERS+0x7a>
    794c:	81 e0       	ldi	r24, 0x01	; 1
    794e:	80 93 c1 10 	sts	0x10C1, r24
    7952:	80 93 59 0c 	sts	0x0C59, r24
    7956:	e2 96       	adiw	r28, 0x32	; 50
    7958:	0f b6       	in	r0, 0x3f	; 63
    795a:	f8 94       	cli
    795c:	de bf       	out	0x3e, r29	; 62
    795e:	0f be       	out	0x3f, r0	; 63
    7960:	cd bf       	out	0x3d, r28	; 61
    7962:	df 91       	pop	r29
    7964:	cf 91       	pop	r28
    7966:	08 95       	ret

00007968 <TEST_ADD_USER_PASS>:
    7968:	cf 93       	push	r28
    796a:	df 93       	push	r29
    796c:	cd b7       	in	r28, 0x3d	; 61
    796e:	de b7       	in	r29, 0x3e	; 62
    7970:	62 97       	sbiw	r28, 0x12	; 18
    7972:	0f b6       	in	r0, 0x3f	; 63
    7974:	f8 94       	cli
    7976:	de bf       	out	0x3e, r29	; 62
    7978:	0f be       	out	0x3f, r0	; 63
    797a:	cd bf       	out	0x3d, r28	; 61
    797c:	88 e0       	ldi	r24, 0x08	; 8
    797e:	eb e1       	ldi	r30, 0x1B	; 27
    7980:	f4 e0       	ldi	r31, 0x04	; 4
    7982:	de 01       	movw	r26, r28
    7984:	11 96       	adiw	r26, 0x01	; 1
    7986:	01 90       	ld	r0, Z+
    7988:	0d 92       	st	X+, r0
    798a:	8a 95       	dec	r24
    798c:	e1 f7       	brne	.-8      	; 0x7986 <TEST_ADD_USER_PASS+0x1e>
    798e:	8a e0       	ldi	r24, 0x0A	; 10
    7990:	e3 e2       	ldi	r30, 0x23	; 35
    7992:	f4 e0       	ldi	r31, 0x04	; 4
    7994:	de 01       	movw	r26, r28
    7996:	19 96       	adiw	r26, 0x09	; 9
    7998:	01 90       	ld	r0, Z+
    799a:	0d 92       	st	X+, r0
    799c:	8a 95       	dec	r24
    799e:	e1 f7       	brne	.-8      	; 0x7998 <TEST_ADD_USER_PASS+0x30>
    79a0:	20 e0       	ldi	r18, 0x00	; 0
    79a2:	82 2f       	mov	r24, r18
    79a4:	90 e0       	ldi	r25, 0x00	; 0
    79a6:	e1 e0       	ldi	r30, 0x01	; 1
    79a8:	f0 e0       	ldi	r31, 0x00	; 0
    79aa:	ec 0f       	add	r30, r28
    79ac:	fd 1f       	adc	r31, r29
    79ae:	e8 0f       	add	r30, r24
    79b0:	f9 1f       	adc	r31, r25
    79b2:	30 81       	ld	r19, Z
    79b4:	fc 01       	movw	r30, r24
    79b6:	e1 58       	subi	r30, 0x81	; 129
    79b8:	ff 4e       	sbci	r31, 0xEF	; 239
    79ba:	30 83       	st	Z, r19
    79bc:	2f 5f       	subi	r18, 0xFF	; 255
    79be:	e2 2f       	mov	r30, r18
    79c0:	f0 e0       	ldi	r31, 0x00	; 0
    79c2:	31 97       	sbiw	r30, 0x01	; 1
    79c4:	81 e0       	ldi	r24, 0x01	; 1
    79c6:	90 e0       	ldi	r25, 0x00	; 0
    79c8:	8c 0f       	add	r24, r28
    79ca:	9d 1f       	adc	r25, r29
    79cc:	e8 0f       	add	r30, r24
    79ce:	f9 1f       	adc	r31, r25
    79d0:	80 81       	ld	r24, Z
    79d2:	81 11       	cpse	r24, r1
    79d4:	e6 cf       	rjmp	.-52     	; 0x79a2 <TEST_ADD_USER_PASS+0x3a>
    79d6:	20 e0       	ldi	r18, 0x00	; 0
    79d8:	82 2f       	mov	r24, r18
    79da:	90 e0       	ldi	r25, 0x00	; 0
    79dc:	e9 e0       	ldi	r30, 0x09	; 9
    79de:	f0 e0       	ldi	r31, 0x00	; 0
    79e0:	ec 0f       	add	r30, r28
    79e2:	fd 1f       	adc	r31, r29
    79e4:	e8 0f       	add	r30, r24
    79e6:	f9 1f       	adc	r31, r25
    79e8:	30 81       	ld	r19, Z
    79ea:	fc 01       	movw	r30, r24
    79ec:	e9 55       	subi	r30, 0x59	; 89
    79ee:	ff 4e       	sbci	r31, 0xEF	; 239
    79f0:	30 83       	st	Z, r19
    79f2:	2f 5f       	subi	r18, 0xFF	; 255
    79f4:	e2 2f       	mov	r30, r18
    79f6:	f0 e0       	ldi	r31, 0x00	; 0
    79f8:	ea 55       	subi	r30, 0x5A	; 90
    79fa:	ff 4e       	sbci	r31, 0xEF	; 239
    79fc:	80 81       	ld	r24, Z
    79fe:	81 11       	cpse	r24, r1
    7a00:	eb cf       	rjmp	.-42     	; 0x79d8 <TEST_ADD_USER_PASS+0x70>
    7a02:	81 e0       	ldi	r24, 0x01	; 1
    7a04:	80 93 5a 0c 	sts	0x0C5A, r24
    7a08:	62 96       	adiw	r28, 0x12	; 18
    7a0a:	0f b6       	in	r0, 0x3f	; 63
    7a0c:	f8 94       	cli
    7a0e:	de bf       	out	0x3e, r29	; 62
    7a10:	0f be       	out	0x3f, r0	; 63
    7a12:	cd bf       	out	0x3d, r28	; 61
    7a14:	df 91       	pop	r29
    7a16:	cf 91       	pop	r28
    7a18:	08 95       	ret

00007a1a <TEST_UART_SEND_str>:
}

void TEST_UART_SEND_str(char*str)
{
	USART0_SEND_str(str);
    7a1a:	0c 94 95 1f 	jmp	0x3f2a	; 0x3f2a <USART0_SEND_str>
    7a1e:	08 95       	ret

00007a20 <TEST_UART_SEND_byte>:
}

void TEST_UART_SEND_byte(volatile unsigned char byte)
{
    7a20:	cf 93       	push	r28
    7a22:	df 93       	push	r29
    7a24:	1f 92       	push	r1
    7a26:	cd b7       	in	r28, 0x3d	; 61
    7a28:	de b7       	in	r29, 0x3e	; 62
    7a2a:	89 83       	std	Y+1, r24	; 0x01
	USART0_SEND_byte(byte);
    7a2c:	89 81       	ldd	r24, Y+1	; 0x01
    7a2e:	0e 94 f6 1d 	call	0x3bec	; 0x3bec <USART0_SEND_byte>
}
    7a32:	0f 90       	pop	r0
    7a34:	df 91       	pop	r29
    7a36:	cf 91       	pop	r28
    7a38:	08 95       	ret

00007a3a <TEST_UART_SEND_VALUE>:
void TEST_UART_SEND_VALUE(long long X)
{
    7a3a:	0f 93       	push	r16
    7a3c:	1f 93       	push	r17
    7a3e:	cf 93       	push	r28
    7a40:	df 93       	push	r29
    7a42:	cd b7       	in	r28, 0x3d	; 61
    7a44:	de b7       	in	r29, 0x3e	; 62
    7a46:	2f 97       	sbiw	r28, 0x0f	; 15
    7a48:	0f b6       	in	r0, 0x3f	; 63
    7a4a:	f8 94       	cli
    7a4c:	de bf       	out	0x3e, r29	; 62
    7a4e:	0f be       	out	0x3f, r0	; 63
    7a50:	cd bf       	out	0x3d, r28	; 61
	unsigned char VALUE[15];
	USART0_SEND_ARRAY(VALUE,inttostring(VALUE,X));
    7a52:	02 2f       	mov	r16, r18
    7a54:	13 2f       	mov	r17, r19
    7a56:	24 2f       	mov	r18, r20
    7a58:	35 2f       	mov	r19, r21
    7a5a:	46 2f       	mov	r20, r22
    7a5c:	57 2f       	mov	r21, r23
    7a5e:	68 2f       	mov	r22, r24
    7a60:	79 2f       	mov	r23, r25
    7a62:	ce 01       	movw	r24, r28
    7a64:	01 96       	adiw	r24, 0x01	; 1
    7a66:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <inttostring>
    7a6a:	bc 01       	movw	r22, r24
    7a6c:	ce 01       	movw	r24, r28
    7a6e:	01 96       	adiw	r24, 0x01	; 1
    7a70:	0e 94 d3 1f 	call	0x3fa6	; 0x3fa6 <USART0_SEND_ARRAY>
    7a74:	2f 96       	adiw	r28, 0x0f	; 15
    7a76:	0f b6       	in	r0, 0x3f	; 63
    7a78:	f8 94       	cli
    7a7a:	de bf       	out	0x3e, r29	; 62
    7a7c:	0f be       	out	0x3f, r0	; 63
    7a7e:	cd bf       	out	0x3d, r28	; 61
    7a80:	df 91       	pop	r29
    7a82:	cf 91       	pop	r28
    7a84:	1f 91       	pop	r17
    7a86:	0f 91       	pop	r16
    7a88:	08 95       	ret

00007a8a <TIMERS_SETUP>:
#include "TIMER.h"



void TIMERS_SETUP()
{
    7a8a:	8f 92       	push	r8
    7a8c:	af 92       	push	r10
    7a8e:	bf 92       	push	r11
    7a90:	cf 92       	push	r12
    7a92:	df 92       	push	r13
    7a94:	ef 92       	push	r14
    7a96:	ff 92       	push	r15
    7a98:	0f 93       	push	r16
	TIMER0_ENABLE(TIMER_1024,NORMAL_MOD,OC0_DISCONNECTED,OVER_FLOW_INT_ENABLE);
    7a9a:	21 e0       	ldi	r18, 0x01	; 1
    7a9c:	40 e0       	ldi	r20, 0x00	; 0
    7a9e:	60 e0       	ldi	r22, 0x00	; 0
    7aa0:	85 e0       	ldi	r24, 0x05	; 5
    7aa2:	0e 94 19 1d 	call	0x3a32	; 0x3a32 <TIMER0_ENABLE>
	TIMER3_ENABLE(T3_OCA3_DISCONNECT,T3_OCB3_DISCONNECT,T3_OCC3_DISCONNECT,T3_NORMAL,T3_TIMER_64,0,0,0,ENABLE_TIMER3_INT,DISABLE_TIMER3_INT,DISABLE_TIMER3_INT,DISABLE_TIMER3_INT,DISABLE_TIMER3_INT);/*0.25 SEC*/
    7aa6:	1f 92       	push	r1
    7aa8:	1f 92       	push	r1
    7aaa:	1f 92       	push	r1
    7aac:	1f 92       	push	r1
    7aae:	88 24       	eor	r8, r8
    7ab0:	83 94       	inc	r8
    7ab2:	a1 2c       	mov	r10, r1
    7ab4:	b1 2c       	mov	r11, r1
    7ab6:	c1 2c       	mov	r12, r1
    7ab8:	d1 2c       	mov	r13, r1
    7aba:	e1 2c       	mov	r14, r1
    7abc:	f1 2c       	mov	r15, r1
    7abe:	03 e0       	ldi	r16, 0x03	; 3
    7ac0:	20 e0       	ldi	r18, 0x00	; 0
    7ac2:	40 e0       	ldi	r20, 0x00	; 0
    7ac4:	60 e0       	ldi	r22, 0x00	; 0
    7ac6:	80 e0       	ldi	r24, 0x00	; 0
    7ac8:	0e 94 69 1d 	call	0x3ad2	; 0x3ad2 <TIMER3_ENABLE>
		
	global_interupt_enable();
    7acc:	8f b7       	in	r24, 0x3f	; 63
    7ace:	80 68       	ori	r24, 0x80	; 128
    7ad0:	8f bf       	out	0x3f, r24	; 63
    7ad2:	0f 90       	pop	r0
    7ad4:	0f 90       	pop	r0
    7ad6:	0f 90       	pop	r0
    7ad8:	0f 90       	pop	r0
}
    7ada:	0f 91       	pop	r16
    7adc:	ff 90       	pop	r15
    7ade:	ef 90       	pop	r14
    7ae0:	df 90       	pop	r13
    7ae2:	cf 90       	pop	r12
    7ae4:	bf 90       	pop	r11
    7ae6:	af 90       	pop	r10
    7ae8:	8f 90       	pop	r8
    7aea:	08 95       	ret

00007aec <TIMER0_INT_EVENT>:

void TIMER0_INT_EVENT()
{
	LED_GRID_TIMER_INT();
    7aec:	0c 94 fe 05 	jmp	0xbfc	; 0xbfc <LED_GRID_TIMER_INT>
    7af0:	08 95       	ret

00007af2 <TIMER3_INT_EVENT>:
}

void TIMER3_INT_EVENT()
{
	SENSOR_TIMER3();
    7af2:	a0 dd       	rcall	.-1216   	; 0x7634 <SENSOR_TIMER3>
	WIFI_TIMER3();
    7af4:	db c2       	rjmp	.+1462   	; 0x80ac <WIFI_TIMER3>
    7af6:	08 95       	ret

00007af8 <WIFI_SETUP_IO>:



void WIFI_SETUP_IO()
{
	gpio_outputconfg(WIFI_CONNECTED_DDR_ADDRESS,WIFI_CONNECTED_OUTMOD_ADDRESS,OUTPASS,WIFI_CONNECTED_PIN);
    7af8:	24 e0       	ldi	r18, 0x04	; 4
    7afa:	40 e0       	ldi	r20, 0x00	; 0
    7afc:	61 e2       	ldi	r22, 0x21	; 33
    7afe:	70 e0       	ldi	r23, 0x00	; 0
    7b00:	82 e2       	ldi	r24, 0x22	; 34
    7b02:	90 e0       	ldi	r25, 0x00	; 0
    7b04:	0c 94 72 08 	jmp	0x10e4	; 0x10e4 <gpio_outputconfg>
    7b08:	08 95       	ret

00007b0a <WIFI_LOAD_PARAMETERS>:




void WIFI_LOAD_PARAMETERS()
{
    7b0a:	1f 93       	push	r17
    7b0c:	cf 93       	push	r28
    7b0e:	df 93       	push	r29
	/*CHECK USER AND PASS*/
	if (readeeprom(MY_EEPROM_CHECK_AVAILABLE_USER_PASS)==CHECK_AVAILABLE_USER_PASS_VALUE)
    7b10:	80 e0       	ldi	r24, 0x00	; 0
    7b12:	90 e0       	ldi	r25, 0x00	; 0
    7b14:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    7b18:	84 34       	cpi	r24, 0x44	; 68
    7b1a:	a9 f5       	brne	.+106    	; 0x7b86 <WIFI_LOAD_PARAMETERS+0x7c>
	{
		USER_LENGTH=readeeprom(MY_EEPROM_USER_LENGTH);
    7b1c:	81 e0       	ldi	r24, 0x01	; 1
    7b1e:	90 e0       	ldi	r25, 0x00	; 0
    7b20:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    7b24:	80 93 c7 10 	sts	0x10C7, r24
		PASS_LENGTH=readeeprom(MY_EEPROM_PASS_LENGTH);
    7b28:	81 e1       	ldi	r24, 0x11	; 17
    7b2a:	90 e0       	ldi	r25, 0x00	; 0
    7b2c:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    7b30:	80 93 c5 10 	sts	0x10C5, r24
		unsigned char i=0;
		for (i=0;i<USER_LENGTH;++i)
    7b34:	80 91 c7 10 	lds	r24, 0x10C7
    7b38:	88 23       	and	r24, r24
    7b3a:	79 f0       	breq	.+30     	; 0x7b5a <WIFI_LOAD_PARAMETERS+0x50>
    7b3c:	10 e0       	ldi	r17, 0x00	; 0
		{
			USER_NAME[i]=readeeprom(MY_EEPROM_START_OF_USER+i);
    7b3e:	c1 2f       	mov	r28, r17
    7b40:	d0 e0       	ldi	r29, 0x00	; 0
    7b42:	ce 01       	movw	r24, r28
    7b44:	02 96       	adiw	r24, 0x02	; 2
    7b46:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    7b4a:	c0 59       	subi	r28, 0x90	; 144
    7b4c:	df 4e       	sbci	r29, 0xEF	; 239
    7b4e:	88 83       	st	Y, r24
	if (readeeprom(MY_EEPROM_CHECK_AVAILABLE_USER_PASS)==CHECK_AVAILABLE_USER_PASS_VALUE)
	{
		USER_LENGTH=readeeprom(MY_EEPROM_USER_LENGTH);
		PASS_LENGTH=readeeprom(MY_EEPROM_PASS_LENGTH);
		unsigned char i=0;
		for (i=0;i<USER_LENGTH;++i)
    7b50:	1f 5f       	subi	r17, 0xFF	; 255
    7b52:	80 91 c7 10 	lds	r24, 0x10C7
    7b56:	18 17       	cp	r17, r24
    7b58:	90 f3       	brcs	.-28     	; 0x7b3e <WIFI_LOAD_PARAMETERS+0x34>
		{
			USER_NAME[i]=readeeprom(MY_EEPROM_START_OF_USER+i);
		}
		for (i=0;i<PASS_LENGTH;++i)
    7b5a:	80 91 c5 10 	lds	r24, 0x10C5
    7b5e:	88 23       	and	r24, r24
    7b60:	79 f0       	breq	.+30     	; 0x7b80 <WIFI_LOAD_PARAMETERS+0x76>
    7b62:	10 e0       	ldi	r17, 0x00	; 0
		{
			PASSWORD[i]=readeeprom(MY_EEPROM_START_OF_PASS+i);
    7b64:	c1 2f       	mov	r28, r17
    7b66:	d0 e0       	ldi	r29, 0x00	; 0
    7b68:	ce 01       	movw	r24, r28
    7b6a:	42 96       	adiw	r24, 0x12	; 18
    7b6c:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    7b70:	c0 5f       	subi	r28, 0xF0	; 240
    7b72:	d0 4f       	sbci	r29, 0xF0	; 240
    7b74:	88 83       	st	Y, r24
		unsigned char i=0;
		for (i=0;i<USER_LENGTH;++i)
		{
			USER_NAME[i]=readeeprom(MY_EEPROM_START_OF_USER+i);
		}
		for (i=0;i<PASS_LENGTH;++i)
    7b76:	1f 5f       	subi	r17, 0xFF	; 255
    7b78:	80 91 c5 10 	lds	r24, 0x10C5
    7b7c:	18 17       	cp	r17, r24
    7b7e:	90 f3       	brcs	.-28     	; 0x7b64 <WIFI_LOAD_PARAMETERS+0x5a>
		{
			PASSWORD[i]=readeeprom(MY_EEPROM_START_OF_PASS+i);
		}
		F_VALID_USER_PASS=1;
    7b80:	81 e0       	ldi	r24, 0x01	; 1
    7b82:	80 93 b6 10 	sts	0x10B6, r24
	}
	
	
	/*CHECK IOT PAR*/
		if (readeeprom(MY_EEPROM_CHECK_AVAILABLE_IOT_PAR)==CHECK_AVAILABLE_IOT_PAR_VALUE)
    7b86:	81 e2       	ldi	r24, 0x21	; 33
    7b88:	90 e0       	ldi	r25, 0x00	; 0
    7b8a:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    7b8e:	84 34       	cpi	r24, 0x44	; 68
    7b90:	d9 f5       	brne	.+118    	; 0x7c08 <WIFI_LOAD_PARAMETERS+0xfe>
		{
			G_CH_ID_LENGTH=readeeprom(MY_EEPROM_CH_ID_LENGTH);
    7b92:	82 e2       	ldi	r24, 0x22	; 34
    7b94:	90 e0       	ldi	r25, 0x00	; 0
    7b96:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    7b9a:	80 93 e2 10 	sts	0x10E2, r24
			G_WRITE_KEY_LENGTH=readeeprom(MY_EEPROM_WRITE_KEY_LENGTH);
    7b9e:	8d e2       	ldi	r24, 0x2D	; 45
    7ba0:	90 e0       	ldi	r25, 0x00	; 0
    7ba2:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    7ba6:	80 93 e1 10 	sts	0x10E1, r24
			G_FIELD_NUM=readeeprom(MY_EEPROM_FIELD_NUM);
    7baa:	87 e4       	ldi	r24, 0x47	; 71
    7bac:	90 e0       	ldi	r25, 0x00	; 0
    7bae:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    7bb2:	80 93 e4 10 	sts	0x10E4, r24
			
			unsigned char i=0;
			for (i=0;i<G_CH_ID_LENGTH;++i)
    7bb6:	80 91 e2 10 	lds	r24, 0x10E2
    7bba:	88 23       	and	r24, r24
    7bbc:	79 f0       	breq	.+30     	; 0x7bdc <WIFI_LOAD_PARAMETERS+0xd2>
    7bbe:	10 e0       	ldi	r17, 0x00	; 0
			{
				G_CH_ID[i]=readeeprom(MY_EEPROM_START_OF_CH_ID+i);
    7bc0:	c1 2f       	mov	r28, r17
    7bc2:	d0 e0       	ldi	r29, 0x00	; 0
    7bc4:	ce 01       	movw	r24, r28
    7bc6:	83 96       	adiw	r24, 0x23	; 35
    7bc8:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    7bcc:	c9 54       	subi	r28, 0x49	; 73
    7bce:	df 4e       	sbci	r29, 0xEF	; 239
    7bd0:	88 83       	st	Y, r24
			G_CH_ID_LENGTH=readeeprom(MY_EEPROM_CH_ID_LENGTH);
			G_WRITE_KEY_LENGTH=readeeprom(MY_EEPROM_WRITE_KEY_LENGTH);
			G_FIELD_NUM=readeeprom(MY_EEPROM_FIELD_NUM);
			
			unsigned char i=0;
			for (i=0;i<G_CH_ID_LENGTH;++i)
    7bd2:	1f 5f       	subi	r17, 0xFF	; 255
    7bd4:	80 91 e2 10 	lds	r24, 0x10E2
    7bd8:	18 17       	cp	r17, r24
    7bda:	90 f3       	brcs	.-28     	; 0x7bc0 <WIFI_LOAD_PARAMETERS+0xb6>
			{
				G_CH_ID[i]=readeeprom(MY_EEPROM_START_OF_CH_ID+i);
			}
			for (i=0;i<G_WRITE_KEY_LENGTH;++i)
    7bdc:	80 91 e1 10 	lds	r24, 0x10E1
    7be0:	88 23       	and	r24, r24
    7be2:	79 f0       	breq	.+30     	; 0x7c02 <WIFI_LOAD_PARAMETERS+0xf8>
    7be4:	10 e0       	ldi	r17, 0x00	; 0
			{
				G_WRITE_KEY[i]=readeeprom(MY_EEPROM_START_OF_WRITE_KEY+i);
    7be6:	c1 2f       	mov	r28, r17
    7be8:	d0 e0       	ldi	r29, 0x00	; 0
    7bea:	ce 01       	movw	r24, r28
    7bec:	8e 96       	adiw	r24, 0x2e	; 46
    7bee:	0e 94 40 1c 	call	0x3880	; 0x3880 <readeeprom>
    7bf2:	c8 53       	subi	r28, 0x38	; 56
    7bf4:	df 4e       	sbci	r29, 0xEF	; 239
    7bf6:	88 83       	st	Y, r24
			unsigned char i=0;
			for (i=0;i<G_CH_ID_LENGTH;++i)
			{
				G_CH_ID[i]=readeeprom(MY_EEPROM_START_OF_CH_ID+i);
			}
			for (i=0;i<G_WRITE_KEY_LENGTH;++i)
    7bf8:	1f 5f       	subi	r17, 0xFF	; 255
    7bfa:	80 91 e1 10 	lds	r24, 0x10E1
    7bfe:	18 17       	cp	r17, r24
    7c00:	90 f3       	brcs	.-28     	; 0x7be6 <WIFI_LOAD_PARAMETERS+0xdc>
			{
				G_WRITE_KEY[i]=readeeprom(MY_EEPROM_START_OF_WRITE_KEY+i);
			}	
			F_VALID_IOT_PAR=1;
    7c02:	81 e0       	ldi	r24, 0x01	; 1
    7c04:	80 93 e3 10 	sts	0x10E3, r24
			/*ADD LED TO INDICATE CONNECTION TO SERVER*/
		}
		
}
    7c08:	df 91       	pop	r29
    7c0a:	cf 91       	pop	r28
    7c0c:	1f 91       	pop	r17
    7c0e:	08 95       	ret

00007c10 <WIFI_UPDATE_USER_PASS>:

void WIFI_UPDATE_USER_PASS(volatile unsigned char*LOCAL_USER,volatile unsigned char*LOCAL_PASS)  
{
    7c10:	bf 92       	push	r11
    7c12:	cf 92       	push	r12
    7c14:	df 92       	push	r13
    7c16:	ef 92       	push	r14
    7c18:	ff 92       	push	r15
    7c1a:	0f 93       	push	r16
    7c1c:	1f 93       	push	r17
    7c1e:	cf 93       	push	r28
    7c20:	df 93       	push	r29
    7c22:	6c 01       	movw	r12, r24
    7c24:	7b 01       	movw	r14, r22
	unsigned char i=0;
	/*save user name*/
	while(LOCAL_USER[i]!=0)
    7c26:	fc 01       	movw	r30, r24
    7c28:	80 81       	ld	r24, Z
    7c2a:	88 23       	and	r24, r24
    7c2c:	b1 f0       	breq	.+44     	; 0x7c5a <WIFI_UPDATE_USER_PASS+0x4a>
    7c2e:	e6 01       	movw	r28, r12
		
}

void WIFI_UPDATE_USER_PASS(volatile unsigned char*LOCAL_USER,volatile unsigned char*LOCAL_PASS)  
{
	unsigned char i=0;
    7c30:	b1 2c       	mov	r11, r1
	/*save user name*/
	while(LOCAL_USER[i]!=0)
	{
		writeeeprom(MY_EEPROM_START_OF_USER+i,LOCAL_USER[i]);
    7c32:	68 81       	ld	r22, Y
    7c34:	0b 2d       	mov	r16, r11
    7c36:	10 e0       	ldi	r17, 0x00	; 0
    7c38:	c8 01       	movw	r24, r16
    7c3a:	02 96       	adiw	r24, 0x02	; 2
    7c3c:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
		USER_NAME[i]=LOCAL_USER[i];
    7c40:	88 81       	ld	r24, Y
    7c42:	f8 01       	movw	r30, r16
    7c44:	e0 59       	subi	r30, 0x90	; 144
    7c46:	ff 4e       	sbci	r31, 0xEF	; 239
    7c48:	80 83       	st	Z, r24
		i++;
    7c4a:	b3 94       	inc	r11

void WIFI_UPDATE_USER_PASS(volatile unsigned char*LOCAL_USER,volatile unsigned char*LOCAL_PASS)  
{
	unsigned char i=0;
	/*save user name*/
	while(LOCAL_USER[i]!=0)
    7c4c:	e6 01       	movw	r28, r12
    7c4e:	cb 0d       	add	r28, r11
    7c50:	d1 1d       	adc	r29, r1
    7c52:	88 81       	ld	r24, Y
    7c54:	81 11       	cpse	r24, r1
    7c56:	ed cf       	rjmp	.-38     	; 0x7c32 <WIFI_UPDATE_USER_PASS+0x22>
    7c58:	01 c0       	rjmp	.+2      	; 0x7c5c <WIFI_UPDATE_USER_PASS+0x4c>
		
}

void WIFI_UPDATE_USER_PASS(volatile unsigned char*LOCAL_USER,volatile unsigned char*LOCAL_PASS)  
{
	unsigned char i=0;
    7c5a:	b1 2c       	mov	r11, r1
	{
		writeeeprom(MY_EEPROM_START_OF_USER+i,LOCAL_USER[i]);
		USER_NAME[i]=LOCAL_USER[i];
		i++;
	}
	writeeeprom(MY_EEPROM_USER_LENGTH,i);
    7c5c:	6b 2d       	mov	r22, r11
    7c5e:	81 e0       	ldi	r24, 0x01	; 1
    7c60:	90 e0       	ldi	r25, 0x00	; 0
    7c62:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
	USER_LENGTH=i;
    7c66:	b0 92 c7 10 	sts	0x10C7, r11
	/*save user name*/
	i=0;
	while(LOCAL_PASS[i]!=0)
    7c6a:	f7 01       	movw	r30, r14
    7c6c:	80 81       	ld	r24, Z
    7c6e:	88 23       	and	r24, r24
    7c70:	b1 f0       	breq	.+44     	; 0x7c9e <WIFI_UPDATE_USER_PASS+0x8e>
    7c72:	e7 01       	movw	r28, r14
		i++;
	}
	writeeeprom(MY_EEPROM_USER_LENGTH,i);
	USER_LENGTH=i;
	/*save user name*/
	i=0;
    7c74:	d1 2c       	mov	r13, r1
	while(LOCAL_PASS[i]!=0)
	{
		writeeeprom(MY_EEPROM_START_OF_PASS+i,LOCAL_PASS[i]);
    7c76:	68 81       	ld	r22, Y
    7c78:	0d 2d       	mov	r16, r13
    7c7a:	10 e0       	ldi	r17, 0x00	; 0
    7c7c:	c8 01       	movw	r24, r16
    7c7e:	42 96       	adiw	r24, 0x12	; 18
    7c80:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
		PASSWORD[i]=LOCAL_PASS[i];
    7c84:	88 81       	ld	r24, Y
    7c86:	f8 01       	movw	r30, r16
    7c88:	e0 5f       	subi	r30, 0xF0	; 240
    7c8a:	f0 4f       	sbci	r31, 0xF0	; 240
    7c8c:	80 83       	st	Z, r24
		i++;
    7c8e:	d3 94       	inc	r13
	}
	writeeeprom(MY_EEPROM_USER_LENGTH,i);
	USER_LENGTH=i;
	/*save user name*/
	i=0;
	while(LOCAL_PASS[i]!=0)
    7c90:	e7 01       	movw	r28, r14
    7c92:	cd 0d       	add	r28, r13
    7c94:	d1 1d       	adc	r29, r1
    7c96:	88 81       	ld	r24, Y
    7c98:	81 11       	cpse	r24, r1
    7c9a:	ed cf       	rjmp	.-38     	; 0x7c76 <WIFI_UPDATE_USER_PASS+0x66>
    7c9c:	01 c0       	rjmp	.+2      	; 0x7ca0 <WIFI_UPDATE_USER_PASS+0x90>
		i++;
	}
	writeeeprom(MY_EEPROM_USER_LENGTH,i);
	USER_LENGTH=i;
	/*save user name*/
	i=0;
    7c9e:	d1 2c       	mov	r13, r1
	{
		writeeeprom(MY_EEPROM_START_OF_PASS+i,LOCAL_PASS[i]);
		PASSWORD[i]=LOCAL_PASS[i];
		i++;
	}
	writeeeprom(MY_EEPROM_PASS_LENGTH,i);
    7ca0:	6d 2d       	mov	r22, r13
    7ca2:	81 e1       	ldi	r24, 0x11	; 17
    7ca4:	90 e0       	ldi	r25, 0x00	; 0
    7ca6:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
	PASS_LENGTH=i;
    7caa:	d0 92 c5 10 	sts	0x10C5, r13
	writeeeprom(MY_EEPROM_CHECK_AVAILABLE_USER_PASS,CHECK_AVAILABLE_USER_PASS_VALUE);	
    7cae:	64 e4       	ldi	r22, 0x44	; 68
    7cb0:	80 e0       	ldi	r24, 0x00	; 0
    7cb2:	90 e0       	ldi	r25, 0x00	; 0
    7cb4:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
	F_VALID_USER_PASS=1;
    7cb8:	81 e0       	ldi	r24, 0x01	; 1
    7cba:	80 93 b6 10 	sts	0x10B6, r24
}
    7cbe:	df 91       	pop	r29
    7cc0:	cf 91       	pop	r28
    7cc2:	1f 91       	pop	r17
    7cc4:	0f 91       	pop	r16
    7cc6:	ff 90       	pop	r15
    7cc8:	ef 90       	pop	r14
    7cca:	df 90       	pop	r13
    7ccc:	cf 90       	pop	r12
    7cce:	bf 90       	pop	r11
    7cd0:	08 95       	ret

00007cd2 <WIFI_UPDATE_IOT_PAR>:

void WIFI_UPDATE_IOT_PAR(volatile unsigned char *CHANNEL_ID,volatile unsigned char CHANNEL_ID_LENGTH,volatile unsigned char *API_WRITE_KEY,volatile unsigned char API_WRITE_KEY_LENGTH,volatile unsigned char FIELD_NUM)
{
    7cd2:	9f 92       	push	r9
    7cd4:	af 92       	push	r10
    7cd6:	bf 92       	push	r11
    7cd8:	cf 92       	push	r12
    7cda:	df 92       	push	r13
    7cdc:	ef 92       	push	r14
    7cde:	ff 92       	push	r15
    7ce0:	0f 93       	push	r16
    7ce2:	1f 93       	push	r17
    7ce4:	cf 93       	push	r28
    7ce6:	df 93       	push	r29
    7ce8:	00 d0       	rcall	.+0      	; 0x7cea <WIFI_UPDATE_IOT_PAR+0x18>
    7cea:	1f 92       	push	r1
    7cec:	cd b7       	in	r28, 0x3d	; 61
    7cee:	de b7       	in	r29, 0x3e	; 62
    7cf0:	5c 01       	movw	r10, r24
    7cf2:	69 83       	std	Y+1, r22	; 0x01
    7cf4:	6a 01       	movw	r12, r20
    7cf6:	2a 83       	std	Y+2, r18	; 0x02
    7cf8:	0b 83       	std	Y+3, r16	; 0x03
	unsigned char i=0;
	/*save channel id*/
	for(i=0;i<CHANNEL_ID_LENGTH;i++)
    7cfa:	89 81       	ldd	r24, Y+1	; 0x01
    7cfc:	88 23       	and	r24, r24
    7cfe:	b9 f0       	breq	.+46     	; 0x7d2e <WIFI_UPDATE_IOT_PAR+0x5c>
    7d00:	91 2c       	mov	r9, r1
	{
		writeeeprom(MY_EEPROM_START_OF_CH_ID+i,CHANNEL_ID[i]);
    7d02:	09 2d       	mov	r16, r9
    7d04:	10 e0       	ldi	r17, 0x00	; 0
    7d06:	75 01       	movw	r14, r10
    7d08:	e0 0e       	add	r14, r16
    7d0a:	f1 1e       	adc	r15, r17
    7d0c:	f7 01       	movw	r30, r14
    7d0e:	60 81       	ld	r22, Z
    7d10:	c8 01       	movw	r24, r16
    7d12:	83 96       	adiw	r24, 0x23	; 35
    7d14:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
		G_CH_ID[i]=CHANNEL_ID[i];
    7d18:	f7 01       	movw	r30, r14
    7d1a:	80 81       	ld	r24, Z
    7d1c:	f8 01       	movw	r30, r16
    7d1e:	e9 54       	subi	r30, 0x49	; 73
    7d20:	ff 4e       	sbci	r31, 0xEF	; 239
    7d22:	80 83       	st	Z, r24

void WIFI_UPDATE_IOT_PAR(volatile unsigned char *CHANNEL_ID,volatile unsigned char CHANNEL_ID_LENGTH,volatile unsigned char *API_WRITE_KEY,volatile unsigned char API_WRITE_KEY_LENGTH,volatile unsigned char FIELD_NUM)
{
	unsigned char i=0;
	/*save channel id*/
	for(i=0;i<CHANNEL_ID_LENGTH;i++)
    7d24:	93 94       	inc	r9
    7d26:	89 81       	ldd	r24, Y+1	; 0x01
    7d28:	98 16       	cp	r9, r24
    7d2a:	58 f3       	brcs	.-42     	; 0x7d02 <WIFI_UPDATE_IOT_PAR+0x30>
    7d2c:	01 c0       	rjmp	.+2      	; 0x7d30 <WIFI_UPDATE_IOT_PAR+0x5e>
    7d2e:	91 2c       	mov	r9, r1
	{
		writeeeprom(MY_EEPROM_START_OF_CH_ID+i,CHANNEL_ID[i]);
		G_CH_ID[i]=CHANNEL_ID[i];
	}
	writeeeprom(MY_EEPROM_CH_ID_LENGTH,i);
    7d30:	69 2d       	mov	r22, r9
    7d32:	82 e2       	ldi	r24, 0x22	; 34
    7d34:	90 e0       	ldi	r25, 0x00	; 0
    7d36:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
	G_CH_ID_LENGTH=i;
    7d3a:	90 92 e2 10 	sts	0x10E2, r9
	/*save write api key*/
	
	for(i=0;i<API_WRITE_KEY_LENGTH;i++)
    7d3e:	8a 81       	ldd	r24, Y+2	; 0x02
    7d40:	88 23       	and	r24, r24
    7d42:	b9 f0       	breq	.+46     	; 0x7d72 <WIFI_UPDATE_IOT_PAR+0xa0>
    7d44:	b1 2c       	mov	r11, r1
	{
		writeeeprom(MY_EEPROM_START_OF_WRITE_KEY+i,API_WRITE_KEY[i]);
    7d46:	0b 2d       	mov	r16, r11
    7d48:	10 e0       	ldi	r17, 0x00	; 0
    7d4a:	76 01       	movw	r14, r12
    7d4c:	e0 0e       	add	r14, r16
    7d4e:	f1 1e       	adc	r15, r17
    7d50:	f7 01       	movw	r30, r14
    7d52:	60 81       	ld	r22, Z
    7d54:	c8 01       	movw	r24, r16
    7d56:	8e 96       	adiw	r24, 0x2e	; 46
    7d58:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
		G_WRITE_KEY[i]=API_WRITE_KEY[i];
    7d5c:	f7 01       	movw	r30, r14
    7d5e:	80 81       	ld	r24, Z
    7d60:	f8 01       	movw	r30, r16
    7d62:	e8 53       	subi	r30, 0x38	; 56
    7d64:	ff 4e       	sbci	r31, 0xEF	; 239
    7d66:	80 83       	st	Z, r24
	}
	writeeeprom(MY_EEPROM_CH_ID_LENGTH,i);
	G_CH_ID_LENGTH=i;
	/*save write api key*/
	
	for(i=0;i<API_WRITE_KEY_LENGTH;i++)
    7d68:	b3 94       	inc	r11
    7d6a:	8a 81       	ldd	r24, Y+2	; 0x02
    7d6c:	b8 16       	cp	r11, r24
    7d6e:	58 f3       	brcs	.-42     	; 0x7d46 <WIFI_UPDATE_IOT_PAR+0x74>
    7d70:	01 c0       	rjmp	.+2      	; 0x7d74 <WIFI_UPDATE_IOT_PAR+0xa2>
    7d72:	b1 2c       	mov	r11, r1
	{
		writeeeprom(MY_EEPROM_START_OF_WRITE_KEY+i,API_WRITE_KEY[i]);
		G_WRITE_KEY[i]=API_WRITE_KEY[i];
	}
	writeeeprom(MY_EEPROM_WRITE_KEY_LENGTH,i);
    7d74:	6b 2d       	mov	r22, r11
    7d76:	8d e2       	ldi	r24, 0x2D	; 45
    7d78:	90 e0       	ldi	r25, 0x00	; 0
    7d7a:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
	G_WRITE_KEY_LENGTH=i;
    7d7e:	b0 92 e1 10 	sts	0x10E1, r11
	/*save field*/
	writeeeprom(MY_EEPROM_FIELD_NUM,FIELD_NUM);
    7d82:	6b 81       	ldd	r22, Y+3	; 0x03
    7d84:	87 e4       	ldi	r24, 0x47	; 71
    7d86:	90 e0       	ldi	r25, 0x00	; 0
    7d88:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
	G_FIELD_NUM=FIELD_NUM;
    7d8c:	8b 81       	ldd	r24, Y+3	; 0x03
    7d8e:	80 93 e4 10 	sts	0x10E4, r24
	writeeeprom(MY_EEPROM_CHECK_AVAILABLE_IOT_PAR,CHECK_AVAILABLE_IOT_PAR_VALUE);
    7d92:	64 e4       	ldi	r22, 0x44	; 68
    7d94:	81 e2       	ldi	r24, 0x21	; 33
    7d96:	90 e0       	ldi	r25, 0x00	; 0
    7d98:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
	F_VALID_IOT_PAR=1;
    7d9c:	81 e0       	ldi	r24, 0x01	; 1
    7d9e:	80 93 e3 10 	sts	0x10E3, r24
	/*ADD LED TO INDICATE CONNECTION TO SERVER*/
}
    7da2:	0f 90       	pop	r0
    7da4:	0f 90       	pop	r0
    7da6:	0f 90       	pop	r0
    7da8:	df 91       	pop	r29
    7daa:	cf 91       	pop	r28
    7dac:	1f 91       	pop	r17
    7dae:	0f 91       	pop	r16
    7db0:	ff 90       	pop	r15
    7db2:	ef 90       	pop	r14
    7db4:	df 90       	pop	r13
    7db6:	cf 90       	pop	r12
    7db8:	bf 90       	pop	r11
    7dba:	af 90       	pop	r10
    7dbc:	9f 90       	pop	r9
    7dbe:	08 95       	ret

00007dc0 <WIFI_LOOP>:
}



void WIFI_LOOP()
{
    7dc0:	ef 92       	push	r14
    7dc2:	ff 92       	push	r15
    7dc4:	0f 93       	push	r16
    7dc6:	1f 93       	push	r17
    7dc8:	cf 93       	push	r28
    7dca:	df 93       	push	r29
    7dcc:	1f 92       	push	r1
    7dce:	cd b7       	in	r28, 0x3d	; 61
    7dd0:	de b7       	in	r29, 0x3e	; 62
	/*to connect*/
	if (!F_WIFI_CONNECTED)
    7dd2:	80 91 5b 0c 	lds	r24, 0x0C5B
    7dd6:	81 11       	cpse	r24, r1
    7dd8:	2d c0       	rjmp	.+90     	; 0x7e34 <WIFI_LOOP+0x74>
	{
		clearbit(*WIFI_CONNECTED_OUT_ADDRESS,WIFI_CONNECTED_PIN);
    7dda:	1c 98       	cbi	0x03, 4	; 3
		if (F_T_TRY_TO_CONNECT==MAX_F_T_TRY_TO_CONNECT)
    7ddc:	80 91 c2 10 	lds	r24, 0x10C2
    7de0:	84 31       	cpi	r24, 0x14	; 20
    7de2:	09 f0       	breq	.+2      	; 0x7de6 <WIFI_LOOP+0x26>
    7de4:	bd c0       	rjmp	.+378    	; 0x7f60 <WIFI_LOOP+0x1a0>
		{
			F_T_TRY_TO_CONNECT=0;
    7de6:	10 92 c2 10 	sts	0x10C2, r1
			if (F_VALID_USER_PASS)
    7dea:	80 91 b6 10 	lds	r24, 0x10B6
    7dee:	88 23       	and	r24, r24
    7df0:	09 f4       	brne	.+2      	; 0x7df4 <WIFI_LOOP+0x34>
    7df2:	b6 c0       	rjmp	.+364    	; 0x7f60 <WIFI_LOOP+0x1a0>
			{
				unsigned char LOCAL_CONNECTION_STATE=0;			
    7df4:	19 82       	std	Y+1, r1	; 0x01
				TEST_UART_SEND_str("ap try to connect\n");
    7df6:	8d e2       	ldi	r24, 0x2D	; 45
    7df8:	94 e0       	ldi	r25, 0x04	; 4
    7dfa:	0f de       	rcall	.-994    	; 0x7a1a <TEST_UART_SEND_str>
				if (ESP_CONNECT_AP(USER_NAME,USER_LENGTH,PASSWORD,PASS_LENGTH,&LOCAL_CONNECTION_STATE)==0)
    7dfc:	20 91 c5 10 	lds	r18, 0x10C5
    7e00:	60 91 c7 10 	lds	r22, 0x10C7
    7e04:	8e 01       	movw	r16, r28
    7e06:	0f 5f       	subi	r16, 0xFF	; 255
    7e08:	1f 4f       	sbci	r17, 0xFF	; 255
    7e0a:	40 e1       	ldi	r20, 0x10	; 16
    7e0c:	5f e0       	ldi	r21, 0x0F	; 15
    7e0e:	80 e7       	ldi	r24, 0x70	; 112
    7e10:	90 e1       	ldi	r25, 0x10	; 16
    7e12:	0e 94 8c 0a 	call	0x1518	; 0x1518 <ESP_CONNECT_AP>
    7e16:	81 11       	cpse	r24, r1
    7e18:	a3 c0       	rjmp	.+326    	; 0x7f60 <WIFI_LOOP+0x1a0>
				{
					if (LOCAL_CONNECTION_STATE==1)
    7e1a:	89 81       	ldd	r24, Y+1	; 0x01
    7e1c:	81 30       	cpi	r24, 0x01	; 1
    7e1e:	41 f4       	brne	.+16     	; 0x7e30 <WIFI_LOOP+0x70>
					{
						TEST_UART_SEND_str("ap connected\n");
    7e20:	80 e4       	ldi	r24, 0x40	; 64
    7e22:	94 e0       	ldi	r25, 0x04	; 4
    7e24:	fa dd       	rcall	.-1036   	; 0x7a1a <TEST_UART_SEND_str>
						setbit(*WIFI_CONNECTED_OUT_ADDRESS,WIFI_CONNECTED_PIN);
    7e26:	1c 9a       	sbi	0x03, 4	; 3
						F_WIFI_CONNECTED=1;
    7e28:	81 e0       	ldi	r24, 0x01	; 1
    7e2a:	80 93 5b 0c 	sts	0x0C5B, r24
    7e2e:	98 c0       	rjmp	.+304    	; 0x7f60 <WIFI_LOOP+0x1a0>
						/*ADD LED TO INDICATE CONNECTION TO AP*/
					}
					else
					{
						/*TEST_UART_SEND_str("ap not connected\n");*/
						clearbit(*WIFI_CONNECTED_OUT_ADDRESS,WIFI_CONNECTED_PIN);
    7e30:	1c 98       	cbi	0x03, 4	; 3
    7e32:	96 c0       	rjmp	.+300    	; 0x7f60 <WIFI_LOOP+0x1a0>
			}
		}
	}
	else
	{
		setbit(*WIFI_CONNECTED_OUT_ADDRESS,WIFI_CONNECTED_PIN);
    7e34:	1c 9a       	sbi	0x03, 4	; 3
		/*to read*/
		if(F_T_READY_TO_READ==MAX_T_READY_TO_READ)
    7e36:	80 91 c3 10 	lds	r24, 0x10C3
    7e3a:	82 30       	cpi	r24, 0x02	; 2
    7e3c:	61 f5       	brne	.+88     	; 0x7e96 <WIFI_LOOP+0xd6>
		{
			if(F_VALID_IOT_PAR)
    7e3e:	80 91 e3 10 	lds	r24, 0x10E3
    7e42:	88 23       	and	r24, r24
    7e44:	41 f1       	breq	.+80     	; 0x7e96 <WIFI_LOOP+0xd6>
			{
				if(!F_LAST_RECIVED_DATA_NOT_HANDLED)
    7e46:	80 91 c6 10 	lds	r24, 0x10C6
    7e4a:	81 11       	cpse	r24, r1
    7e4c:	24 c0       	rjmp	.+72     	; 0x7e96 <WIFI_LOOP+0xd6>
				{
					
					/*TEST_UART_SEND_str("READ SERVER\n");*/
					F_T_READY_TO_READ=0;
    7e4e:	10 92 c3 10 	sts	0x10C3, r1
					if(ESP_READ_HTTP(G_CH_ID , G_CH_ID_LENGTH,G_FIELD_NUM,G_RECIVED_DATA)==0)
    7e52:	40 91 e4 10 	lds	r20, 0x10E4
    7e56:	60 91 e2 10 	lds	r22, 0x10E2
    7e5a:	25 e7       	ldi	r18, 0x75	; 117
    7e5c:	3e e0       	ldi	r19, 0x0E	; 14
    7e5e:	87 eb       	ldi	r24, 0xB7	; 183
    7e60:	90 e1       	ldi	r25, 0x10	; 16
    7e62:	0e 94 2e 0d 	call	0x1a5c	; 0x1a5c <ESP_READ_HTTP>
    7e66:	81 11       	cpse	r24, r1
    7e68:	09 c0       	rjmp	.+18     	; 0x7e7c <WIFI_LOOP+0xbc>
						TEST_UART_SEND_str("\n");
						TEST_UART_SEND_ARRAY(G_RECIVED_DATA[3].DATA_ELEMENT,G_RECIVED_DATA[3].length);
						TEST_UART_SEND_str("\n");
						TEST_UART_SEND_ARRAY(G_RECIVED_DATA[4].DATA_ELEMENT,G_RECIVED_DATA[4].length);
						TEST_UART_SEND_str("\n");	*/				
							TEST_UART_SEND_str("DATA READ FROM SERVER\n");
    7e6a:	8e e4       	ldi	r24, 0x4E	; 78
    7e6c:	94 e0       	ldi	r25, 0x04	; 4
    7e6e:	d5 dd       	rcall	.-1110   	; 0x7a1a <TEST_UART_SEND_str>
						
						/*****************************/
						FAILED_READ_HTTP_COUNTER=0;
    7e70:	10 92 58 0c 	sts	0x0C58, r1
						F_LAST_RECIVED_DATA_NOT_HANDLED=1;/*MAKE SENSOR WORK ON IT*/
    7e74:	81 e0       	ldi	r24, 0x01	; 1
    7e76:	80 93 c6 10 	sts	0x10C6, r24
    7e7a:	0d c0       	rjmp	.+26     	; 0x7e96 <WIFI_LOOP+0xd6>
					}	
					else
					{
						FAILED_READ_HTTP_COUNTER++;
    7e7c:	80 91 58 0c 	lds	r24, 0x0C58
    7e80:	8f 5f       	subi	r24, 0xFF	; 255
    7e82:	80 93 58 0c 	sts	0x0C58, r24
						/*ADD LED ERROR SERVER*/
						if(FAILED_READ_HTTP_COUNTER==FAILED_READ_HTTP_COUNTER_MAX)
    7e86:	80 91 58 0c 	lds	r24, 0x0C58
    7e8a:	85 30       	cpi	r24, 0x05	; 5
    7e8c:	21 f4       	brne	.+8      	; 0x7e96 <WIFI_LOOP+0xd6>
						{
							FAILED_READ_HTTP_COUNTER=0;
    7e8e:	10 92 58 0c 	sts	0x0C58, r1
							F_WIFI_CONNECTED=0;
    7e92:	10 92 5b 0c 	sts	0x0C5B, r1
				}
			}
			
		}
		/*to send*/
		if(F_T_READY_TO_SEND==MAX_T_READY_TO_SEND)
    7e96:	80 91 e8 10 	lds	r24, 0x10E8
    7e9a:	84 30       	cpi	r24, 0x04	; 4
    7e9c:	09 f0       	breq	.+2      	; 0x7ea0 <WIFI_LOOP+0xe0>
    7e9e:	60 c0       	rjmp	.+192    	; 0x7f60 <WIFI_LOOP+0x1a0>
		{
			if(F_VALID_IOT_PAR)
    7ea0:	80 91 e3 10 	lds	r24, 0x10E3
    7ea4:	88 23       	and	r24, r24
    7ea6:	09 f4       	brne	.+2      	; 0x7eaa <WIFI_LOOP+0xea>
    7ea8:	5b c0       	rjmp	.+182    	; 0x7f60 <WIFI_LOOP+0x1a0>
			{
				if(G_SEND_DATA_QUEUE.COUNT!=0)
    7eaa:	80 91 2b 0f 	lds	r24, 0x0F2B
    7eae:	88 23       	and	r24, r24
    7eb0:	09 f4       	brne	.+2      	; 0x7eb4 <WIFI_LOOP+0xf4>
    7eb2:	56 c0       	rjmp	.+172    	; 0x7f60 <WIFI_LOOP+0x1a0>
				{
					unsigned char *LOCAL_DATA_SEND;
					unsigned char LOCAL_DATA_SEND_LENGTH=0;
					TEST_UART_SEND_str("WRITE\n");
    7eb4:	85 e6       	ldi	r24, 0x65	; 101
    7eb6:	94 e0       	ldi	r25, 0x04	; 4
    7eb8:	b0 dd       	rcall	.-1184   	; 0x7a1a <TEST_UART_SEND_str>
					xSemaphoreTake(QUEUE_SEMAPHORE,portMAX_DELAY);
    7eba:	4f ef       	ldi	r20, 0xFF	; 255
    7ebc:	5f ef       	ldi	r21, 0xFF	; 255
    7ebe:	ba 01       	movw	r22, r20
    7ec0:	80 91 71 0e 	lds	r24, 0x0E71
    7ec4:	90 91 72 0e 	lds	r25, 0x0E72
    7ec8:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
					LOCAL_DATA_SEND=QUEUE_GET_FRONT_ARRAY_U8(&G_SEND_DATA_QUEUE);
    7ecc:	89 e2       	ldi	r24, 0x29	; 41
    7ece:	9f e0       	ldi	r25, 0x0F	; 15
    7ed0:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <QUEUE_GET_FRONT_ARRAY_U8>
    7ed4:	7c 01       	movw	r14, r24
					xSemaphoreGive(QUEUE_SEMAPHORE);
    7ed6:	00 e0       	ldi	r16, 0x00	; 0
    7ed8:	20 e0       	ldi	r18, 0x00	; 0
    7eda:	30 e0       	ldi	r19, 0x00	; 0
    7edc:	a9 01       	movw	r20, r18
    7ede:	60 e0       	ldi	r22, 0x00	; 0
    7ee0:	70 e0       	ldi	r23, 0x00	; 0
    7ee2:	80 91 71 0e 	lds	r24, 0x0E71
    7ee6:	90 91 72 0e 	lds	r25, 0x0E72
    7eea:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <xQueueGenericSend>
					while (LOCAL_DATA_SEND[LOCAL_DATA_SEND_LENGTH]!=0)
    7eee:	f7 01       	movw	r30, r14
    7ef0:	80 81       	ld	r24, Z
    7ef2:	88 23       	and	r24, r24
    7ef4:	41 f0       	breq	.+16     	; 0x7f06 <WIFI_LOOP+0x146>
					{
						LOCAL_DATA_SEND_LENGTH++;
    7ef6:	0f 5f       	subi	r16, 0xFF	; 255
					unsigned char LOCAL_DATA_SEND_LENGTH=0;
					TEST_UART_SEND_str("WRITE\n");
					xSemaphoreTake(QUEUE_SEMAPHORE,portMAX_DELAY);
					LOCAL_DATA_SEND=QUEUE_GET_FRONT_ARRAY_U8(&G_SEND_DATA_QUEUE);
					xSemaphoreGive(QUEUE_SEMAPHORE);
					while (LOCAL_DATA_SEND[LOCAL_DATA_SEND_LENGTH]!=0)
    7ef8:	f7 01       	movw	r30, r14
    7efa:	e0 0f       	add	r30, r16
    7efc:	f1 1d       	adc	r31, r1
    7efe:	80 81       	ld	r24, Z
    7f00:	81 11       	cpse	r24, r1
    7f02:	f9 cf       	rjmp	.-14     	; 0x7ef6 <WIFI_LOOP+0x136>
    7f04:	01 c0       	rjmp	.+2      	; 0x7f08 <WIFI_LOOP+0x148>
			if(F_VALID_IOT_PAR)
			{
				if(G_SEND_DATA_QUEUE.COUNT!=0)
				{
					unsigned char *LOCAL_DATA_SEND;
					unsigned char LOCAL_DATA_SEND_LENGTH=0;
    7f06:	00 e0       	ldi	r16, 0x00	; 0
					xSemaphoreGive(QUEUE_SEMAPHORE);
					while (LOCAL_DATA_SEND[LOCAL_DATA_SEND_LENGTH]!=0)
					{
						LOCAL_DATA_SEND_LENGTH++;
					}
					F_T_READY_TO_SEND=0;
    7f08:	10 92 e8 10 	sts	0x10E8, r1
					TEST_UART_SEND_str("WRITE1\n");
    7f0c:	8c e6       	ldi	r24, 0x6C	; 108
    7f0e:	94 e0       	ldi	r25, 0x04	; 4
    7f10:	84 dd       	rcall	.-1272   	; 0x7a1a <TEST_UART_SEND_str>
					if(ESP_WRITE_HTTP(G_WRITE_KEY,G_WRITE_KEY_LENGTH,G_FIELD_NUM,LOCAL_DATA_SEND,LOCAL_DATA_SEND_LENGTH)==0)
    7f12:	40 91 e4 10 	lds	r20, 0x10E4
    7f16:	60 91 e1 10 	lds	r22, 0x10E1
    7f1a:	97 01       	movw	r18, r14
    7f1c:	88 ec       	ldi	r24, 0xC8	; 200
    7f1e:	90 e1       	ldi	r25, 0x10	; 16
    7f20:	0e 94 a4 0b 	call	0x1748	; 0x1748 <ESP_WRITE_HTTP>
    7f24:	81 11       	cpse	r24, r1
    7f26:	1a c0       	rjmp	.+52     	; 0x7f5c <WIFI_LOOP+0x19c>
					{
						xSemaphoreTake(QUEUE_SEMAPHORE,portMAX_DELAY);
    7f28:	4f ef       	ldi	r20, 0xFF	; 255
    7f2a:	5f ef       	ldi	r21, 0xFF	; 255
    7f2c:	ba 01       	movw	r22, r20
    7f2e:	80 91 71 0e 	lds	r24, 0x0E71
    7f32:	90 91 72 0e 	lds	r25, 0x0E72
    7f36:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
						QUEUE_DELETE_FRONT_ARRAY_U8(&G_SEND_DATA_QUEUE);
    7f3a:	89 e2       	ldi	r24, 0x29	; 41
    7f3c:	9f e0       	ldi	r25, 0x0F	; 15
    7f3e:	0e 94 8a 05 	call	0xb14	; 0xb14 <QUEUE_DELETE_FRONT_ARRAY_U8>
						xSemaphoreGive(QUEUE_SEMAPHORE);
    7f42:	00 e0       	ldi	r16, 0x00	; 0
    7f44:	20 e0       	ldi	r18, 0x00	; 0
    7f46:	30 e0       	ldi	r19, 0x00	; 0
    7f48:	a9 01       	movw	r20, r18
    7f4a:	60 e0       	ldi	r22, 0x00	; 0
    7f4c:	70 e0       	ldi	r23, 0x00	; 0
    7f4e:	80 91 71 0e 	lds	r24, 0x0E71
    7f52:	90 91 72 0e 	lds	r25, 0x0E72
    7f56:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <xQueueGenericSend>
    7f5a:	02 c0       	rjmp	.+4      	; 0x7f60 <WIFI_LOOP+0x1a0>
					}
					else
					{
						F_WIFI_CONNECTED=0;
    7f5c:	10 92 5b 0c 	sts	0x0C5B, r1
			}
		}

	}
	
	if(F_B_NEW_USER_PASS)
    7f60:	80 91 5a 0c 	lds	r24, 0x0C5A
    7f64:	88 23       	and	r24, r24
    7f66:	39 f0       	breq	.+14     	; 0x7f76 <WIFI_LOOP+0x1b6>
	{
		F_B_NEW_USER_PASS=0;
    7f68:	10 92 5a 0c 	sts	0x0C5A, r1
		WIFI_UPDATE_USER_PASS(F_B_USER_NAME,F_B_PASSWORD);
    7f6c:	67 ea       	ldi	r22, 0xA7	; 167
    7f6e:	70 e1       	ldi	r23, 0x10	; 16
    7f70:	8f e7       	ldi	r24, 0x7F	; 127
    7f72:	90 e1       	ldi	r25, 0x10	; 16
    7f74:	4d de       	rcall	.-870    	; 0x7c10 <WIFI_UPDATE_USER_PASS>
	}
	
	if(F_B_NEW_IOT_PAR)
    7f76:	80 91 59 0c 	lds	r24, 0x0C59
    7f7a:	88 23       	and	r24, r24
    7f7c:	69 f0       	breq	.+26     	; 0x7f98 <WIFI_LOOP+0x1d8>
	{
		F_B_NEW_IOT_PAR=0;
    7f7e:	10 92 59 0c 	sts	0x0C59, r1
		WIFI_UPDATE_IOT_PAR(F_B_CH_ID,F_B_CH_ID_LENGTH,F_B_WRITE_KEY,F_B_WRITE_KEY_LENGTH,F_B_FIELD_NUM);
    7f82:	00 91 c1 10 	lds	r16, 0x10C1
    7f86:	20 91 c4 10 	lds	r18, 0x10C4
    7f8a:	60 91 e7 10 	lds	r22, 0x10E7
    7f8e:	4e e8       	ldi	r20, 0x8E	; 142
    7f90:	50 e1       	ldi	r21, 0x10	; 16
    7f92:	8f e1       	ldi	r24, 0x1F	; 31
    7f94:	9f e0       	ldi	r25, 0x0F	; 15
    7f96:	9d de       	rcall	.-710    	; 0x7cd2 <WIFI_UPDATE_IOT_PAR>
	}
}
    7f98:	0f 90       	pop	r0
    7f9a:	df 91       	pop	r29
    7f9c:	cf 91       	pop	r28
    7f9e:	1f 91       	pop	r17
    7fa0:	0f 91       	pop	r16
    7fa2:	ff 90       	pop	r15
    7fa4:	ef 90       	pop	r14
    7fa6:	08 95       	ret

00007fa8 <WIFI_TASK>:
volatile QueueHandle_t RX_ESP_QUEUE;
void WIFI_TASK(void * pd)
{
	/*RX_ESP_SEMAPHORE=xSemaphoreCreateBinary();
	xSemaphoreGive(RX_ESP_SEMAPHORE);*/
	TX_ESP_SEMAPHORE=xSemaphoreCreateBinary();
    7fa8:	43 e0       	ldi	r20, 0x03	; 3
    7faa:	60 e0       	ldi	r22, 0x00	; 0
    7fac:	81 e0       	ldi	r24, 0x01	; 1
    7fae:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <xQueueGenericCreate>
    7fb2:	90 93 e6 10 	sts	0x10E6, r25
    7fb6:	80 93 e5 10 	sts	0x10E5, r24
	xSemaphoreGive(TX_ESP_SEMAPHORE);
    7fba:	80 91 e5 10 	lds	r24, 0x10E5
    7fbe:	90 91 e6 10 	lds	r25, 0x10E6
    7fc2:	00 e0       	ldi	r16, 0x00	; 0
    7fc4:	20 e0       	ldi	r18, 0x00	; 0
    7fc6:	30 e0       	ldi	r19, 0x00	; 0
    7fc8:	a9 01       	movw	r20, r18
    7fca:	60 e0       	ldi	r22, 0x00	; 0
    7fcc:	70 e0       	ldi	r23, 0x00	; 0
    7fce:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <xQueueGenericSend>
	ESP_SEMAPHORE=xSemaphoreCreateBinary();
    7fd2:	43 e0       	ldi	r20, 0x03	; 3
    7fd4:	60 e0       	ldi	r22, 0x00	; 0
    7fd6:	81 e0       	ldi	r24, 0x01	; 1
    7fd8:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <xQueueGenericCreate>
    7fdc:	90 93 6d 10 	sts	0x106D, r25
    7fe0:	80 93 6c 10 	sts	0x106C, r24
	RX_ESP_QUEUE=xQueueCreate(255,1);
    7fe4:	40 e0       	ldi	r20, 0x00	; 0
    7fe6:	61 e0       	ldi	r22, 0x01	; 1
    7fe8:	8f ef       	ldi	r24, 0xFF	; 255
    7fea:	0e 94 8c 15 	call	0x2b18	; 0x2b18 <xQueueGenericCreate>
    7fee:	90 93 6f 10 	sts	0x106F, r25
    7ff2:	80 93 6e 10 	sts	0x106E, r24
	TEST_UART_SEND_str("que");
    7ff6:	84 e7       	ldi	r24, 0x74	; 116
    7ff8:	94 e0       	ldi	r25, 0x04	; 4
    7ffa:	0f dd       	rcall	.-1506   	; 0x7a1a <TEST_UART_SEND_str>
	TEST_UART_SEND_VALUE(RX_ESP_QUEUE);
    7ffc:	e0 91 6e 10 	lds	r30, 0x106E
    8000:	f0 91 6f 10 	lds	r31, 0x106F
    8004:	9f 2f       	mov	r25, r31
    8006:	99 0f       	add	r25, r25
    8008:	99 0b       	sbc	r25, r25
    800a:	2e 2f       	mov	r18, r30
    800c:	3f 2f       	mov	r19, r31
    800e:	49 2f       	mov	r20, r25
    8010:	59 2f       	mov	r21, r25
    8012:	69 2f       	mov	r22, r25
    8014:	79 2f       	mov	r23, r25
    8016:	89 2f       	mov	r24, r25
    8018:	10 dd       	rcall	.-1504   	; 0x7a3a <TEST_UART_SEND_VALUE>
	
	
	if (ESP_SETUP()==0)
    801a:	0e 94 df 09 	call	0x13be	; 0x13be <ESP_SETUP>
    801e:	81 11       	cpse	r24, r1
    8020:	0f c0       	rjmp	.+30     	; 0x8040 <WIFI_TASK+0x98>
	{
		xSemaphoreGive(ESP_SEMAPHORE);
    8022:	20 e0       	ldi	r18, 0x00	; 0
    8024:	30 e0       	ldi	r19, 0x00	; 0
    8026:	a9 01       	movw	r20, r18
    8028:	60 e0       	ldi	r22, 0x00	; 0
    802a:	70 e0       	ldi	r23, 0x00	; 0
    802c:	80 91 6c 10 	lds	r24, 0x106C
    8030:	90 91 6d 10 	lds	r25, 0x106D
    8034:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <xQueueGenericSend>
		TEST_UART_SEND_str("ESP READY\n");
    8038:	88 e7       	ldi	r24, 0x78	; 120
    803a:	94 e0       	ldi	r25, 0x04	; 4
    803c:	ee dc       	rcall	.-1572   	; 0x7a1a <TEST_UART_SEND_str>
    803e:	03 c0       	rjmp	.+6      	; 0x8046 <WIFI_TASK+0x9e>
	}
	else
	{
		TEST_UART_SEND_str("ESP NOT READY\n");
    8040:	83 e8       	ldi	r24, 0x83	; 131
    8042:	94 e0       	ldi	r25, 0x04	; 4
    8044:	ea dc       	rcall	.-1580   	; 0x7a1a <TEST_UART_SEND_str>
	}
	WIFI_LOAD_PARAMETERS();
    8046:	61 dd       	rcall	.-1342   	; 0x7b0a <WIFI_LOAD_PARAMETERS>
	TEST_ADD_USER_PASS();
    8048:	8f dc       	rcall	.-1762   	; 0x7968 <TEST_ADD_USER_PASS>
	TEST_ADD_IOT_PARAMETERS();
    804a:	30 dc       	rcall	.-1952   	; 0x78ac <TEST_ADD_IOT_PARAMETERS>
	while (1)
	{
		 if (xSemaphoreTake(ESP_SEMAPHORE,0)==pdFAIL)
    804c:	40 e0       	ldi	r20, 0x00	; 0
    804e:	50 e0       	ldi	r21, 0x00	; 0
    8050:	ba 01       	movw	r22, r20
    8052:	80 91 6c 10 	lds	r24, 0x106C
    8056:	90 91 6d 10 	lds	r25, 0x106D
    805a:	0e 94 45 17 	call	0x2e8a	; 0x2e8a <xQueueSemaphoreTake>
    805e:	81 11       	cpse	r24, r1
    8060:	11 c0       	rjmp	.+34     	; 0x8084 <WIFI_TASK+0xdc>
		 {
			 if (ESP_SETUP()==0)
    8062:	0e 94 df 09 	call	0x13be	; 0x13be <ESP_SETUP>
    8066:	81 11       	cpse	r24, r1
    8068:	1a c0       	rjmp	.+52     	; 0x809e <WIFI_TASK+0xf6>
			 {
				 xSemaphoreGive(ESP_SEMAPHORE);
    806a:	00 e0       	ldi	r16, 0x00	; 0
    806c:	20 e0       	ldi	r18, 0x00	; 0
    806e:	30 e0       	ldi	r19, 0x00	; 0
    8070:	a9 01       	movw	r20, r18
    8072:	60 e0       	ldi	r22, 0x00	; 0
    8074:	70 e0       	ldi	r23, 0x00	; 0
    8076:	80 91 6c 10 	lds	r24, 0x106C
    807a:	90 91 6d 10 	lds	r25, 0x106D
    807e:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <xQueueGenericSend>
    8082:	0d c0       	rjmp	.+26     	; 0x809e <WIFI_TASK+0xf6>
			 }
		 }
		 else
		 {
			WIFI_LOOP();
    8084:	9d de       	rcall	.-710    	; 0x7dc0 <WIFI_LOOP>
			xSemaphoreGive(ESP_SEMAPHORE);
    8086:	00 e0       	ldi	r16, 0x00	; 0
    8088:	20 e0       	ldi	r18, 0x00	; 0
    808a:	30 e0       	ldi	r19, 0x00	; 0
    808c:	a9 01       	movw	r20, r18
    808e:	60 e0       	ldi	r22, 0x00	; 0
    8090:	70 e0       	ldi	r23, 0x00	; 0
    8092:	80 91 6c 10 	lds	r24, 0x106C
    8096:	90 91 6d 10 	lds	r25, 0x106D
    809a:	0e 94 b7 15 	call	0x2b6e	; 0x2b6e <xQueueGenericSend>
		 }
		 
		 vTaskDelay(pdMS_TO_TICKS(10));
    809e:	61 e0       	ldi	r22, 0x01	; 1
    80a0:	70 e0       	ldi	r23, 0x00	; 0
    80a2:	80 e0       	ldi	r24, 0x00	; 0
    80a4:	90 e0       	ldi	r25, 0x00	; 0
    80a6:	0e 94 15 1b 	call	0x362a	; 0x362a <vTaskDelay>
	}
    80aa:	d0 cf       	rjmp	.-96     	; 0x804c <WIFI_TASK+0xa4>

000080ac <WIFI_TIMER3>:
}

void WIFI_TIMER3()
{
	
	if (F_T_TRY_TO_CONNECT!=MAX_F_T_TRY_TO_CONNECT)
    80ac:	80 91 c2 10 	lds	r24, 0x10C2
    80b0:	84 31       	cpi	r24, 0x14	; 20
    80b2:	29 f0       	breq	.+10     	; 0x80be <WIFI_TIMER3+0x12>
	{
		F_T_TRY_TO_CONNECT++;
    80b4:	80 91 c2 10 	lds	r24, 0x10C2
    80b8:	8f 5f       	subi	r24, 0xFF	; 255
    80ba:	80 93 c2 10 	sts	0x10C2, r24
	}
	if (F_T_READY_TO_READ!=MAX_T_READY_TO_READ)
    80be:	80 91 c3 10 	lds	r24, 0x10C3
    80c2:	82 30       	cpi	r24, 0x02	; 2
    80c4:	29 f0       	breq	.+10     	; 0x80d0 <WIFI_TIMER3+0x24>
	{
		F_T_READY_TO_READ++;
    80c6:	80 91 c3 10 	lds	r24, 0x10C3
    80ca:	8f 5f       	subi	r24, 0xFF	; 255
    80cc:	80 93 c3 10 	sts	0x10C3, r24
	}
	if (F_T_READY_TO_SEND!=MAX_T_READY_TO_SEND)
    80d0:	80 91 e8 10 	lds	r24, 0x10E8
    80d4:	84 30       	cpi	r24, 0x04	; 4
    80d6:	29 f0       	breq	.+10     	; 0x80e2 <WIFI_TIMER3+0x36>
	{
		F_T_READY_TO_SEND++;
    80d8:	80 91 e8 10 	lds	r24, 0x10E8
    80dc:	8f 5f       	subi	r24, 0xFF	; 255
    80de:	80 93 e8 10 	sts	0x10E8, r24
    80e2:	08 95       	ret

000080e4 <WIFI_RESET>:

void WIFI_RESET()
{
	
	
		writeeeprom(MY_EEPROM_CHECK_AVAILABLE_USER_PASS,0XFF);
    80e4:	6f ef       	ldi	r22, 0xFF	; 255
    80e6:	80 e0       	ldi	r24, 0x00	; 0
    80e8:	90 e0       	ldi	r25, 0x00	; 0
    80ea:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
		writeeeprom(MY_EEPROM_CHECK_AVAILABLE_IOT_PAR,0XFF);
    80ee:	6f ef       	ldi	r22, 0xFF	; 255
    80f0:	81 e2       	ldi	r24, 0x21	; 33
    80f2:	90 e0       	ldi	r25, 0x00	; 0
    80f4:	0e 94 48 1c 	call	0x3890	; 0x3890 <writeeeprom>
		F_WIFI_CONNECTED=0;
    80f8:	10 92 5b 0c 	sts	0x0C5B, r1
		F_VALID_USER_PASS=0;
    80fc:	10 92 b6 10 	sts	0x10B6, r1
		F_VALID_IOT_PAR=0;
    8100:	10 92 e3 10 	sts	0x10E3, r1
    8104:	08 95       	ret

00008106 <__subsf3>:
    8106:	50 58       	subi	r21, 0x80	; 128

00008108 <__addsf3>:
    8108:	bb 27       	eor	r27, r27
    810a:	aa 27       	eor	r26, r26
    810c:	0e d0       	rcall	.+28     	; 0x812a <__addsf3x>
    810e:	48 c1       	rjmp	.+656    	; 0x83a0 <__fp_round>
    8110:	39 d1       	rcall	.+626    	; 0x8384 <__fp_pscA>
    8112:	30 f0       	brcs	.+12     	; 0x8120 <__addsf3+0x18>
    8114:	3e d1       	rcall	.+636    	; 0x8392 <__fp_pscB>
    8116:	20 f0       	brcs	.+8      	; 0x8120 <__addsf3+0x18>
    8118:	31 f4       	brne	.+12     	; 0x8126 <__addsf3+0x1e>
    811a:	9f 3f       	cpi	r25, 0xFF	; 255
    811c:	11 f4       	brne	.+4      	; 0x8122 <__addsf3+0x1a>
    811e:	1e f4       	brtc	.+6      	; 0x8126 <__addsf3+0x1e>
    8120:	2e c1       	rjmp	.+604    	; 0x837e <__fp_nan>
    8122:	0e f4       	brtc	.+2      	; 0x8126 <__addsf3+0x1e>
    8124:	e0 95       	com	r30
    8126:	e7 fb       	bst	r30, 7
    8128:	24 c1       	rjmp	.+584    	; 0x8372 <__fp_inf>

0000812a <__addsf3x>:
    812a:	e9 2f       	mov	r30, r25
    812c:	4a d1       	rcall	.+660    	; 0x83c2 <__fp_split3>
    812e:	80 f3       	brcs	.-32     	; 0x8110 <__addsf3+0x8>
    8130:	ba 17       	cp	r27, r26
    8132:	62 07       	cpc	r22, r18
    8134:	73 07       	cpc	r23, r19
    8136:	84 07       	cpc	r24, r20
    8138:	95 07       	cpc	r25, r21
    813a:	18 f0       	brcs	.+6      	; 0x8142 <__addsf3x+0x18>
    813c:	71 f4       	brne	.+28     	; 0x815a <__addsf3x+0x30>
    813e:	9e f5       	brtc	.+102    	; 0x81a6 <__addsf3x+0x7c>
    8140:	62 c1       	rjmp	.+708    	; 0x8406 <__fp_zero>
    8142:	0e f4       	brtc	.+2      	; 0x8146 <__addsf3x+0x1c>
    8144:	e0 95       	com	r30
    8146:	0b 2e       	mov	r0, r27
    8148:	ba 2f       	mov	r27, r26
    814a:	a0 2d       	mov	r26, r0
    814c:	0b 01       	movw	r0, r22
    814e:	b9 01       	movw	r22, r18
    8150:	90 01       	movw	r18, r0
    8152:	0c 01       	movw	r0, r24
    8154:	ca 01       	movw	r24, r20
    8156:	a0 01       	movw	r20, r0
    8158:	11 24       	eor	r1, r1
    815a:	ff 27       	eor	r31, r31
    815c:	59 1b       	sub	r21, r25
    815e:	99 f0       	breq	.+38     	; 0x8186 <__addsf3x+0x5c>
    8160:	59 3f       	cpi	r21, 0xF9	; 249
    8162:	50 f4       	brcc	.+20     	; 0x8178 <__addsf3x+0x4e>
    8164:	50 3e       	cpi	r21, 0xE0	; 224
    8166:	68 f1       	brcs	.+90     	; 0x81c2 <__addsf3x+0x98>
    8168:	1a 16       	cp	r1, r26
    816a:	f0 40       	sbci	r31, 0x00	; 0
    816c:	a2 2f       	mov	r26, r18
    816e:	23 2f       	mov	r18, r19
    8170:	34 2f       	mov	r19, r20
    8172:	44 27       	eor	r20, r20
    8174:	58 5f       	subi	r21, 0xF8	; 248
    8176:	f3 cf       	rjmp	.-26     	; 0x815e <__addsf3x+0x34>
    8178:	46 95       	lsr	r20
    817a:	37 95       	ror	r19
    817c:	27 95       	ror	r18
    817e:	a7 95       	ror	r26
    8180:	f0 40       	sbci	r31, 0x00	; 0
    8182:	53 95       	inc	r21
    8184:	c9 f7       	brne	.-14     	; 0x8178 <__addsf3x+0x4e>
    8186:	7e f4       	brtc	.+30     	; 0x81a6 <__addsf3x+0x7c>
    8188:	1f 16       	cp	r1, r31
    818a:	ba 0b       	sbc	r27, r26
    818c:	62 0b       	sbc	r22, r18
    818e:	73 0b       	sbc	r23, r19
    8190:	84 0b       	sbc	r24, r20
    8192:	ba f0       	brmi	.+46     	; 0x81c2 <__addsf3x+0x98>
    8194:	91 50       	subi	r25, 0x01	; 1
    8196:	a1 f0       	breq	.+40     	; 0x81c0 <__addsf3x+0x96>
    8198:	ff 0f       	add	r31, r31
    819a:	bb 1f       	adc	r27, r27
    819c:	66 1f       	adc	r22, r22
    819e:	77 1f       	adc	r23, r23
    81a0:	88 1f       	adc	r24, r24
    81a2:	c2 f7       	brpl	.-16     	; 0x8194 <__addsf3x+0x6a>
    81a4:	0e c0       	rjmp	.+28     	; 0x81c2 <__addsf3x+0x98>
    81a6:	ba 0f       	add	r27, r26
    81a8:	62 1f       	adc	r22, r18
    81aa:	73 1f       	adc	r23, r19
    81ac:	84 1f       	adc	r24, r20
    81ae:	48 f4       	brcc	.+18     	; 0x81c2 <__addsf3x+0x98>
    81b0:	87 95       	ror	r24
    81b2:	77 95       	ror	r23
    81b4:	67 95       	ror	r22
    81b6:	b7 95       	ror	r27
    81b8:	f7 95       	ror	r31
    81ba:	9e 3f       	cpi	r25, 0xFE	; 254
    81bc:	08 f0       	brcs	.+2      	; 0x81c0 <__addsf3x+0x96>
    81be:	b3 cf       	rjmp	.-154    	; 0x8126 <__addsf3+0x1e>
    81c0:	93 95       	inc	r25
    81c2:	88 0f       	add	r24, r24
    81c4:	08 f0       	brcs	.+2      	; 0x81c8 <__addsf3x+0x9e>
    81c6:	99 27       	eor	r25, r25
    81c8:	ee 0f       	add	r30, r30
    81ca:	97 95       	ror	r25
    81cc:	87 95       	ror	r24
    81ce:	08 95       	ret

000081d0 <__divsf3>:
    81d0:	0c d0       	rcall	.+24     	; 0x81ea <__divsf3x>
    81d2:	e6 c0       	rjmp	.+460    	; 0x83a0 <__fp_round>
    81d4:	de d0       	rcall	.+444    	; 0x8392 <__fp_pscB>
    81d6:	40 f0       	brcs	.+16     	; 0x81e8 <__divsf3+0x18>
    81d8:	d5 d0       	rcall	.+426    	; 0x8384 <__fp_pscA>
    81da:	30 f0       	brcs	.+12     	; 0x81e8 <__divsf3+0x18>
    81dc:	21 f4       	brne	.+8      	; 0x81e6 <__divsf3+0x16>
    81de:	5f 3f       	cpi	r21, 0xFF	; 255
    81e0:	19 f0       	breq	.+6      	; 0x81e8 <__divsf3+0x18>
    81e2:	c7 c0       	rjmp	.+398    	; 0x8372 <__fp_inf>
    81e4:	51 11       	cpse	r21, r1
    81e6:	10 c1       	rjmp	.+544    	; 0x8408 <__fp_szero>
    81e8:	ca c0       	rjmp	.+404    	; 0x837e <__fp_nan>

000081ea <__divsf3x>:
    81ea:	eb d0       	rcall	.+470    	; 0x83c2 <__fp_split3>
    81ec:	98 f3       	brcs	.-26     	; 0x81d4 <__divsf3+0x4>

000081ee <__divsf3_pse>:
    81ee:	99 23       	and	r25, r25
    81f0:	c9 f3       	breq	.-14     	; 0x81e4 <__divsf3+0x14>
    81f2:	55 23       	and	r21, r21
    81f4:	b1 f3       	breq	.-20     	; 0x81e2 <__divsf3+0x12>
    81f6:	95 1b       	sub	r25, r21
    81f8:	55 0b       	sbc	r21, r21
    81fa:	bb 27       	eor	r27, r27
    81fc:	aa 27       	eor	r26, r26
    81fe:	62 17       	cp	r22, r18
    8200:	73 07       	cpc	r23, r19
    8202:	84 07       	cpc	r24, r20
    8204:	38 f0       	brcs	.+14     	; 0x8214 <__divsf3_pse+0x26>
    8206:	9f 5f       	subi	r25, 0xFF	; 255
    8208:	5f 4f       	sbci	r21, 0xFF	; 255
    820a:	22 0f       	add	r18, r18
    820c:	33 1f       	adc	r19, r19
    820e:	44 1f       	adc	r20, r20
    8210:	aa 1f       	adc	r26, r26
    8212:	a9 f3       	breq	.-22     	; 0x81fe <__divsf3_pse+0x10>
    8214:	33 d0       	rcall	.+102    	; 0x827c <__divsf3_pse+0x8e>
    8216:	0e 2e       	mov	r0, r30
    8218:	3a f0       	brmi	.+14     	; 0x8228 <__divsf3_pse+0x3a>
    821a:	e0 e8       	ldi	r30, 0x80	; 128
    821c:	30 d0       	rcall	.+96     	; 0x827e <__divsf3_pse+0x90>
    821e:	91 50       	subi	r25, 0x01	; 1
    8220:	50 40       	sbci	r21, 0x00	; 0
    8222:	e6 95       	lsr	r30
    8224:	00 1c       	adc	r0, r0
    8226:	ca f7       	brpl	.-14     	; 0x821a <__divsf3_pse+0x2c>
    8228:	29 d0       	rcall	.+82     	; 0x827c <__divsf3_pse+0x8e>
    822a:	fe 2f       	mov	r31, r30
    822c:	27 d0       	rcall	.+78     	; 0x827c <__divsf3_pse+0x8e>
    822e:	66 0f       	add	r22, r22
    8230:	77 1f       	adc	r23, r23
    8232:	88 1f       	adc	r24, r24
    8234:	bb 1f       	adc	r27, r27
    8236:	26 17       	cp	r18, r22
    8238:	37 07       	cpc	r19, r23
    823a:	48 07       	cpc	r20, r24
    823c:	ab 07       	cpc	r26, r27
    823e:	b0 e8       	ldi	r27, 0x80	; 128
    8240:	09 f0       	breq	.+2      	; 0x8244 <__divsf3_pse+0x56>
    8242:	bb 0b       	sbc	r27, r27
    8244:	80 2d       	mov	r24, r0
    8246:	bf 01       	movw	r22, r30
    8248:	ff 27       	eor	r31, r31
    824a:	93 58       	subi	r25, 0x83	; 131
    824c:	5f 4f       	sbci	r21, 0xFF	; 255
    824e:	2a f0       	brmi	.+10     	; 0x825a <__divsf3_pse+0x6c>
    8250:	9e 3f       	cpi	r25, 0xFE	; 254
    8252:	51 05       	cpc	r21, r1
    8254:	68 f0       	brcs	.+26     	; 0x8270 <__divsf3_pse+0x82>
    8256:	8d c0       	rjmp	.+282    	; 0x8372 <__fp_inf>
    8258:	d7 c0       	rjmp	.+430    	; 0x8408 <__fp_szero>
    825a:	5f 3f       	cpi	r21, 0xFF	; 255
    825c:	ec f3       	brlt	.-6      	; 0x8258 <__divsf3_pse+0x6a>
    825e:	98 3e       	cpi	r25, 0xE8	; 232
    8260:	dc f3       	brlt	.-10     	; 0x8258 <__divsf3_pse+0x6a>
    8262:	86 95       	lsr	r24
    8264:	77 95       	ror	r23
    8266:	67 95       	ror	r22
    8268:	b7 95       	ror	r27
    826a:	f7 95       	ror	r31
    826c:	9f 5f       	subi	r25, 0xFF	; 255
    826e:	c9 f7       	brne	.-14     	; 0x8262 <__divsf3_pse+0x74>
    8270:	88 0f       	add	r24, r24
    8272:	91 1d       	adc	r25, r1
    8274:	96 95       	lsr	r25
    8276:	87 95       	ror	r24
    8278:	97 f9       	bld	r25, 7
    827a:	08 95       	ret
    827c:	e1 e0       	ldi	r30, 0x01	; 1
    827e:	66 0f       	add	r22, r22
    8280:	77 1f       	adc	r23, r23
    8282:	88 1f       	adc	r24, r24
    8284:	bb 1f       	adc	r27, r27
    8286:	62 17       	cp	r22, r18
    8288:	73 07       	cpc	r23, r19
    828a:	84 07       	cpc	r24, r20
    828c:	ba 07       	cpc	r27, r26
    828e:	20 f0       	brcs	.+8      	; 0x8298 <__divsf3_pse+0xaa>
    8290:	62 1b       	sub	r22, r18
    8292:	73 0b       	sbc	r23, r19
    8294:	84 0b       	sbc	r24, r20
    8296:	ba 0b       	sbc	r27, r26
    8298:	ee 1f       	adc	r30, r30
    829a:	88 f7       	brcc	.-30     	; 0x827e <__divsf3_pse+0x90>
    829c:	e0 95       	com	r30
    829e:	08 95       	ret

000082a0 <__fixunssfsi>:
    82a0:	98 d0       	rcall	.+304    	; 0x83d2 <__fp_splitA>
    82a2:	88 f0       	brcs	.+34     	; 0x82c6 <__fixunssfsi+0x26>
    82a4:	9f 57       	subi	r25, 0x7F	; 127
    82a6:	90 f0       	brcs	.+36     	; 0x82cc <__fixunssfsi+0x2c>
    82a8:	b9 2f       	mov	r27, r25
    82aa:	99 27       	eor	r25, r25
    82ac:	b7 51       	subi	r27, 0x17	; 23
    82ae:	a0 f0       	brcs	.+40     	; 0x82d8 <__fixunssfsi+0x38>
    82b0:	d1 f0       	breq	.+52     	; 0x82e6 <__fixunssfsi+0x46>
    82b2:	66 0f       	add	r22, r22
    82b4:	77 1f       	adc	r23, r23
    82b6:	88 1f       	adc	r24, r24
    82b8:	99 1f       	adc	r25, r25
    82ba:	1a f0       	brmi	.+6      	; 0x82c2 <__fixunssfsi+0x22>
    82bc:	ba 95       	dec	r27
    82be:	c9 f7       	brne	.-14     	; 0x82b2 <__fixunssfsi+0x12>
    82c0:	12 c0       	rjmp	.+36     	; 0x82e6 <__fixunssfsi+0x46>
    82c2:	b1 30       	cpi	r27, 0x01	; 1
    82c4:	81 f0       	breq	.+32     	; 0x82e6 <__fixunssfsi+0x46>
    82c6:	9f d0       	rcall	.+318    	; 0x8406 <__fp_zero>
    82c8:	b1 e0       	ldi	r27, 0x01	; 1
    82ca:	08 95       	ret
    82cc:	9c c0       	rjmp	.+312    	; 0x8406 <__fp_zero>
    82ce:	67 2f       	mov	r22, r23
    82d0:	78 2f       	mov	r23, r24
    82d2:	88 27       	eor	r24, r24
    82d4:	b8 5f       	subi	r27, 0xF8	; 248
    82d6:	39 f0       	breq	.+14     	; 0x82e6 <__fixunssfsi+0x46>
    82d8:	b9 3f       	cpi	r27, 0xF9	; 249
    82da:	cc f3       	brlt	.-14     	; 0x82ce <__fixunssfsi+0x2e>
    82dc:	86 95       	lsr	r24
    82de:	77 95       	ror	r23
    82e0:	67 95       	ror	r22
    82e2:	b3 95       	inc	r27
    82e4:	d9 f7       	brne	.-10     	; 0x82dc <__fixunssfsi+0x3c>
    82e6:	3e f4       	brtc	.+14     	; 0x82f6 <__fixunssfsi+0x56>
    82e8:	90 95       	com	r25
    82ea:	80 95       	com	r24
    82ec:	70 95       	com	r23
    82ee:	61 95       	neg	r22
    82f0:	7f 4f       	sbci	r23, 0xFF	; 255
    82f2:	8f 4f       	sbci	r24, 0xFF	; 255
    82f4:	9f 4f       	sbci	r25, 0xFF	; 255
    82f6:	08 95       	ret

000082f8 <__floatunsisf>:
    82f8:	e8 94       	clt
    82fa:	09 c0       	rjmp	.+18     	; 0x830e <__floatsisf+0x12>

000082fc <__floatsisf>:
    82fc:	97 fb       	bst	r25, 7
    82fe:	3e f4       	brtc	.+14     	; 0x830e <__floatsisf+0x12>
    8300:	90 95       	com	r25
    8302:	80 95       	com	r24
    8304:	70 95       	com	r23
    8306:	61 95       	neg	r22
    8308:	7f 4f       	sbci	r23, 0xFF	; 255
    830a:	8f 4f       	sbci	r24, 0xFF	; 255
    830c:	9f 4f       	sbci	r25, 0xFF	; 255
    830e:	99 23       	and	r25, r25
    8310:	a9 f0       	breq	.+42     	; 0x833c <__floatsisf+0x40>
    8312:	f9 2f       	mov	r31, r25
    8314:	96 e9       	ldi	r25, 0x96	; 150
    8316:	bb 27       	eor	r27, r27
    8318:	93 95       	inc	r25
    831a:	f6 95       	lsr	r31
    831c:	87 95       	ror	r24
    831e:	77 95       	ror	r23
    8320:	67 95       	ror	r22
    8322:	b7 95       	ror	r27
    8324:	f1 11       	cpse	r31, r1
    8326:	f8 cf       	rjmp	.-16     	; 0x8318 <__floatsisf+0x1c>
    8328:	fa f4       	brpl	.+62     	; 0x8368 <__floatsisf+0x6c>
    832a:	bb 0f       	add	r27, r27
    832c:	11 f4       	brne	.+4      	; 0x8332 <__floatsisf+0x36>
    832e:	60 ff       	sbrs	r22, 0
    8330:	1b c0       	rjmp	.+54     	; 0x8368 <__floatsisf+0x6c>
    8332:	6f 5f       	subi	r22, 0xFF	; 255
    8334:	7f 4f       	sbci	r23, 0xFF	; 255
    8336:	8f 4f       	sbci	r24, 0xFF	; 255
    8338:	9f 4f       	sbci	r25, 0xFF	; 255
    833a:	16 c0       	rjmp	.+44     	; 0x8368 <__floatsisf+0x6c>
    833c:	88 23       	and	r24, r24
    833e:	11 f0       	breq	.+4      	; 0x8344 <__floatsisf+0x48>
    8340:	96 e9       	ldi	r25, 0x96	; 150
    8342:	11 c0       	rjmp	.+34     	; 0x8366 <__floatsisf+0x6a>
    8344:	77 23       	and	r23, r23
    8346:	21 f0       	breq	.+8      	; 0x8350 <__floatsisf+0x54>
    8348:	9e e8       	ldi	r25, 0x8E	; 142
    834a:	87 2f       	mov	r24, r23
    834c:	76 2f       	mov	r23, r22
    834e:	05 c0       	rjmp	.+10     	; 0x835a <__floatsisf+0x5e>
    8350:	66 23       	and	r22, r22
    8352:	71 f0       	breq	.+28     	; 0x8370 <__floatsisf+0x74>
    8354:	96 e8       	ldi	r25, 0x86	; 134
    8356:	86 2f       	mov	r24, r22
    8358:	70 e0       	ldi	r23, 0x00	; 0
    835a:	60 e0       	ldi	r22, 0x00	; 0
    835c:	2a f0       	brmi	.+10     	; 0x8368 <__floatsisf+0x6c>
    835e:	9a 95       	dec	r25
    8360:	66 0f       	add	r22, r22
    8362:	77 1f       	adc	r23, r23
    8364:	88 1f       	adc	r24, r24
    8366:	da f7       	brpl	.-10     	; 0x835e <__floatsisf+0x62>
    8368:	88 0f       	add	r24, r24
    836a:	96 95       	lsr	r25
    836c:	87 95       	ror	r24
    836e:	97 f9       	bld	r25, 7
    8370:	08 95       	ret

00008372 <__fp_inf>:
    8372:	97 f9       	bld	r25, 7
    8374:	9f 67       	ori	r25, 0x7F	; 127
    8376:	80 e8       	ldi	r24, 0x80	; 128
    8378:	70 e0       	ldi	r23, 0x00	; 0
    837a:	60 e0       	ldi	r22, 0x00	; 0
    837c:	08 95       	ret

0000837e <__fp_nan>:
    837e:	9f ef       	ldi	r25, 0xFF	; 255
    8380:	80 ec       	ldi	r24, 0xC0	; 192
    8382:	08 95       	ret

00008384 <__fp_pscA>:
    8384:	00 24       	eor	r0, r0
    8386:	0a 94       	dec	r0
    8388:	16 16       	cp	r1, r22
    838a:	17 06       	cpc	r1, r23
    838c:	18 06       	cpc	r1, r24
    838e:	09 06       	cpc	r0, r25
    8390:	08 95       	ret

00008392 <__fp_pscB>:
    8392:	00 24       	eor	r0, r0
    8394:	0a 94       	dec	r0
    8396:	12 16       	cp	r1, r18
    8398:	13 06       	cpc	r1, r19
    839a:	14 06       	cpc	r1, r20
    839c:	05 06       	cpc	r0, r21
    839e:	08 95       	ret

000083a0 <__fp_round>:
    83a0:	09 2e       	mov	r0, r25
    83a2:	03 94       	inc	r0
    83a4:	00 0c       	add	r0, r0
    83a6:	11 f4       	brne	.+4      	; 0x83ac <__fp_round+0xc>
    83a8:	88 23       	and	r24, r24
    83aa:	52 f0       	brmi	.+20     	; 0x83c0 <__fp_round+0x20>
    83ac:	bb 0f       	add	r27, r27
    83ae:	40 f4       	brcc	.+16     	; 0x83c0 <__fp_round+0x20>
    83b0:	bf 2b       	or	r27, r31
    83b2:	11 f4       	brne	.+4      	; 0x83b8 <__fp_round+0x18>
    83b4:	60 ff       	sbrs	r22, 0
    83b6:	04 c0       	rjmp	.+8      	; 0x83c0 <__fp_round+0x20>
    83b8:	6f 5f       	subi	r22, 0xFF	; 255
    83ba:	7f 4f       	sbci	r23, 0xFF	; 255
    83bc:	8f 4f       	sbci	r24, 0xFF	; 255
    83be:	9f 4f       	sbci	r25, 0xFF	; 255
    83c0:	08 95       	ret

000083c2 <__fp_split3>:
    83c2:	57 fd       	sbrc	r21, 7
    83c4:	90 58       	subi	r25, 0x80	; 128
    83c6:	44 0f       	add	r20, r20
    83c8:	55 1f       	adc	r21, r21
    83ca:	59 f0       	breq	.+22     	; 0x83e2 <__fp_splitA+0x10>
    83cc:	5f 3f       	cpi	r21, 0xFF	; 255
    83ce:	71 f0       	breq	.+28     	; 0x83ec <__fp_splitA+0x1a>
    83d0:	47 95       	ror	r20

000083d2 <__fp_splitA>:
    83d2:	88 0f       	add	r24, r24
    83d4:	97 fb       	bst	r25, 7
    83d6:	99 1f       	adc	r25, r25
    83d8:	61 f0       	breq	.+24     	; 0x83f2 <__fp_splitA+0x20>
    83da:	9f 3f       	cpi	r25, 0xFF	; 255
    83dc:	79 f0       	breq	.+30     	; 0x83fc <__fp_splitA+0x2a>
    83de:	87 95       	ror	r24
    83e0:	08 95       	ret
    83e2:	12 16       	cp	r1, r18
    83e4:	13 06       	cpc	r1, r19
    83e6:	14 06       	cpc	r1, r20
    83e8:	55 1f       	adc	r21, r21
    83ea:	f2 cf       	rjmp	.-28     	; 0x83d0 <__fp_split3+0xe>
    83ec:	46 95       	lsr	r20
    83ee:	f1 df       	rcall	.-30     	; 0x83d2 <__fp_splitA>
    83f0:	08 c0       	rjmp	.+16     	; 0x8402 <__fp_splitA+0x30>
    83f2:	16 16       	cp	r1, r22
    83f4:	17 06       	cpc	r1, r23
    83f6:	18 06       	cpc	r1, r24
    83f8:	99 1f       	adc	r25, r25
    83fa:	f1 cf       	rjmp	.-30     	; 0x83de <__fp_splitA+0xc>
    83fc:	86 95       	lsr	r24
    83fe:	71 05       	cpc	r23, r1
    8400:	61 05       	cpc	r22, r1
    8402:	08 94       	sec
    8404:	08 95       	ret

00008406 <__fp_zero>:
    8406:	e8 94       	clt

00008408 <__fp_szero>:
    8408:	bb 27       	eor	r27, r27
    840a:	66 27       	eor	r22, r22
    840c:	77 27       	eor	r23, r23
    840e:	cb 01       	movw	r24, r22
    8410:	97 f9       	bld	r25, 7
    8412:	08 95       	ret

00008414 <__udivmodsi4>:
    8414:	a1 e2       	ldi	r26, 0x21	; 33
    8416:	1a 2e       	mov	r1, r26
    8418:	aa 1b       	sub	r26, r26
    841a:	bb 1b       	sub	r27, r27
    841c:	fd 01       	movw	r30, r26
    841e:	0d c0       	rjmp	.+26     	; 0x843a <__udivmodsi4_ep>

00008420 <__udivmodsi4_loop>:
    8420:	aa 1f       	adc	r26, r26
    8422:	bb 1f       	adc	r27, r27
    8424:	ee 1f       	adc	r30, r30
    8426:	ff 1f       	adc	r31, r31
    8428:	a2 17       	cp	r26, r18
    842a:	b3 07       	cpc	r27, r19
    842c:	e4 07       	cpc	r30, r20
    842e:	f5 07       	cpc	r31, r21
    8430:	20 f0       	brcs	.+8      	; 0x843a <__udivmodsi4_ep>
    8432:	a2 1b       	sub	r26, r18
    8434:	b3 0b       	sbc	r27, r19
    8436:	e4 0b       	sbc	r30, r20
    8438:	f5 0b       	sbc	r31, r21

0000843a <__udivmodsi4_ep>:
    843a:	66 1f       	adc	r22, r22
    843c:	77 1f       	adc	r23, r23
    843e:	88 1f       	adc	r24, r24
    8440:	99 1f       	adc	r25, r25
    8442:	1a 94       	dec	r1
    8444:	69 f7       	brne	.-38     	; 0x8420 <__udivmodsi4_loop>
    8446:	60 95       	com	r22
    8448:	70 95       	com	r23
    844a:	80 95       	com	r24
    844c:	90 95       	com	r25
    844e:	9b 01       	movw	r18, r22
    8450:	ac 01       	movw	r20, r24
    8452:	bd 01       	movw	r22, r26
    8454:	cf 01       	movw	r24, r30
    8456:	08 95       	ret

00008458 <__tablejump2__>:
    8458:	ee 0f       	add	r30, r30
    845a:	ff 1f       	adc	r31, r31

0000845c <__tablejump__>:
    845c:	05 90       	lpm	r0, Z+
    845e:	f4 91       	lpm	r31, Z
    8460:	e0 2d       	mov	r30, r0
    8462:	09 94       	ijmp

00008464 <__umulhisi3>:
    8464:	a2 9f       	mul	r26, r18
    8466:	b0 01       	movw	r22, r0
    8468:	b3 9f       	mul	r27, r19
    846a:	c0 01       	movw	r24, r0
    846c:	a3 9f       	mul	r26, r19
    846e:	70 0d       	add	r23, r0
    8470:	81 1d       	adc	r24, r1
    8472:	11 24       	eor	r1, r1
    8474:	91 1d       	adc	r25, r1
    8476:	b2 9f       	mul	r27, r18
    8478:	70 0d       	add	r23, r0
    847a:	81 1d       	adc	r24, r1
    847c:	11 24       	eor	r1, r1
    847e:	91 1d       	adc	r25, r1
    8480:	08 95       	ret

00008482 <__muluhisi3>:
    8482:	f0 df       	rcall	.-32     	; 0x8464 <__umulhisi3>
    8484:	a5 9f       	mul	r26, r21
    8486:	90 0d       	add	r25, r0
    8488:	b4 9f       	mul	r27, r20
    848a:	90 0d       	add	r25, r0
    848c:	a4 9f       	mul	r26, r20
    848e:	80 0d       	add	r24, r0
    8490:	91 1d       	adc	r25, r1
    8492:	11 24       	eor	r1, r1
    8494:	08 95       	ret

00008496 <__umoddi3>:
    8496:	68 94       	set
    8498:	01 c0       	rjmp	.+2      	; 0x849c <__udivdi3_umoddi3>

0000849a <__udivdi3>:
    849a:	e8 94       	clt

0000849c <__udivdi3_umoddi3>:
    849c:	8f 92       	push	r8
    849e:	9f 92       	push	r9
    84a0:	cf 93       	push	r28
    84a2:	df 93       	push	r29
    84a4:	05 d0       	rcall	.+10     	; 0x84b0 <__udivmod64>
    84a6:	df 91       	pop	r29
    84a8:	cf 91       	pop	r28
    84aa:	9f 90       	pop	r9
    84ac:	8f 90       	pop	r8
    84ae:	08 95       	ret

000084b0 <__udivmod64>:
    84b0:	88 24       	eor	r8, r8
    84b2:	99 24       	eor	r9, r9
    84b4:	f4 01       	movw	r30, r8
    84b6:	e4 01       	movw	r28, r8
    84b8:	b0 e4       	ldi	r27, 0x40	; 64
    84ba:	9f 93       	push	r25
    84bc:	aa 27       	eor	r26, r26
    84be:	9a 15       	cp	r25, r10
    84c0:	8b 04       	cpc	r8, r11
    84c2:	9c 04       	cpc	r9, r12
    84c4:	ed 05       	cpc	r30, r13
    84c6:	fe 05       	cpc	r31, r14
    84c8:	cf 05       	cpc	r28, r15
    84ca:	d0 07       	cpc	r29, r16
    84cc:	a1 07       	cpc	r26, r17
    84ce:	98 f4       	brcc	.+38     	; 0x84f6 <__udivmod64+0x46>
    84d0:	ad 2f       	mov	r26, r29
    84d2:	dc 2f       	mov	r29, r28
    84d4:	cf 2f       	mov	r28, r31
    84d6:	fe 2f       	mov	r31, r30
    84d8:	e9 2d       	mov	r30, r9
    84da:	98 2c       	mov	r9, r8
    84dc:	89 2e       	mov	r8, r25
    84de:	98 2f       	mov	r25, r24
    84e0:	87 2f       	mov	r24, r23
    84e2:	76 2f       	mov	r23, r22
    84e4:	65 2f       	mov	r22, r21
    84e6:	54 2f       	mov	r21, r20
    84e8:	43 2f       	mov	r20, r19
    84ea:	32 2f       	mov	r19, r18
    84ec:	22 27       	eor	r18, r18
    84ee:	b8 50       	subi	r27, 0x08	; 8
    84f0:	31 f7       	brne	.-52     	; 0x84be <__udivmod64+0xe>
    84f2:	bf 91       	pop	r27
    84f4:	27 c0       	rjmp	.+78     	; 0x8544 <__udivmod64+0x94>
    84f6:	1b 2e       	mov	r1, r27
    84f8:	bf 91       	pop	r27
    84fa:	bb 27       	eor	r27, r27
    84fc:	22 0f       	add	r18, r18
    84fe:	33 1f       	adc	r19, r19
    8500:	44 1f       	adc	r20, r20
    8502:	55 1f       	adc	r21, r21
    8504:	66 1f       	adc	r22, r22
    8506:	77 1f       	adc	r23, r23
    8508:	88 1f       	adc	r24, r24
    850a:	99 1f       	adc	r25, r25
    850c:	88 1c       	adc	r8, r8
    850e:	99 1c       	adc	r9, r9
    8510:	ee 1f       	adc	r30, r30
    8512:	ff 1f       	adc	r31, r31
    8514:	cc 1f       	adc	r28, r28
    8516:	dd 1f       	adc	r29, r29
    8518:	aa 1f       	adc	r26, r26
    851a:	bb 1f       	adc	r27, r27
    851c:	8a 14       	cp	r8, r10
    851e:	9b 04       	cpc	r9, r11
    8520:	ec 05       	cpc	r30, r12
    8522:	fd 05       	cpc	r31, r13
    8524:	ce 05       	cpc	r28, r14
    8526:	df 05       	cpc	r29, r15
    8528:	a0 07       	cpc	r26, r16
    852a:	b1 07       	cpc	r27, r17
    852c:	48 f0       	brcs	.+18     	; 0x8540 <__udivmod64+0x90>
    852e:	8a 18       	sub	r8, r10
    8530:	9b 08       	sbc	r9, r11
    8532:	ec 09       	sbc	r30, r12
    8534:	fd 09       	sbc	r31, r13
    8536:	ce 09       	sbc	r28, r14
    8538:	df 09       	sbc	r29, r15
    853a:	a0 0b       	sbc	r26, r16
    853c:	b1 0b       	sbc	r27, r17
    853e:	21 60       	ori	r18, 0x01	; 1
    8540:	1a 94       	dec	r1
    8542:	e1 f6       	brne	.-72     	; 0x84fc <__udivmod64+0x4c>
    8544:	2e f4       	brtc	.+10     	; 0x8550 <__udivmod64+0xa0>
    8546:	94 01       	movw	r18, r8
    8548:	af 01       	movw	r20, r30
    854a:	be 01       	movw	r22, r28
    854c:	cd 01       	movw	r24, r26
    854e:	00 0c       	add	r0, r0
    8550:	08 95       	ret

00008552 <__negdi2>:
    8552:	60 95       	com	r22
    8554:	70 95       	com	r23
    8556:	80 95       	com	r24
    8558:	90 95       	com	r25
    855a:	30 95       	com	r19
    855c:	40 95       	com	r20
    855e:	50 95       	com	r21
    8560:	21 95       	neg	r18
    8562:	3f 4f       	sbci	r19, 0xFF	; 255
    8564:	4f 4f       	sbci	r20, 0xFF	; 255
    8566:	5f 4f       	sbci	r21, 0xFF	; 255
    8568:	6f 4f       	sbci	r22, 0xFF	; 255
    856a:	7f 4f       	sbci	r23, 0xFF	; 255
    856c:	8f 4f       	sbci	r24, 0xFF	; 255
    856e:	9f 4f       	sbci	r25, 0xFF	; 255
    8570:	08 95       	ret

00008572 <__ashldi3>:
    8572:	0f 93       	push	r16
    8574:	08 30       	cpi	r16, 0x08	; 8
    8576:	90 f0       	brcs	.+36     	; 0x859c <__ashldi3+0x2a>
    8578:	98 2f       	mov	r25, r24
    857a:	87 2f       	mov	r24, r23
    857c:	76 2f       	mov	r23, r22
    857e:	65 2f       	mov	r22, r21
    8580:	54 2f       	mov	r21, r20
    8582:	43 2f       	mov	r20, r19
    8584:	32 2f       	mov	r19, r18
    8586:	22 27       	eor	r18, r18
    8588:	08 50       	subi	r16, 0x08	; 8
    858a:	f4 cf       	rjmp	.-24     	; 0x8574 <__ashldi3+0x2>
    858c:	22 0f       	add	r18, r18
    858e:	33 1f       	adc	r19, r19
    8590:	44 1f       	adc	r20, r20
    8592:	55 1f       	adc	r21, r21
    8594:	66 1f       	adc	r22, r22
    8596:	77 1f       	adc	r23, r23
    8598:	88 1f       	adc	r24, r24
    859a:	99 1f       	adc	r25, r25
    859c:	0a 95       	dec	r16
    859e:	b2 f7       	brpl	.-20     	; 0x858c <__ashldi3+0x1a>
    85a0:	0f 91       	pop	r16
    85a2:	08 95       	ret

000085a4 <__ashrdi3>:
    85a4:	97 fb       	bst	r25, 7
    85a6:	10 f8       	bld	r1, 0

000085a8 <__lshrdi3>:
    85a8:	16 94       	lsr	r1
    85aa:	00 08       	sbc	r0, r0
    85ac:	0f 93       	push	r16
    85ae:	08 30       	cpi	r16, 0x08	; 8
    85b0:	98 f0       	brcs	.+38     	; 0x85d8 <__lshrdi3+0x30>
    85b2:	08 50       	subi	r16, 0x08	; 8
    85b4:	23 2f       	mov	r18, r19
    85b6:	34 2f       	mov	r19, r20
    85b8:	45 2f       	mov	r20, r21
    85ba:	56 2f       	mov	r21, r22
    85bc:	67 2f       	mov	r22, r23
    85be:	78 2f       	mov	r23, r24
    85c0:	89 2f       	mov	r24, r25
    85c2:	90 2d       	mov	r25, r0
    85c4:	f4 cf       	rjmp	.-24     	; 0x85ae <__lshrdi3+0x6>
    85c6:	05 94       	asr	r0
    85c8:	97 95       	ror	r25
    85ca:	87 95       	ror	r24
    85cc:	77 95       	ror	r23
    85ce:	67 95       	ror	r22
    85d0:	57 95       	ror	r21
    85d2:	47 95       	ror	r20
    85d4:	37 95       	ror	r19
    85d6:	27 95       	ror	r18
    85d8:	0a 95       	dec	r16
    85da:	aa f7       	brpl	.-22     	; 0x85c6 <__lshrdi3+0x1e>
    85dc:	0f 91       	pop	r16
    85de:	08 95       	ret

000085e0 <__adddi3>:
    85e0:	2a 0d       	add	r18, r10
    85e2:	3b 1d       	adc	r19, r11
    85e4:	4c 1d       	adc	r20, r12
    85e6:	5d 1d       	adc	r21, r13
    85e8:	6e 1d       	adc	r22, r14
    85ea:	7f 1d       	adc	r23, r15
    85ec:	80 1f       	adc	r24, r16
    85ee:	91 1f       	adc	r25, r17
    85f0:	08 95       	ret

000085f2 <__adddi3_s8>:
    85f2:	00 24       	eor	r0, r0
    85f4:	a7 fd       	sbrc	r26, 7
    85f6:	00 94       	com	r0
    85f8:	2a 0f       	add	r18, r26
    85fa:	30 1d       	adc	r19, r0
    85fc:	40 1d       	adc	r20, r0
    85fe:	50 1d       	adc	r21, r0
    8600:	60 1d       	adc	r22, r0
    8602:	70 1d       	adc	r23, r0
    8604:	80 1d       	adc	r24, r0
    8606:	90 1d       	adc	r25, r0
    8608:	08 95       	ret

0000860a <__cmpdi2_s8>:
    860a:	00 24       	eor	r0, r0
    860c:	a7 fd       	sbrc	r26, 7
    860e:	00 94       	com	r0
    8610:	2a 17       	cp	r18, r26
    8612:	30 05       	cpc	r19, r0
    8614:	40 05       	cpc	r20, r0
    8616:	50 05       	cpc	r21, r0
    8618:	60 05       	cpc	r22, r0
    861a:	70 05       	cpc	r23, r0
    861c:	80 05       	cpc	r24, r0
    861e:	90 05       	cpc	r25, r0
    8620:	08 95       	ret

00008622 <memcpy>:
    8622:	fb 01       	movw	r30, r22
    8624:	dc 01       	movw	r26, r24
    8626:	02 c0       	rjmp	.+4      	; 0x862c <memcpy+0xa>
    8628:	01 90       	ld	r0, Z+
    862a:	0d 92       	st	X+, r0
    862c:	41 50       	subi	r20, 0x01	; 1
    862e:	50 40       	sbci	r21, 0x00	; 0
    8630:	d8 f7       	brcc	.-10     	; 0x8628 <memcpy+0x6>
    8632:	08 95       	ret

00008634 <_exit>:
    8634:	f8 94       	cli

00008636 <__stop_program>:
    8636:	ff cf       	rjmp	.-2      	; 0x8636 <__stop_program>
